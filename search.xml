<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>chatRoom</title>
      <link href="/2025/07/17/muduo/"/>
      <url>/2025/07/17/muduo/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Muduo-库"><a href="#C-Muduo-库" class="headerlink" title="C++ Muduo 库"></a>C++ Muduo 库</h1><p><a href="https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&vd_source=28887ecca1f25a715214067a2b3b58ac">https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac</a></p><p><img src="/../0_images/muduo/muduo%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="alt text"></p><p><img src="/../0_images/muduo/muduo%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="alt text"></p><h1 id="noncopyable-禁止拷贝"><a href="#noncopyable-禁止拷贝" class="headerlink" title="noncopyable 禁止拷贝"></a>noncopyable 禁止拷贝</h1><p>我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承noncopyable类，我们看一下noncopyable.h代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NONCOPYABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCOPYABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>noncopyable会取消拷贝构造，这样子类继承它之后，在调用构造函数进行构造的时候会默认调用父类的构造函数来构造父类的属性，因此当进行拷贝构造的时候就会发现，父类没有拷贝构造，因此就无法实现，从而无法实现拷贝构造</p><h1 id="Timestamp-时间类"><a href="#Timestamp-时间类" class="headerlink" title="Timestamp 时间类"></a>Timestamp 时间类</h1><p>主要是用于格式化输出当前的时间，向外提供接口就好，非常的简单</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIMESTAMP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMESTAMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timestamp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    <span class="built_in">Timestamp</span>(); </span><br><span class="line">    <span class="comment">//带参构造 explicit 是为了防止编译器将microSecondsSinceEpoch优化成int</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timestamp</span><span class="params">(<span class="type">int64_t</span> microSecondsSinceEpoch)</span></span>; </span><br><span class="line">    <span class="comment">//返回当前的Timestamp</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Timestamp <span class="title">now</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//转化为string输出 //一般是Timestamp::now().toString() 这样用</span></span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>():<span class="built_in">microSecondsSinceEpoch_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//带参构造</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>(<span class="type">int64_t</span> microSecondsSinceEpoch)</span><br><span class="line">    : <span class="built_in">microSecondsSinceEpoch_</span>(microSecondsSinceEpoch)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的Timestamp</span></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Timestamp</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化输出</span></span><br><span class="line"><span class="function">std::string <span class="title">Timestamp::toString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    tm *tm_time = <span class="built_in">localtime</span>(&amp;microSecondsSinceEpoch_);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">128</span>, <span class="string">&quot;%4d/%02d/%02d %02d:%02d:%02d&quot;</span>, </span><br><span class="line">        tm_time-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">        tm_time-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">        tm_time-&gt;tm_mday,</span><br><span class="line">        tm_time-&gt;tm_hour,</span><br><span class="line">        tm_time-&gt;tm_min,</span><br><span class="line">        tm_time-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; Timestamp::now().toString() &lt;&lt; std::endl; </span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="Logger-日志"><a href="#Logger-日志" class="headerlink" title="Logger 日志"></a>Logger 日志</h1><p>向外提供打印的接口，用以输出log信息，一共由四种信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义日志的级别 INFO ERROR FATAL DEBUG</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line">    INFO,  <span class="comment">// 普通信息</span></span><br><span class="line">    ERROR, <span class="comment">// 错误信息</span></span><br><span class="line">    FATAL, <span class="comment">// 崩溃信息(无法挽回的一些错误)</span></span><br><span class="line">    DEBUG, <span class="comment">// 调试信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Logger class 里面只需要设置最为简单的接口就好，不需要写在txt里面，如果写的话涉及到日志的回滚等操作，很复杂。详细的可以看webserver的日志</p><p>那么这里只需要</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="comment">// 写日志</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string message)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logLevel_; <span class="comment">//日志级别</span></span><br><span class="line">    <span class="comment">// 构造函数私有化 单例模式</span></span><br><span class="line">    <span class="built_in">Logger</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单例模式，使用static，以及构造函数私有化等操作，其他的还有设置日志级别以及写日志的基础操作就好</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Logger::setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    logLevel_ = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写日志 [级别日志] time : message</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(std::string message)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志级别</span></span><br><span class="line">    <span class="keyword">switch</span> (logLevel_) &#123;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FATAL:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[FATAL]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[DEBUG]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印时间和message</span></span><br><span class="line">    std::cout &lt;&lt; Timestamp::<span class="built_in">now</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上到这里日志class就已经完成的，但是如果用户使用的话就需要先 instance 初始化 再 setLogLevel 才能 log 打印，会很麻烦，而且logLevel不应该由用户来设置，咱们只需要定义一些宏向外提供接口就好</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(INFO);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(ERROR);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(FATAL);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">        exit(-1);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG的信息比较多，而且一般不提供给用户使用，因此设置一个MUDEBUG开关来操作一下</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(DEBUG);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>完整的代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGGER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义日志的级别 INFO ERROR FATAL DEBUG</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line">    INFO,  <span class="comment">// 普通信息</span></span><br><span class="line">    ERROR, <span class="comment">// 错误信息</span></span><br><span class="line">    FATAL, <span class="comment">// 崩溃信息(无法挽回的一些错误)</span></span><br><span class="line">    DEBUG, <span class="comment">// 调试信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一个日志类 //不需要进行拷贝构造和赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="comment">// 写日志</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string message)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logLevel_; <span class="comment">//日志级别</span></span><br><span class="line">    <span class="comment">// 构造函数私有化 单例模式</span></span><br><span class="line">    <span class="built_in">Logger</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 因为在用户使用的时候不可能初始化日志，设置日志的level等操作，因此定义好提供给用户使用的宏</span></span><br><span class="line"><span class="comment">// LOG_INFO(&quot;%s,%d&quot;,ard1,arg2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(INFO);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(ERROR);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(FATAL);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">        exit(-1);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG的信息比较多，而且一般不提供给用户使用，因此设置一个MUDEBUG开关来操作一下</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(DEBUG);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Logger::setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    logLevel_ = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写日志 [级别日志] time : message</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(std::string message)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志级别</span></span><br><span class="line">    <span class="keyword">switch</span> (logLevel_) &#123;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FATAL:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[FATAL]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[DEBUG]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印时间和message</span></span><br><span class="line">    std::cout &lt;&lt; Timestamp::<span class="built_in">now</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="InetAddress-address封装"><a href="#InetAddress-address封装" class="headerlink" title="InetAddress address封装"></a>InetAddress address封装</h1><p>主要是将IP和PORT进行封装，提供一些基础的接口 比如 toIp toIpPort toPort等,这里只做了IPV4的支持</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INETADDRESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INETADDRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装socket地址类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//两个构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="type">uint16_t</span> port = <span class="number">0</span>, std::string ip = <span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="type">const</span> sockaddr_in &amp;addr)</span>:addr_(addr)&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取IP</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIp</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取IP与Port</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIpPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取port</span></span><br><span class="line">    <span class="function"><span class="type">uint16_t</span> <span class="title">toPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//直接获取sockaddr_in</span></span><br><span class="line">    <span class="function"><span class="type">const</span> sockaddr_in* <span class="title">getSockAddr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> &amp;addr_;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSockAddr</span><span class="params">(<span class="type">const</span> sockaddr_in &amp;addr)</span> </span>&#123; addr_ = addr; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sockaddr_in addr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line">InetAddress::<span class="built_in">InetAddress</span>(<span class="type">uint16_t</span> port, std::string ip )&#123;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr_,<span class="built_in">sizeof</span>(addr_)); <span class="comment">//将addr_清零</span></span><br><span class="line">    addr_.sin_family = AF_INET;</span><br><span class="line">    addr_.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    addr_.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取IP</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得把addr_之中的网络字节序传成本地字节序</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 网络地址从二进制形式转换为点分十进制（IPv4）或冒号十六进制（IPv6）的字符串形式</span></span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET,&amp;addr_.sin_addr,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取IP与Port</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIpPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET,&amp;addr_.sin_addr,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="type">size_t</span> end = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+end,<span class="string">&quot;:%u&quot;</span>,port);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取port</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">InetAddress::toPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     InetAddress addr(8080);</span></span><br><span class="line"><span class="comment">//     std::cout&lt;&lt;addr.toIpPort()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h1><p>简单来说，就是将fd封装起来，和poller做配合。核心思想就是自己的事情自己做</p><p>fd一般会注册到poller里面，设置一些感兴趣的事件，比如 EPOLLIN  EPOLLOUT 等，然后设置一些回调事件，当发生事件的时候就执行这些回调</p><p>要注意的是Channel会注册到poller之中，但是他俩都是由EventLoop来控制的，EventLoop里面有一个poller和多个Channel</p><p>Channel的核心思想就是自己的事情自己做，因此会有很多的操作本身的操作，比如注册事件、删除本身等操作，这些事件会会在class类里面提供接口，但是需要EventLoop来调用从而操作poller</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHANNEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHANNEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接前置声明，不包含头文件,直接后面在源文件之中包含头文件，这样的话就可以直接编译成库从而不用提供给用户头文件的信息，防止泄漏更多的东西</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理清楚  EventLoop、Channel、Poller之间的关系   《= Reactor模型上对应 Demultiplex</span></span><br><span class="line"><span class="comment"> * Channel 理解为通道，封装可sockfd和其感兴趣的event 如EPOLLIN  EPOLLOUT</span></span><br><span class="line"><span class="comment"> * 还绑定了poller返回的具体事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//事件回调</span></span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="comment">//只读事件回调</span></span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in">void</span>(Timestamp)&gt;; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Channel</span>(EventLoop *loop,<span class="type">int</span> fd);</span><br><span class="line">    ~<span class="built_in">Channel</span>(); <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd得到poller通知以后，处理事件的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123;</span><br><span class="line">        readCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//读事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        writeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        closeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//关闭事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        errorCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//错误事件回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当channel被手动remove掉，channel还在执行回调，使用弱智能指针实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回绑定的fd</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fd_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回注册的事件</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 revents_ 真正发生的事件，这个接口是放给epoll和eventloop用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span></span>&#123;</span><br><span class="line">        revents_ = revt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fd相应的事件的状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ |= kReadEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//读事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ &amp;= ~kReadEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消读</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ |= kWriteEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//写事件 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ &amp;= ~kWriteEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ = kNoneEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消所有的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回fd当前的事件状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kNoneEvent;</span><br><span class="line">    &#125; <span class="comment">//对所有事件都不敢兴起</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kWriteEvent;</span><br><span class="line">    &#125; <span class="comment">//对写事件感兴趣</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReading</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kReadEvent;</span><br><span class="line">    &#125; <span class="comment">//对读事件感兴趣</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前的状态 -1：channel未添加到poller中 1 channel已添加到poller中 2 channel从poller中删除</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置状态，这个接口也是放给epoll和eventloop用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_index</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        index_ = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个线程有一个EventLoop，一个EventLoop里面有一个poller，一个poller可以监听很多的channel，因此一个channel需要有一个EventLoop。但是一个EventLoop可以包含很多的channel</span></span><br><span class="line">    <span class="comment">// 这个方法就是返回该channel属于那个EventLoop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">ownerLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除channel用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;  <span class="comment">//没有任何事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;  <span class="comment">//读事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent; <span class="comment">//写事件</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// 事件注册</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fd_;    <span class="comment">// fd,poller监听的对象</span></span><br><span class="line">    <span class="type">int</span> events_;      <span class="comment">// 注册fd感兴趣的事件</span></span><br><span class="line">    <span class="type">int</span> revents_;     <span class="comment">// poller返回的具体发生的事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // index表示什么？ 在 EpollPoller之中右这个</span></span><br><span class="line">    <span class="comment">// // channel未添加到poller中</span></span><br><span class="line">    <span class="comment">// const int kNew = -1;          // channel的成员index_ = -1</span></span><br><span class="line">    <span class="comment">// // channel已添加到poller中</span></span><br><span class="line">    <span class="comment">// const int kAdded = 1;</span></span><br><span class="line">    <span class="comment">// // channel从poller中删除</span></span><br><span class="line">    <span class="comment">// const int kDeleted = 2;</span></span><br><span class="line">    <span class="type">int</span> index_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak_ptr 可以转化为 share_ptr </span></span><br><span class="line">    <span class="comment">// 用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_;</span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Channel通道里面能够获取fd最终发生的事件的revents，所以它负责调用具体事件的回调操作</span></span><br><span class="line">    <span class="comment">// 这些方法需要用户传递过来</span></span><br><span class="line">    ReadEventCallback readCallback_;</span><br><span class="line">    EventCallback writeCallback_;</span><br><span class="line">    EventCallback closeCallback_;</span><br><span class="line">    EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;                   <span class="comment">//没有任何事件</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;  <span class="comment">//读事件</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = EPOLLOUT;           <span class="comment">//写事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop *loop,<span class="type">int</span> fd)</span><br><span class="line">    :<span class="built_in">loop_</span>(loop),<span class="built_in">fd_</span>(fd),<span class="built_in">events_</span>(<span class="number">0</span>),<span class="built_in">revents_</span>(<span class="number">0</span>),<span class="built_in">index_</span>(<span class="number">-1</span>),<span class="built_in">tied_</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Channel::~<span class="built_in">Channel</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel的tie方法什么时候调用过？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当改变channel所表示fd的events事件后，update负责在poller里面更改fd相应的事件epoll_ctl</span></span><br><span class="line"><span class="comment"> * EventLoop =&gt; ChannelList   Poller,  Poller与ChannelList是独立的，因此只能通过EventLoop来操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过channel所属的EventLoop，调用poller的相应方法，注册fd的events事件</span></span><br><span class="line">    loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在channel所属的EventLoop中， 把当前的channel删除掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tied_)&#123;</span><br><span class="line">        <span class="comment">//weak_ptr不控制对象的生命周期，但是，它知道对象是否还活着</span></span><br><span class="line">        <span class="comment">//用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(guard)&#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据poller通知的channel发生的具体事件， 由channel负责调用具体的回调操作</span></span><br><span class="line"><span class="comment">// 根据相应的事件来调用相应的回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>, revents_);</span><br><span class="line">    <span class="comment">// 关闭事件</span></span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) &#123;</span><br><span class="line">            <span class="built_in">errorCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (EPOLLIN | EPOLLPRI)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) &#123;</span><br><span class="line">            <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) &#123;</span><br><span class="line">            <span class="built_in">writeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Poller-封装"><a href="#Poller-封装" class="headerlink" title="Poller 封装"></a>Poller 封装</h1><p>Muduo提供了poll与Epoll，处于复用的考虑，在使用的时候不可能提供固定poll与Epoll，因此要将两者封装一下，使用一个抽象类Poller，poll与Epoll来继承Poller，这样使用的时候直接用Poller来替代即可</p><p>抽象类Poller提供一些通用的接口，由poll与Epoll来实现，比如updateChannel removeChannel 等事件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> POLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// muduo库中多路事件分发器的核心IO复用模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Poller</span>(EventLoop *loop);    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>() = <span class="keyword">default</span>;<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给所有的IO复用保留统一的接口 select poll epoll</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;   <span class="comment">//updata Channel的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;   <span class="comment">//删除Channel的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断参数channel是否在poller之中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop可以通过该接口获取默认的IO复用的具体实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Poller* <span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// map的key：sockfd  value：sockfd所属的channel通道类型</span></span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>,Channel*&gt;;</span><br><span class="line">    ChannelMap channels_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *ownerLoop_; <span class="comment">//定义Poller所属的事件循环EventLoop</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Poller::<span class="built_in">Poller</span>(EventLoop *loop):<span class="built_in">ownerLoop_</span>(loop)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Poller::hasChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = channels_.<span class="built_in">find</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">return</span> it != channels_.<span class="built_in">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultPoller.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &quot;PollPoller.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EpollPoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想一下为啥在这里实现，不在Poller里面实现,因为PollPoller 与 EPollPoller 继承于Poller,如果在Poller.cc 里面实现的话就得包含PollPoller.h EPollPoller.h 感觉有一些反过来了</span></span><br><span class="line"><span class="function">Poller* <span class="title">Poller::newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getenv</span>(<span class="string">&quot;MUDUO_USE_POLL&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 生成poll的实例 因为没有实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EpollPoller</span>(loop); <span class="comment">// 生成epoll的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EpollPoller 就是真正的 IO多路复用的实现了 poll没有实现</p><p>EpollPoller要实现Poller的接口和一些基本的操作，主要是将epoll的一些事情封装起来 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * epoll的使用  </span></span><br><span class="line"><span class="comment"> * epoll_create</span></span><br><span class="line"><span class="comment"> * epoll_ctl   add/mod/del</span></span><br><span class="line"><span class="comment"> * epoll_wait</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollPoller</span> : <span class="keyword">public</span> Poller &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollPoller</span>(EventLoop* loop);</span><br><span class="line">    ~<span class="built_in">EpollPoller</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类Poller的抽象方法</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充活跃链接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,ChannelList *activeChannels)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 更新channel通道</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation,Channel *channel)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epollfd_;</span><br><span class="line">    EventList events_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EpollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// channel未添加到poller中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kNew = <span class="number">-1</span>;          <span class="comment">// channel的成员index_ = -1</span></span><br><span class="line"><span class="comment">// channel已添加到poller中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kAdded = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// channel从poller中删除</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kDeleted = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">EpollPoller::<span class="built_in">EpollPoller</span>(EventLoop* loop)</span><br><span class="line">    :<span class="built_in">Poller</span>(loop),</span><br><span class="line">    <span class="built_in">epollfd_</span>(::<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)),</span><br><span class="line">    <span class="built_in">events_</span>(kInitEventListSize)  <span class="comment">// vector&lt;epoll_event&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">if</span>(epollfd_ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_create error:%d \n&quot;</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EpollPoller::~<span class="built_in">EpollPoller</span>()&#123;</span><br><span class="line">    ::<span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写基类Poller的抽象方法 </span></span><br><span class="line"><span class="comment">// EventLoop 调用 poller.poll，  poller.poll通过将epoll_wait之中发生事件的channel写入activeChannels之中来告知EventLoop那些发生了</span></span><br><span class="line"><span class="function">Timestamp <span class="title">EpollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实际上应该用LOG_DEBUG输出日志更为合理</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd total count:%lu \n&quot;</span>, __FUNCTION__, channels_.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_,&amp;*events_.<span class="built_in">begin</span>(),<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()),timeoutMs);</span><br><span class="line">    <span class="type">int</span> saveErrno = errno;</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numEvents &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%d events happened \n&quot;</span>, numEvents);</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(numEvents,activeChannels);</span><br><span class="line">        <span class="keyword">if</span>(numEvents == events_.<span class="built_in">size</span>())&#123; <span class="comment">//所有的event都发生了，那么可能空间不够，需要扩容</span></span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numEvents == <span class="number">0</span>)&#123; <span class="comment">// 超时链</span></span><br><span class="line">         <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s timeout! \n&quot;</span>, __FUNCTION__);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//外部中断</span></span><br><span class="line">        <span class="keyword">if</span> (saveErrno != EINTR)&#123;</span><br><span class="line">            errno = saveErrno;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EPollPoller::poll() err!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel update remove =&gt; EventLoop updateChannel removeChannel =&gt; Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *            EventLoop  =&gt;   poller.poll  </span></span><br><span class="line"><span class="comment"> *     ChannelList      Poller</span></span><br><span class="line"><span class="comment"> *                     ChannelMap  &lt;fd, channel*&gt;   epollfd</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::updateChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d events=%d index=%d \n&quot;</span>, __FUNCTION__, channel-&gt;<span class="built_in">fd</span>(), channel-&gt;<span class="built_in">events</span>(), index);</span><br><span class="line">    <span class="comment">// channel还没有注册或者是已经删除掉了（kDeleted的时候Poller里面的ChannelMap里面并没有删除掉,调用removeChannel的时候才会在ChannelMap里面删除掉）</span></span><br><span class="line">    <span class="keyword">if</span>(index == kNew || index == kDeleted)&#123; </span><br><span class="line">        <span class="keyword">if</span>(index == kNew)&#123;</span><br><span class="line">            <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD,channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// channel已经在poller上注册过了</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        <span class="keyword">if</span>(channel-&gt;<span class="built_in">isNoneEvent</span>())&#123; <span class="comment">//对任何事情都不感兴趣了，那就删除</span></span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL,channel);</span><br><span class="line">            channel-&gt;<span class="built_in">set_index</span>(kDeleted);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从poller中删除channel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::removeChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d\n&quot;</span>, __FUNCTION__, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="keyword">if</span>(index == kAdded)&#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL,channel);</span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kNew);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充活跃链接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,ChannelList *activeChannels)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numEvents;i++)&#123;</span><br><span class="line">        Channel* channel = <span class="built_in">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel);  <span class="comment">// EventLoop就拿到了它的poller给它返回的所有发生事件的channel列表了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新channel通道 epoll_ctl add/mod/del</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::update</span><span class="params">(<span class="type">int</span> operation,Channel *channel)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event,<span class="keyword">sizeof</span> event);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">epoll_ctl</span>(epollfd_,operation,fd,&amp;event) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(operation == EPOLL_CTL_DEL)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;epoll_ctl del error:%d\n&quot;</span>, errno);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_ctl add/mod error:%d\n&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的倒是挺常规的，要注意的是kNew kAdded kDeleted三个状态，EventList 与 ChannelList的管理，activeChannels的管理等操作</p><p>还有的是update函数里面event.data.ptr &#x3D; channel;这一行代码，与fillActiveChannels里面的操作相联动</p><p>前面已经说了，poller是由EventLoop来管理的，因此Timestamp EpollPoller::poll(int timeoutMs,ChannelList *activeChannels)是由EventLoop来调用的</p><p>EventLoop传给Timestamp EpollPoller::poll(int timeoutMs,ChannelList *activeChannels) activeChannels，就会得到相应的channel，后面再由EventLoop调用channel的handleEvent来处理事件就好</p><h1 id="EventLoop-Reactor"><a href="#EventLoop-Reactor" class="headerlink" title="EventLoop  Reactor"></a>EventLoop  Reactor</h1><p>上面已经说了EventLoop负责管理一个poller与很多个Channel，这个有点复杂 要注意的是四个函数   void wakeup();  void loop();    void runInLoop(Functor cb);  void queueInLoop(Functor cb);  要不然可能会迷糊，其他的就挺常规的</p><p>先看代码，先了解一下其他的函数，这里就不多讲了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CurrentThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 退出事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Timestamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollReturnTime_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前loop中执行cb</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">    <span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来唤醒loop所在的线程的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断EventLoop对象是否在自己的线程里面</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId_ == CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;         <span class="comment">// wake up</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;  <span class="comment">// 执行回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    std::atomic_bool looping_;  <span class="comment">//原子操作</span></span><br><span class="line">    std::atomic_bool quit_;  <span class="comment">//标志退出loop循环</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">pid_t</span> threadId_; <span class="comment">// 记录当前loop所在线程的id</span></span><br><span class="line">    </span><br><span class="line">    Timestamp pollReturnTime_; <span class="comment">// poller返回发生事件的channels的时间点</span></span><br><span class="line">    std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> wakeupFd_;   <span class="comment">// 主要作用，当mainLoop获取一个新用户的channel，通过轮询算法选择一个subloop，通过该成员唤醒subloop处理channel</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; wakeupChannel_; <span class="comment">//将wakeupFd_打包成channel</span></span><br><span class="line"></span><br><span class="line">    ChannelList activeChannels_;</span><br><span class="line"></span><br><span class="line">    std::atomic_bool callingPendingFunctors_; <span class="comment">// 标识当前loop是否有需要执行的回调操作</span></span><br><span class="line">    std::vector&lt;Functor&gt; pendingFunctors_;    <span class="comment">// 存储loop需要执行的所有的回调操作</span></span><br><span class="line">    std::mutex mutex_;                        <span class="comment">// 互斥锁，用来保护上面vector容器的线程安全操作</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止一个线程创建多个EventLoop   thread_local 相当于线程里面的单例模式,看构造函数</span></span><br><span class="line">__thread EventLoop *t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义默认的Poller IO复用接口的超时时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createEventfd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(evtfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;eventfd error:%d \n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::<span class="built_in">EventLoop</span>() </span><br><span class="line">    : <span class="built_in">looping_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">quit_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">callingPendingFunctors_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">threadId_</span>(CurrentThread::<span class="built_in">tid</span>())</span><br><span class="line">    , <span class="built_in">poller_</span>(Poller::<span class="built_in">newDefaultPoller</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>())</span><br><span class="line">    , <span class="built_in">wakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;EventLoop created %p in thread %d \n&quot;</span>, <span class="keyword">this</span>, threadId_);</span><br><span class="line">    <span class="keyword">if</span>(t_loopInThisThread) &#123;</span><br><span class="line">        <span class="comment">// 防止一个线程创建多个EventLoop </span></span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;Another EventLoop %p exists in this thread %d \n&quot;</span>, t_loopInThisThread, threadId_);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置wakeupfd的事件类型以及发生事件后的回调操作</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead,<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 每一个eventloop都将监听wakeupchannel的EPOLLIN读事件了</span></span><br><span class="line">    <span class="comment">// mainReactor给subReactor发送一个消息，那么subReactor就不阻塞了，起来做事情了</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line">EventLoop::~<span class="built_in">EventLoop</span>() &#123;</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    ::<span class="built_in">close</span>(wakeupFd_);</span><br><span class="line">    t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mainReactor给subReactor发送一个消息，那么subReactor就不阻塞了，起来做事情了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事件循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_)&#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd（mainLoop与channel之间的通信）</span></span><br><span class="line">        <span class="comment">// 正常的client的fd就直接用下面的channel-&gt;handleEvent(pollReturnTime_);来解决了</span></span><br><span class="line">        <span class="comment">// wakeupf基本上用于接收新的连接，由mainLoop注册一些回调cb存储在pendingFunctors_然后再唤醒subloop，由subloop来执行这些回调，这样方便把这些新的连接注册到subloop上  这一操作由doPendingFunctors函数实现</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs,&amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(Channel* channel:activeChannels_)&#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop   mainLoop接收新的连接得到fd，我们用channel打包fd然后分发给subloop来执行一些回调</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作（pendingFunctors_）</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping. \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出事件循环  </span></span><br><span class="line"><span class="comment">// 1.loop在自己的线程中调用quit(这就直接结束了，下次loop函数里面while循环发现quit为true就结束了)  </span></span><br><span class="line"><span class="comment">// 2.在非loop的线程中，调用loop的quit，那么这个loop可能在阻塞 poller_-&gt;poll 这一部，则需要把这个loop先唤醒，这样的话等下一次循环的时候发现quit_为true就结束了，反之不唤醒的话就会一直阻塞在poller_-&gt;poll这一步，如果不发生事件可能永远无法结束 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *              mainLoop</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *                                             no ==================== 生产者-消费者的线程安全的队列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  subLoop1     subLoop2     subLoop3</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit   在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>())&#123;   <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();<span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来唤醒loop所在的线程的  向wakeupfd_写一个数据，wakeupChannel就发生读事件，当前loop线程就会被唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;  <span class="comment">// 执行回调</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);  <span class="comment">//不直接使用pendingFunctors_执行下面的代码为了防止一边写一边读，交叉持有锁，造成耗费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor &amp;functor: functors)&#123;</span><br><span class="line">        <span class="built_in">functor</span>();  <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是wakeup函数， EventLoop肯定会调用poller_-&gt;poll （也就是epoll_wait），这里肯定会阻塞，但是有一些特殊情况可能需要唤醒这个（这个特殊情况一会再说），因此需要wakeup来实现</p><p>我们看到EventLoop里面有一个wakeupFd_的属性，系统会提供一个eventfd函数，这个和socketfd用法差不多也可以用来读和写，将eventfd封装成channel再用poller来监听，这样的话要实现wakeup的话就简单了，只需要注册读事件，然后往wakeupFd_里面写一些东西就好</p><p>我们可以看到构造函数里面wakeupChannel_注册了enableReading读事件，setReadCallback设置的回调是EventLoop::handleRea</p><p>我们把wakeup与handleRead拿出来看一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wakeup 就是写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleRead 就是读</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看void loop(); </p><p>这个就比较简单了，主要是逻辑，为什么说比较简单，我们看代码就知道</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_)&#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd（mainLoop与channel之间的通信）</span></span><br><span class="line">        <span class="comment">// 正常的client的fd就直接用下面的channel-&gt;handleEvent(pollReturnTime_);来解决了</span></span><br><span class="line">        <span class="comment">// wakeupf基本上用于接收新的连接，由mainLoop注册一些回调cb存储在pendingFunctors_然后再唤醒subloop，由subloop来执行这些回调，这样方便把这些新的连接注册到subloop上  这一操作由doPendingFunctors函数实现</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs,&amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(Channel* channel:activeChannels_)&#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop   mainLoop接收新的连接得到fd，我们用channel打包fd然后分发给subloop来执行一些回调</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作（pendingFunctors_）</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping. \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就几行，调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_)获取那些channel发生事件了，然后回调事件channel可以自己做，这里做一下调用就行，其他的就是doPendingFunctors</p><p>doPendingFunctors就涉及到void runInLoop(Functor cb);  void queueInLoop(Functor cb); 这两个函数了</p><p>runInLoop比较好理解，就是当前loop所在的线程执行的函数，这样的话就直接执行就好了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>())&#123;   <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在非当前loop线程中执行cb的时候就需要调用queueInLoop函数了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();<span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queueInLoop会把cb放置到pendingFunctors_里面，然后唤醒当前loop（原来的loop可能正在阻塞的状态），然后loop就会调用doPendingFunctors</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;  <span class="comment">// 执行回调</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);  <span class="comment">//不直接使用pendingFunctors_执行下面的代码为了防止一边写一边读，交叉持有锁，造成耗费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor &amp;functor: functors)&#123;</span><br><span class="line">        <span class="built_in">functor</span>();  <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐一执行pendingFunctors_里面的函数</p><h1 id="Thread-EventLoopThread-EventLoopThreadPool"><a href="#Thread-EventLoopThread-EventLoopThreadPool" class="headerlink" title="Thread EventLoopThread EventLoopThreadPool"></a>Thread EventLoopThread EventLoopThreadPool</h1><p>Thread是对<thread>库的封装，其他没有特殊的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc,<span class="type">const</span> std::string &amp;name = std::string())</span></span>;</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> started_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">tid</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tid_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> numCreated_; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">bool</span> joined_;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_;</span><br><span class="line">    <span class="type">pid_t</span> tid_;</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">static</span> std::atomic_int numCreated_;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CurrentThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic_int <span class="title">Thread::numCreated_</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func,<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">joined_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">tid_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">func_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">    , <span class="built_in">name_</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setDefaultName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~<span class="built_in">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_ &amp;&amp; !joined_)&#123;</span><br><span class="line">        thread_-&gt;<span class="built_in">detach</span>();    <span class="comment">// thread类提供的设置分离线程的方法 detach之后等到线程结束之后会自动join</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::setDefaultName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = ++ numCreated_;</span><br><span class="line">    <span class="keyword">if</span>(name_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;Thread%d&quot;</span>, num);</span><br><span class="line">        name_ = buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span>&#123;    <span class="comment">// 一个Thread对象，记录的就是一个新线程的详细信息</span></span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem,<span class="literal">false</span>,<span class="number">0</span>);  <span class="comment">//信号量为0</span></span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    thread_ = std::<span class="built_in">shared_ptr</span>&lt;std::thread&gt;(<span class="keyword">new</span> std::<span class="built_in">thread</span>([&amp;]()&#123;</span><br><span class="line">        <span class="comment">// 获取线程的tid值</span></span><br><span class="line">        tid_ = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem); <span class="comment">//信号量+1</span></span><br><span class="line">        <span class="comment">// 开启一个新线程，专门执行该线程函数</span></span><br><span class="line">        <span class="built_in">func_</span>(); </span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">// 这里必须等待获取上面新创建的线程的tid值,因为有时候会使用tid是否大于0来判断是否创建成功</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem); <span class="comment">//信号量-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span></span>&#123;</span><br><span class="line">    joined_ = <span class="literal">true</span>;</span><br><span class="line">    thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们看，我们用的是std::shared_ptr<thread> thread_; 来存储的，正常的话如果我们直接申请一个thread，那么它就直接start了，这样的话我们就可以通过调用void Thread::start()来开始了</p><p>EventLoopThread 将Eventloop和Thread结合起来，简单来说就是创建线程，循环里面是一个loop，这就muduo所追求的 one loop per thread</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOPTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOPTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThread</span>:noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb = <span class="built_in">ThreadInitCallback</span>(),<span class="type">const</span> std::string &amp;name = std::<span class="built_in">string</span>());</span><br><span class="line">    ~<span class="built_in">EventLoopThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">EventLoop* <span class="title">startLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    EventLoop* loop_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exiting_;</span><br><span class="line">    Thread thread_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">    ThreadInitCallback callback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">exiting_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">thread_</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name)</span><br><span class="line">        , <span class="built_in">mutex_</span>()</span><br><span class="line">        , <span class="built_in">cond_</span>()</span><br><span class="line">        , <span class="built_in">callback_</span>(cb) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>()&#123;</span><br><span class="line">    exiting_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop_ != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        thread_.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_.<span class="built_in">start</span>();  <span class="comment">// 启动底层的新线程 执行的是threadFunc</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(loop_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个方法，实在单独的新线程里面运行的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop loop; <span class="comment">// 创建一个独立的eventloop，和上面的线程是一一对应的，one loop per thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(callback_)&#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// EventLoop loop  =&gt; Poller.poll</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventLoopThreadPool 声明多个EventLoop 以供选择，主要是setThreadNum函数以及 EventLoop* getNextLoop();方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOPTHREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOPTHREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThread</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThreadPool</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoopThreadPool</span>(EventLoop *baseLoop, <span class="type">const</span> std::string &amp;nameArg);</span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span> </span>&#123;</span><br><span class="line">        numThreads_ = numThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果工作在多线程中，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    EventLoop *baseLoop_; <span class="comment">// EventLoop loop;  </span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">int</span> numThreads_;</span><br><span class="line">    <span class="type">int</span> next_;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;</span><br><span class="line">    std::vector&lt;EventLoop*&gt; loops_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop *baseLoop, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">baseLoop_</span>(baseLoop)</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">numThreads_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">next_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, name_.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        EventLoopThread *t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb, buf);</span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>()); <span class="comment">// 底层创建线程，绑定一个新的EventLoop，并返回该loop的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个服务端只有一个线程，运行着baseloop</span></span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果工作在多线程中，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop *loop = baseLoop_;</span><br><span class="line">    <span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>()) &#123; <span class="comment">// 通过轮询获取下一个处理事件的loop</span></span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span> (next_ &gt;= loops_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            next_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;EventLoop*&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;EventLoop*&gt;(<span class="number">1</span>, baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loops_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看start的时候通过numThreads_来初始化EventLoopThread的数量numThreads_是subReactor的数量，这个和原始的muduo不一样，原始的muduo是baseloop + subReactor的数量</p><p>最为主要的是通过轮询的方法来选择subReactor（EventLoop）看EventLoop* EventLoopThreadPool::getNextLoop()，如果loops_为空的话就只会return baseLoop_了</p><h1 id="Socket-Socket的封装"><a href="#Socket-Socket的封装" class="headerlink" title="Socket Socket的封装"></a>Socket Socket的封装</h1><p>前面我们封装了IP 与 PORT (InetAddress) 这里的Socket是对 socket fd的封装 也就是 初始化 bind listen accept</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOCKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装socket fd</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">        : sockfd_(sockfd)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sockfd_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localaddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(InetAddress *peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//一些选项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReusePort</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sockfd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Socket::~<span class="built_in">Socket</span>()&#123;</span><br><span class="line">    <span class="built_in">close</span>(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localaddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">bind</span>(sockfd_,(sockaddr*)localaddr.<span class="built_in">getSockAddr</span>(),<span class="built_in">sizeof</span>(sockaddr_in)))&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;bind sockfd:%d fail \n&quot;</span>, sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">listen</span>(sockfd_,<span class="number">1024</span>))&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;listen sockfd:%d fail \n&quot;</span>, sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket::accept</span><span class="params">(InetAddress *peeraddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. accept函数的参数不合法</span></span><br><span class="line"><span class="comment">     * 2. 对返回的connfd没有设置非阻塞</span></span><br><span class="line"><span class="comment">     * Reactor模型 one loop per thread</span></span><br><span class="line"><span class="comment">     * poller + non-blocking IO</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span> addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr,<span class="keyword">sizeof</span> addr);</span><br><span class="line">    <span class="type">int</span> connfd = ::<span class="built_in">accept4</span>(sockfd_,(sockaddr*)&amp;addr,&amp;len,SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">    <span class="comment">//把连接的addr存储在peeraddr之中，方便返回</span></span><br><span class="line">    <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        peeraddr-&gt;<span class="built_in">setSockAddr</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">shutdown</span>(sockfd_,SHUT_WR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shutdownWrite error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, IPPROTO_TCP, TCP_NODELAY, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setReusePort</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Acceptor-新连接接收"><a href="#Acceptor-新连接接收" class="headerlink" title="Acceptor 新连接接收"></a>Acceptor 新连接接收</h1><p>Acceptor会工作在mainLoop之中，负责接受新的连接</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//新连接的回调</span></span><br><span class="line">    <span class="keyword">using</span> NewConnectionCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport);</span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123;</span><br><span class="line">        newConnectionCallback_ = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> listenning_; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里不是真正的Read，acceptChannel_会注册到mainloop上，当有新连接来的时候就会唤醒来执行回调，这也是Read事件，这个里面调用的是newConnectionCallback_</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    EventLoop *loop_; <span class="comment">// Acceptor用的就是用户定义的那个baseLoop，也称作mainLoop</span></span><br><span class="line">    Socket acceptSocket_;</span><br><span class="line">    Channel acceptChannel_;</span><br><span class="line">    NewConnectionCallback newConnectionCallback_;</span><br><span class="line">    <span class="type">bool</span> listenning_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到acceptSocket_ 就值服务器的 socket(ip 与 port) 客户端连接的时候就是连接这个</p><p>还可以看到 Channel acceptChannel_; 这就是用来处理新的连接的，acceptChannel_会监听读事件并且注册到mainLoop之中（有新连接的时候会相应）</p><p>绑定的回调事件为handleRead 其实是 NewConnectionCallback</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">createNonblocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d listen socket create err:%d \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>())</span><br><span class="line">    , <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// TcpServer::start() Acceptor.listen  有新用户的连接，要执行一个回调（connfd=》channel=》subloop）</span></span><br><span class="line">    <span class="comment">// baseLoop =&gt; acceptChannel_(listenfd) =&gt; </span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(); <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:%s:%d accept err:%d \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:%s:%d sockfd reached limit! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是handleRead函数，直接看 通过peerAddr接收连接sockaddr_in，然后connfd接收socket fd,简单的判断一下传递给newConnectionCallback_就行了，这个由调用方自己设置怎么处理，Acceptor不用管，这不是他应该处理的逻辑</p><h1 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h1><p>和webserver的缓冲区一样，准确来说，webserver的缓冲区是仿照这个来写的，这里就不做多解释了webserver里面已经解释的很清楚了</p><p>|————-A———|————B———–|———–C————|</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络库底层的缓冲器类型定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class="line"><span class="function">        : buffer_(kCheapPrepend + initialSize)</span></span><br><span class="line"><span class="function">        , readerIndex_(kCheapPrepend)</span></span><br><span class="line"><span class="function">        , writerIndex_(kCheapPrepend)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读空间的大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可写空间大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后被隐藏能源</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onMessage string &lt;- Buffer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>()) &#123;</span><br><span class="line">            readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// len == readableBytes() </span></span><br><span class="line">            <span class="built_in">retrieveAll</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readerIndex_ = writerIndex_ = kCheapPrepend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把onMessage函数上报的Buffer数据，转成string类型的数据返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">        <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer_.size() - writerIndex_    len</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">            <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把[data, data+len]内存上的数据，添加到writable缓冲区当中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">        std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">        writerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从fd上读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line">    <span class="comment">// 通过fd发送数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// it.operator*()</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();  <span class="comment">// vector底层数组首元素的地址，也就是数组的起始地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">            buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">            std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                    <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                    <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">            readerIndex_ = kCheapPrepend;</span><br><span class="line">            writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> readerIndex_;</span><br><span class="line">    <span class="type">size_t</span> writerIndex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从fd上读取数据  Poller工作在LT模式</span></span><br><span class="line"><span class="comment"> * Buffer缓冲区是有大小的！ 但是从fd上读数据的时候，却不知道tcp数据最终的大小</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); <span class="comment">// 这是Buffer底层缓冲区剩余的可写空间大小</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) &#123;<span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// extrabuf里面也写入了数据 </span></span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TcpConnection-连接管理"><a href="#TcpConnection-连接管理" class="headerlink" title="TcpConnection 连接管理"></a>TcpConnection 连接管理</h1><p>主要负责管理TCP的连接，比如新连接的建立（connectionCallback_）这个回调由调用者设置，读数据（handleRead messageCallback_） 写数据（send handleWrite），其他的函数都是一些辅助性的，很好理解</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Callbacks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TcpServer =&gt; Acceptor =&gt; 有一个新用户连接，通过accept函数拿到connfd</span></span><br><span class="line"><span class="comment"> * =》 TcpConnection 设置回调 =》 Channel =》 Poller =》 Channel的回调操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span> : noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> std::string &amp;name,</span><br><span class="line">                <span class="type">int</span> sockfd,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; peerAddr);</span><br><span class="line">    ~<span class="built_in">TcpConnection</span>(); <span class="comment">//析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getLoop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getname</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get localAddress</span></span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">localAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localAddr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get peerAddress</span></span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">peerAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peerAddr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是已连接状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state_ == kConnected;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="type">const</span> HighWaterMarkCallback&amp; cb, <span class="type">size_t</span> highWaterMark)</span></span></span><br><span class="line"><span class="function">    </span>&#123; highWaterMarkCallback_ = cb; highWaterMark_ = highWaterMark; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> CloseCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; closeCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接建立</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 连接销毁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectDestroyed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">StateE</span>&#123;kDisconnected,kConnecting,kConnected,kDisconnecting&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(StateE state)</span></span>&#123;</span><br><span class="line">        state_ = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data,<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// 这里绝对不是baseLoop， 因为TcpConnection都是在subLoop里面管理的</span></span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line">    std::atomic_int state_;</span><br><span class="line">    <span class="type">bool</span> reading_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里和Acceptor类似   Acceptor=》mainLoop    TcpConenction=》subLoop</span></span><br><span class="line">    std::unique_ptr&lt;Socket&gt; socket_;</span><br><span class="line">    std::unique_ptr&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> InetAddress localAddr_;</span><br><span class="line">    <span class="type">const</span> InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_; <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;       <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_; <span class="comment">// 消息发送完成以后的回调</span></span><br><span class="line">    HighWaterMarkCallback highWaterMarkCallback_; <span class="comment">// 消息阈值的回调</span></span><br><span class="line">    CloseCallback closeCallback_; <span class="comment">//关闭回调</span></span><br><span class="line">    <span class="type">size_t</span> highWaterMark_;        <span class="comment">//消息阈值（流量控制）</span></span><br><span class="line"></span><br><span class="line">    Buffer inputBuffer_;  <span class="comment">// 接收数据的缓冲区</span></span><br><span class="line">    Buffer outputBuffer_; <span class="comment">// 发送数据的缓冲区</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop *loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loop == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d TcpConnection Loop is null! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop, </span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg, </span><br><span class="line">                <span class="type">int</span> sockfd,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">state_</span>(kConnecting)</span><br><span class="line">    , <span class="built_in">reading_</span>(<span class="literal">true</span>)</span><br><span class="line">    , <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd))</span><br><span class="line">    , <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd))</span><br><span class="line">    , <span class="built_in">localAddr_</span>(localAddr)</span><br><span class="line">    , <span class="built_in">peerAddr_</span>(peerAddr)</span><br><span class="line">    , <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">// 64M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下面给channel设置相应的回调函数，poller给channel通知感兴趣的事件发生了，channel会回调相应的操作函数</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>, name_.<span class="built_in">c_str</span>(), sockfd);</span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>()&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::dtor[%s] at fd=%d state=%d \n&quot;</span>, </span><br><span class="line">        name_.<span class="built_in">c_str</span>(), channel_-&gt;<span class="built_in">fd</span>(), (<span class="type">int</span>)state_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(loop_-&gt;<span class="built_in">isInLoopThread</span>())&#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(),buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(</span><br><span class="line">                &amp;TcpConnection::sendInLoop,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                buf.<span class="built_in">c_str</span>(),</span><br><span class="line">                buf.<span class="built_in">size</span>()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据  应用写的快， 而内核发送数据慢， 需要把待发送数据写入缓冲区， 而且设置了水位回调</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;        <span class="comment">// 已发送的数据量</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len;    <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;   <span class="comment">// 是否发生了错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前调用过该connection的shutdown，不能再进行发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected, give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel_第一次开始写数据（这个时候还没有注册写事件），而且缓冲区没有待发送数据（刚开始数据来的时候就直接发，还没有往缓冲区里面写数据，如果第一次发不完再往缓冲区里面写）</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);  <span class="comment">// 直接开始写</span></span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)&#123; <span class="comment">//写成功</span></span><br><span class="line">            remaining = len - nwrote;  <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)&#123;  <span class="comment">//写完了看看是不是需要调用writeCompleteCallback_回调</span></span><br><span class="line">                <span class="comment">// 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)&#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class="comment">// SIGPIPE  RESET</span></span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write，并没有把数据全部发送出去，剩余的数据需要保存到缓冲区当中，然后给channel</span></span><br><span class="line">    <span class="comment">// 注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用writeCallback_回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite方法，把发送缓冲区中的数据全部发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 调用highWaterMarkCallback</span></span><br><span class="line">        <span class="keyword">if</span>(oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldLen+remaining)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把剩余的数据都写到outputBuffer_之中，然后注册写事件，后面poller会通知写事件，然后调用TcpConnection::handleWrite的回调</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line">        <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">// 这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop,<span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;   <span class="comment">// 说明outputBuffer中的数据已经全部发送完成</span></span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>(); <span class="comment">// 关闭写端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// 向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">// 新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>(); <span class="comment">// 把channel的所有感兴趣的事件，从poller中del掉</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>(); <span class="comment">// 把channel从poller中删除掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)&#123;</span><br><span class="line">                    <span class="comment">// 唤醒loop_对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poller =&gt; channel::closeCallback =&gt; TcpConnection::handleClose</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::handleClose fd=%d state=%d \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>(), (<span class="type">int</span>)state_);</span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(connPtr); <span class="comment">// 执行连接关闭的回调</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr); <span class="comment">// 关闭连接的回调  执行的是TcpServer::removeConnection回调方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> optval;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(channel_-&gt;<span class="built_in">fd</span>(), SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = optval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleError name:%s - SO_ERROR:%d \n&quot;</span>, name_.<span class="built_in">c_str</span>(), err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读数据 handleRead 主要是调用messageCallback_还有一些错误处理 messageCallback_ 也是调用者（TcpServer）设置的(其实也是用户设置的)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写数据 send handleWrite 基本思路：send会先发送一份，如果数据比较少，一次可以写完的话就直接写，不用直接调用buffer等操作，但是如果没发送完就把剩余的写进buf里面，然后注册写事件，这样的话会触发poller通知，从而触发channel的handleWrite回调，从而把剩下的数据给发送除去</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;        <span class="comment">// 已发送的数据量</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len;    <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;   <span class="comment">// 是否发生了错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前调用过该connection的shutdown，不能再进行发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected, give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel_第一次开始写数据（这个时候还没有注册写事件），而且缓冲区没有待发送数据（刚开始数据来的时候就直接发，还没有往缓冲区里面写数据，如果第一次发不完再往缓冲区里面写）</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);  <span class="comment">// 直接开始写</span></span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)&#123; <span class="comment">//写成功</span></span><br><span class="line">            remaining = len - nwrote;  <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)&#123;  <span class="comment">//写完了看看是不是需要调用writeCompleteCallback_回调</span></span><br><span class="line">                <span class="comment">// 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)&#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class="comment">// SIGPIPE  RESET</span></span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write，并没有把数据全部发送出去，剩余的数据需要保存到缓冲区当中，然后给channel</span></span><br><span class="line">    <span class="comment">// 注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用writeCallback_回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite方法，把发送缓冲区中的数据全部发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 调用highWaterMarkCallback</span></span><br><span class="line">        <span class="keyword">if</span>(oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldLen+remaining)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把剩余的数据都写到outputBuffer_之中，然后注册写事件，后面poller会通知写事件，然后调用TcpConnection::handleWrite的回调</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line">        <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">// 这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)&#123;</span><br><span class="line">                    <span class="comment">// 唤醒loop_对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的就是关闭连接 错误处理等操作了，需要注意的是里面针对channel等操作</p><h1 id="TcpServer-模块连接"><a href="#TcpServer-模块连接" class="headerlink" title="TcpServer 模块连接"></a>TcpServer 模块连接</h1><p>所有一切的基础功能，上面的模块已经完成了，在TcpServer里面主要是将这些基础的功能连接在一起</p><p>比如：Adaptor如何分配connection给subReactor，newConnection的回调是什么（connectionCallback_ messageCallback_ 交给用户自己来设置了）等</p><p>其他的还有一些像EventLoopThreadPool的setThreadNum，还有removeConnection等简单操作了，这些操作一般就是直接调用写好模块的函数再加一些简单的逻辑就好</p><p>TcpServer:</p><ul><li><p>有一个baseLoop（loop_） 是mainLoop 负责分发任务，需要用户自己定义，然后在TcpServer初始化的时候传给TcpServer</p></li><li><p>有一个EventLoopThreadPool，根据初始化的numThreads的数量初始化subLoop的数量，负责处理新连接以外的各种事物</p></li><li><p>有一个Acceptor，负责新连接，注册到baseLoop里面的poller，监听读事件，设置TcpServer::newConnection的回调，也就是说，当有新连接的时候就会触发读事件从而通知Acceptor里面的channel执行回调（newConnection）</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户使用muduo编写服务器程序</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Callbacks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外的服务器编程使用的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;;</span><br><span class="line">    <span class="comment">// 端口复用开关</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Option</span> &#123;</span><br><span class="line">        kNoReusePort,</span><br><span class="line">        kReusePort,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option = kNoReusePort);</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadInitcallback</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        threadInitCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        connectionCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        messageCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        writeCompleteCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置底层subloop的个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启服务器监听</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ConnectionMap = std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// baseLoop 用户定义的loop</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string ipPort_;</span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor_;              <span class="comment">// 运行在mainLoop，任务就是监听新连接事件</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class="comment">// one loop per thread</span></span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_;       <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;             <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_; <span class="comment">// 消息发送完成以后的回调</span></span><br><span class="line"></span><br><span class="line">    ThreadInitCallback threadInitCallback_; <span class="comment">// loop线程初始化的回调</span></span><br><span class="line"></span><br><span class="line">    std::atomic_int started_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextConnId_;</span><br><span class="line">    ConnectionMap connections_; <span class="comment">// 保存所有的连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查loop是否是nullptr</span></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop *loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainLoop is null! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有先用户连接时，会执行TcpServer::newConnection回调</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item:connections_)&#123;</span><br><span class="line">        <span class="comment">// 这个局部的shared_ptr智能指针对象，出右括号，可以自动释放new出来的TcpConnection对象资源了</span></span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁连接</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置底层subloop的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>&#123;</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启服务器监听   loop.loop()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>)&#123; <span class="comment">// 防止一个TcpServer对象被start多次</span></span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen,acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个新的客户端的连接，acceptor会执行这个回调操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法，选择一个subLoop，来管理channel</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd，创建TcpConnection连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    <span class="comment">// 下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调   conn-&gt;shutDown()</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s\n&quot;</span>, </span><br><span class="line">        name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接来看newConnection这一关键函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一个新的客户端的连接，acceptor会执行这个回调操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法，选择一个subLoop，来管理channel</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd，创建TcpConnection连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    <span class="comment">// 下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调   conn-&gt;shutDown()</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接通过EventLoopThreadPool的轮询算法选择一个subReactor（ioLoop） 然后初始化一些这个新连接的一些信息，后面再通过ioLoop直接调用TcpConnection的connectEstablished函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// 向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">// 新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听新连接的读事件，当有信息发过来，有可读信息的时候，就会触发channel_里面读的回调从而调用回调函数，也就是用户设置的messageCallback</p><p>其他的到没有啥需要特别说明的了，针对启动一切的start函数的话，就直接调用地层模块的启动就好</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听   loop.loop()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>)&#123; <span class="comment">// 防止一个TcpServer对象被start多次</span></span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen,acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话我们就理清楚了，留给用户需要做的就是，setConnectionCallback（可选） setMessageCallback（必须） setThreadNum（不做的话就只有mainbReactor在工作了，非常不好）</p><h1 id="编译成库添加环境变量路径"><a href="#编译成库添加环境变量路径" class="headerlink" title="编译成库添加环境变量路径"></a>编译成库添加环境变量路径</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">&lt;!-- CMakeLists.txt --&gt;</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">project</span>(mymuduo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake =&gt; makefile   make</span></span><br><span class="line"><span class="comment"># mymuduo最终编译成so动态库，设置动态库的路径，放在根目录的lib文件夹下面</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 设置调试信息 以及 启动C++11语言标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -std=c++11 -fPIC&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参与编译的源代码文件 </span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment"># 编译生成动态库mymuduo</span></span><br><span class="line"><span class="keyword">add_library</span>(mymuduo SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有build目录，创建该目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d `<span class="built_in">pwd</span>`/build ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> `<span class="built_in">pwd</span>`/build</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf `<span class="built_in">pwd</span>`/build/*</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">pwd</span>`/build &amp;&amp;</span><br><span class="line">    cmake .. &amp;&amp;</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到项目根目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把头文件拷贝到 /usr/include/mymuduo  so库拷贝到 /usr/lib    PATH</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /usr/include/mymuduo ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">mkdir</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> header <span class="keyword">in</span> `<span class="built_in">ls</span> *.h`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$header</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> `<span class="built_in">pwd</span>`/lib/libmymuduo.so /usr/lib</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">            <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        server_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                Timestamp time)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 写端   EPOLLHUP =》 closeCallback_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer-01&quot;</span>)</span></span>; <span class="comment">// Acceptor non-blocking listenfd  create bind </span></span><br><span class="line">    server.<span class="built_in">start</span>(); <span class="comment">// listen  loopthread  listenfd =&gt; acceptChannel =&gt; mainLoop =&gt;</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// 启动mainLoop的底层Poller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testserver :</span></span><br><span class="line"><span class="comment">// g++ -o testserver testserver.cc -lmymuduo -lpthread -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clean :</span></span><br><span class="line"><span class="comment">// rm -f testserver</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试： telnet 127.0.0.1 8000</p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于IPV4的流媒体广播</title>
      <link href="/2025/05/07/IPV4DUP/"/>
      <url>/2025/05/07/IPV4DUP/</url>
      
        <content type="html"><![CDATA[<h1 id="基于IPV4的流媒体广播"><a href="#基于IPV4的流媒体广播" class="headerlink" title="基于IPV4的流媒体广播"></a>基于IPV4的流媒体广播</h1><p>这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。</p><p>服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播）</p><p>客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来<br>（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃）</p><h1 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h1><p>原项目git：<a href="https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4">https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4</a></p><p>环境: Ubuntu 20.04 ffmpeg</p><p>还需要下载一个ffmepg包，这个是啥包我忘记了，但是在运行client的时候会发现只会接收一个UDP包的数据</p><p>这是因为缺少了这个包。接收数据之后会馈入ffmpeg里面，因为缺少了这个包，所以才会只接收一个数据之后就断掉</p><p>终端上会有提示，到时候直接ubuntu命令下载即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终端-1 server</span></span><br><span class="line">cd server</span><br><span class="line">make</span><br><span class="line">./server</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端-2 client</span></span><br><span class="line">cd client</span><br><span class="line">./start.<span class="built_in">sh</span></span><br><span class="line"></span><br><span class="line">(这里不是简单的接收数据，ffmpeg是可以正常播放出来音乐的，放不出来可能是虚拟机的问题，我这边是可以正常放出来的)</span><br></pre></td></tr></table></figure><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6_IPV4UDP/</span><br><span class="line">├── client</span><br><span class="line">│   ├── client.c</span><br><span class="line">│   ├── client.h</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── start.sh</span><br><span class="line">├── include</span><br><span class="line">│   └── protocol.h</span><br><span class="line">├── medialib</span><br><span class="line">│   ├── ch1</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 世界这么大还是遇见你.mp3</span><br><span class="line">│   │   └── 起风了.mp3</span><br><span class="line">│   ├── ch2</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 带你去旅行.mp3</span><br><span class="line">│   │   └── 再见只是陌生人.mp3</span><br><span class="line">│   ├── ch3</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── Summertime Sadness.mp3</span><br><span class="line">│   │   └── 学猫叫.mp3</span><br><span class="line">│   └── ch4</span><br><span class="line">├── server</span><br><span class="line">│   ├── channel.c</span><br><span class="line">│   ├── channel.h       //每个频道的广播</span><br><span class="line">│   ├── list.c</span><br><span class="line">│   ├── list.h          //节目单广播</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── medialib.c</span><br><span class="line">│   ├── medialib.h      //medialib转化为广播频道</span><br><span class="line">│   ├── server.c</span><br><span class="line">│   ├── server_conf.h   //服务端的一些基础的配置</span><br><span class="line">│   ├── threadpool.c</span><br><span class="line">│   ├── threadpool.h    //线程池</span><br><span class="line">│   ├── tokenbucket.c</span><br><span class="line">│   └── tokenbucket.h   //令牌桶，负责流量控制</span><br><span class="line">├── README.md</span><br><span class="line">├── LICENSE</span><br><span class="line">└── Streaming_media_broadcasting_system_based_on_IPv4.code-workspace</span><br></pre></td></tr></table></figure><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>protocol.h 文件，这里面定义了很多的基本的配置，比如：多播组的地址，默认的端口号，还有节目单，频道的格式等。</p><p>代码:这里面不涉及啥复杂的操作，看一看即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PROTOCOL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PROTOCOL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> <span class="type">chnid_t</span>;    <span class="comment">//定义频道ID类型为8位无符号整数，范围0~255，节省空间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MGROUP     <span class="string">&quot;224.2.2.2&quot;</span> <span class="comment">// 多播组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_RECVPORT   <span class="string">&quot;1989&quot;</span>      <span class="comment">// 默认端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHANNR             100         <span class="comment">// 最大频道数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTCHNID          0           <span class="comment">// 约定 0 号为节目单频道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINCHNID           1           <span class="comment">// 最小广播频道号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHNID           (CHANNR - MINCHNID)  <span class="comment">// 最大广播频道号 100 - 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_CHANNEL_MAX    (65536U - 20U - 8U)  <span class="comment">// 最大频道数据包  20U IP头   8U UDP头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CHANNEL_DATA   (MSG_CHANNEL_MAX - sizeof(chnid_t)) <span class="comment">//MSG_CHANNEL_MAX去除掉一个 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_LISTCHN_MAX     (65536U - 20U - 8U) <span class="comment">// 最大节目单数据包  20U IP头   8U UDP头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LISTCHN_DATA    (MSG_LISTCHN_MAX - sizeof(chnid_t))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 频道包，第一字节描述频道号，data[0]在结构体最后作用为变长数组，根据malloc到的实际内存大小决定 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_channel_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;             <span class="comment">// must between MINCHNID MAXCHNID 频道号（1字节） 取值范围MINCHNID~MAXCHNID</span></span><br><span class="line">    <span class="type">uint8_t</span> data[<span class="number">0</span>];           <span class="comment">// 柔性数组，实际数据存储位置（长度由MAX_DATA决定）</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">msg_channel_t</span>;  <span class="comment">//不做对其，因为chnid就只有一个字节， data 通常会很大（这个我还不是很理解，对其的话chnid不是最多也就是4个字节码，感觉有没有这个没多大差）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单个节目信息，第一字节描述频道号，第二三字节为本条信息的总字节数，desc[0]为变长数组 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_listdesc_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;             <span class="comment">// 频道号（1字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> deslength;        <span class="comment">// 自述包长度 描述信息长度</span></span><br><span class="line">    <span class="type">uint8_t</span> desc[<span class="number">0</span>];           <span class="comment">// 柔性数组，存储频道描述文本（UTF-8格式）</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">msg_listdesc_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 节目单数据包，第一字节描述频道号，list[0]为变长数组，存储msg_listdesc_t变长内容 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_list_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;           <span class="comment">// 频道号（1字节）</span></span><br><span class="line">    <span class="type">msg_listdesc_t</span> list[<span class="number">0</span>];  <span class="comment">// 柔性数组，包含多个节目条目</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msg_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><p>需要完成的任务:</p><p>1.将medialib目录下的文件转化为广播频道  </p><p>2.广播节目单</p><p>3.广播频道内容</p><p>整体的复现思路：</p><p>1.server_conf.h 里面有一些服务端的基础配置</p><p>2.threadpool 这个比较独立，就是基础的线程池，用来管理线程。不依赖于其他模块</p><p>3.tokenbucket 令牌桶，用来控制流量，防止流量过大</p><p>4.medialib 主要是将medialib目录下的文件转化为广播频道，然后通过list广播节目单，通过channel广播频道内容</p><p>5.channel 主要是广播频道内容</p><p>6.list 主要是广播节目单</p><p>7.server 主要是管理线程池，然后调用list和channel来广播节目单和频道内容</p><p>按照这个思路，依次完成各个模块，然后最后整合起来，就可以完成服务端了</p><h3 id="server-conf-h"><a href="#server-conf-h" class="headerlink" title="server_conf.h"></a>server_conf.h</h3><p>没啥好说的，直接看代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVER_CONF_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVER_CONF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MEDIADIR <span class="string">&quot;/var/medialib&quot;</span>    <span class="comment">// 默认本地媒体库路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_IF <span class="string">&quot;ens33&quot;</span>                  <span class="comment">// 默认网卡</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行模式，守护进程会把进程放到后台</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RNUMODE</span>                                <span class="comment">// 运行模式    </span></span><br><span class="line">&#123;</span><br><span class="line">    RUN_DAEMON = <span class="number">0</span>,                         <span class="comment">// 守护进程</span></span><br><span class="line">    RUN_FOREGROUND                          <span class="comment">// 前台运行</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">server_conf_t</span>                <span class="comment">// 配置文件,</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *mgroup;                           <span class="comment">// [字符串] 组播组IP地址（如：&quot;239.0.0.1&quot;）</span></span><br><span class="line">    <span class="type">char</span> *rcvport;                          <span class="comment">// [字符串] 接收端口号（如：&quot;8080&quot;）</span></span><br><span class="line">    <span class="type">char</span> *media_dir;                        <span class="comment">// [字符串] 媒体文件存储目录路径</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">RNUMODE</span> runmode;                   <span class="comment">// [字符] 运行模式（使用上述枚举值：RUN_DAEMON/RUN_FOREGROUND）</span></span><br><span class="line">    <span class="type">char</span> *ifname;                           <span class="comment">// [字符串] 网络接口名称（用于绑定组播）</span></span><br><span class="line">&#125; <span class="type">server_conf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">server_conf_t</span> server_conf;           <span class="comment">// 配置文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> serversd;                        <span class="comment">// 服务端套接字</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sndaddr;          <span class="comment">// 发送目的地址</span></span><br><span class="line"><span class="keyword">extern</span> ThreadPool_t *pool;                  <span class="comment">// 线程池对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__SERVER_CONF_H__</span></span></span><br></pre></td></tr></table></figure><h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>这个要说一下，我之前做过webserver的项目，那个里面的线程池比较简单，就是单纯的addtask，然后执行任务就可以了，但是这个项目里面的线程池构造的很巧妙，如果看了代码就可以很好理解。</p><p>首先最基本的功能肯定是有的，就是addTask，然后执行任务</p><p>这里面还附加了另外的功能，就是设置了一个管理的线程，这个管理的线程用于管理线程池中线程的数量，当任务不多的时候，没必要保存那么多线程，这个时候就可以kill掉一些，当然会有一个最小的数量。当任务很多的时候，就需要额外申请一些线程，但是这个数量也是有限制的。</p><p>这样来实现线程数量的动态管理，不会因为空线程而浪费太多的CPU资源</p><p>有几个注意的点:</p><p>1.NUMSTEP, 每次进行添加和删除线程都会增加或者删除 NUMSTEP 多的线程。不会说一下子减少到最少，或者是一下子添加到最大。拿减少的来举例：如果检测到很多线程空闲，我先减少NUMSTEP个线程，然后再次检测，如果还是空闲，我再减少NUMSTEP多线程。</p><p>2.numExit 这个设置的就很巧妙，就是如果我要删除掉一个线程，我就把numExit设置为1，并且notify一下，线程在working (在working函数里面) 的时候，先检测一下numExit是不是1 (这里肯定是要加锁的哈)，如果是1，那么我就不去task，直接退出（自杀）就好了，顺便把numExit–（上锁哈）。是不是感觉很巧妙</p><p>3.这里面有个独立出来的manage的线程哈，这个别忘记了，执行的是manager函数，里面就涉及到了之前说的一些线程的增加与删除等操作</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THREADPOOL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __THREADPOOL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG                                // 定义宏，DEBUG模式，打印尽可能多的的log信息，注释则不打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> ThreadPool_t;                      <span class="comment">// 对外隐藏ThreadPool_t内部实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_create</span></span><br><span class="line"><span class="comment"> * @description: 线程池创建函数，创建一个线程池</span></span><br><span class="line"><span class="comment"> * @param - min : 最小线程池数</span></span><br><span class="line"><span class="comment"> * @param - max : 最大线程池数</span></span><br><span class="line"><span class="comment"> * @param - queueCapacity : 最大任务队列数</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 NULL，成功返回线程池对象地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadPool_t* <span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> queueCapacity)</span></span>;                     <span class="comment">// 新创建一个线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_addtask</span></span><br><span class="line"><span class="comment"> * @description: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要添加任务的线程池</span></span><br><span class="line"><span class="comment"> * @param - function: 任务函数 void (*)(void *, volatile int *) 函数指针  【返回类型 (*指针变量名)(参数列表)】</span></span><br><span class="line"><span class="comment"> * @param - arg     : 任务函数参数</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_addtask</span><span class="params">(ThreadPool_t *, <span class="type">void</span> (*)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span> *), <span class="type">void</span> *)</span></span>;       <span class="comment">// 向任务队列添加一个任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @description: 线程池销毁函数，销毁一个线程池</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要销毁的线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(ThreadPool_t *)</span></span>;                                                 <span class="comment">// 销毁一个线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadexit_unlock</span></span><br><span class="line"><span class="comment"> * @description: 线程退出函数，并将该线程 ID 从工作者线程数组中删除</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadexit_unlock</span><span class="params">(ThreadPool_t *)</span></span>;                                                 <span class="comment">// 线程退出函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_live</span></span><br><span class="line"><span class="comment"> * @description: 获取线程池中存活线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 线程池中存活线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_live</span><span class="params">(ThreadPool_t *)</span></span>;                                                   <span class="comment">// 获得线程池中的存活线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_busy</span></span><br><span class="line"><span class="comment"> * @description: 获取线程池中忙线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 线程池中忙线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_busy</span><span class="params">(ThreadPool_t *)</span></span>;                                                   <span class="comment">// 获得线程池中的忙线程数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadpool.cs</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMSTEP 5      <span class="comment">// 线程增减步长</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024   <span class="comment">// 状态显示缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Task_t</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*function)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span> *);   <span class="comment">// 任务函数指针</span></span><br><span class="line">    <span class="type">void</span> *arg;                                  <span class="comment">// 任务参数</span></span><br><span class="line">&#125; Task_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程池类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span>&#123; </span><br><span class="line">    <span class="comment">// 任务队列相关</span></span><br><span class="line">    Task_t *taskQueue;          <span class="comment">// 任务队列数组</span></span><br><span class="line">    <span class="type">int</span> queueCapacity;          <span class="comment">// 任务队列最大容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;              <span class="comment">// 任务队列当前任务数</span></span><br><span class="line">    <span class="type">int</span> queueRear;              <span class="comment">// 队尾</span></span><br><span class="line">    <span class="type">int</span> queueFront;             <span class="comment">// 队头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程管理相关</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;        <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *workerIDs;       <span class="comment">// 工作者线程ID数组</span></span><br><span class="line">    <span class="type">int</span> numMax;                 <span class="comment">// 工作者线程最大的线程数</span></span><br><span class="line">    <span class="type">int</span> numMin;                 <span class="comment">// 工作者线程最小的线程数</span></span><br><span class="line">    <span class="type">int</span> numLive;                <span class="comment">// 工作者线程存活的线程数</span></span><br><span class="line">    <span class="type">int</span> numBusy;                <span class="comment">// 工作者线程忙的线程数</span></span><br><span class="line">    <span class="type">int</span> numExit;                <span class="comment">// 工作者线程需要退出的线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步机制</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 线程池锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 忙线程数锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 非满条件变量，用于唤醒生产者(添加任务函数)</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 非空条件变量，用于唤醒消费者(工作者线程)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> shutstatus;             <span class="comment">// 线程池状态，0 打开，-1 关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG 模式下 调试函数：图形化显示线程状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printstatus</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> numLive, numBusy;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程状态</span></span><br><span class="line">    numLive = <span class="built_in">get_thread_live</span>(pool);</span><br><span class="line">    numBusy = <span class="built_in">get_thread_busy</span>(pool);</span><br><span class="line">    <span class="comment">// 构建状态字符串：&#x27;+&#x27;表示忙碌，&#x27;-&#x27;表示空闲</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numBusy; i++)</span><br><span class="line">        <span class="built_in">strcat</span>(buf, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numLive - numBusy; i++)</span><br><span class="line">        <span class="built_in">strcat</span>(buf, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出格式：[++++++++++-----] : busy=10, live=15</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[ %s ] : busy == %d, live == %d\n&quot;</span>, buf, numBusy, numLive);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : working</span></span><br><span class="line"><span class="comment"> * @description: 工作者线程任务函数，负责从任务队列中取出任务并执行</span></span><br><span class="line"><span class="comment"> * @param - arg : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">working</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)arg;</span><br><span class="line">    Task_t task;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line">    <span class="comment">// 阻塞所有信号，避免工作线程处理信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);  <span class="comment">// 加线程池锁</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; pool-&gt;shutstatus == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool); <span class="comment">// 阻塞直到任务队列不为空</span></span><br><span class="line">            <span class="comment">// 被唤醒后检查是否需要退出线程</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;numExit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;numExit--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;numLive &gt; pool-&gt;numMin)&#123;</span><br><span class="line">                    pool-&gt;numLive--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    <span class="built_in">threadexit_unlock</span>(pool); <span class="comment">// 执行线程退出流程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutstatus == <span class="number">-1</span>) <span class="comment">// 若线程池已经关闭，线程自杀</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="built_in">threadexit_unlock</span>(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列之中取任务</span></span><br><span class="line">        task.function = pool-&gt;taskQueue[pool-&gt;queueFront].function;      <span class="comment">// 取出任务</span></span><br><span class="line">        task.arg = pool-&gt;taskQueue[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pool-&gt;taskQueue[pool-&gt;queueFront], <span class="number">0</span>, <span class="built_in">sizeof</span>(Task_t));   <span class="comment">// 从队列取出任务后，将队列中相应任务清空</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity; <span class="comment">// 移动队头指针</span></span><br><span class="line">        pool-&gt;queueSize--;                                               <span class="comment">// 任务队列中任务数量-1</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notFull);                             <span class="comment">// 唤醒任务生产者 //取出来一个任务后有空位置了自然要处理一下</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy); <span class="comment">// 加锁，改变线程池中忙线程数</span></span><br><span class="line">        pool-&gt;numBusy++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is going to work...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">        task.<span class="built_in">function</span>(task.arg, &amp;(pool-&gt;shutstatus)); <span class="comment">// 执行任务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is done work...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">free</span>(task.arg); <span class="comment">// 释放任务资源</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread [%ld] is free successful...&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is free successful...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">        task.function = <span class="literal">NULL</span>;</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;numBusy--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="built_in">sched_yield</span>(); <span class="comment">// 出让调度器给其他线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : manager</span></span><br><span class="line"><span class="comment"> * @description: 管理者线程任务函数，负责监视、增加和减少线程池中线程的存活线程数量</span></span><br><span class="line"><span class="comment"> * @param - arg : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">manager</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="type">int</span> numLive, numBusy, queueSize;</span><br><span class="line">    <span class="type">int</span> i, count;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞所有信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;shutstatus == <span class="number">0</span>) &#123;  <span class="comment">// 线程池运行中循环</span></span><br><span class="line">        <span class="comment">// 定时2s，可根据实际场景改变</span></span><br><span class="line">        tv.tv_sec = <span class="number">2</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">500000</span>;</span><br><span class="line">        <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);  <span class="comment">// select作为延时函数，替换sleep，保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前状态（减少锁持有时间）</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        numLive = pool-&gt;numLive;</span><br><span class="line">        queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        numBusy = pool-&gt;numBusy;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态扩容逻辑 </span></span><br><span class="line">        count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span> ((numLive &lt; queueSize || numBusy &gt; numLive*<span class="number">0.8</span>) &amp;&amp; numLive &lt; pool-&gt;numMax) &#123; <span class="comment">// 当存活线程数小于待取任务数量，并且小于最大线程数</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool); <span class="comment">// 添加 NUMSTEP 步长的线程</span></span><br><span class="line">            <span class="comment">// 以NUMSTEP为步长创建新线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;numMax &amp;&amp; count &lt; NUMSTEP &amp;&amp; pool-&gt;numLive &lt; pool-&gt;numMax; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;workerIDs[i] == <span class="number">0</span>) &#123;  <span class="comment">// 找到空闲位置</span></span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;workerIDs[i], <span class="literal">NULL</span>, working, pool);</span><br><span class="line">                    count++;</span><br><span class="line">                    pool-&gt;numLive++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放多余线程</span></span><br><span class="line">        <span class="keyword">if</span> (numBusy * <span class="number">2</span> &lt; numLive &amp;&amp; numLive &gt; pool-&gt;numMin) &#123; <span class="comment">// 当忙线程数 * 2小于存活线程数，并且存活的线程大于最小线程数</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;numExit = NUMSTEP;  <span class="comment">// 设置退出数量</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMSTEP; i++)&#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 唤醒工作线程，让其自杀</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printstatus</span>(pool); <span class="comment">// 打印线程池中线程信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">        <span class="built_in">sched_yield</span>();     <span class="comment">// 出让调度器  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_create</span></span><br><span class="line"><span class="comment"> * @description: 线程池创建函数，创建一个线程池</span></span><br><span class="line"><span class="comment"> * @param - min : 最小线程池数</span></span><br><span class="line"><span class="comment"> * @param - max : 最大线程池数</span></span><br><span class="line"><span class="comment"> * @param - queueCapacity : 最大任务队列数</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 NULL，成功返回线程池对象地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadPool_t *<span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueCapacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span>* pool = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ThreadPool_t));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;threadpool malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 申请内存失败就跳过剩下的初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化任务队列</span></span><br><span class="line">        pool-&gt;taskQueue = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Task_t) * queueCapacity);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;taskQueue == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;taskQueue malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;taskQueue, <span class="number">0</span>, <span class="built_in">sizeof</span>(Task_t) * queueCapacity); <span class="comment">//清空一下</span></span><br><span class="line">        pool-&gt;queueCapacity = queueCapacity; <span class="comment">// 各个成员的初始化</span></span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化工作线程数组</span></span><br><span class="line">        pool-&gt;workerIDs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;workerIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;workerIDs malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;workerIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max); <span class="comment">//清空一下</span></span><br><span class="line">        pool-&gt;numMax = max;</span><br><span class="line">        pool-&gt;numMin = min;</span><br><span class="line">        pool-&gt;numLive = min;</span><br><span class="line">        pool-&gt;numBusy = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;numExit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> || <span class="comment">// 初始化锁和条件变量</span></span><br><span class="line">            <span class="built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;lock init failed ...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutstatus = <span class="number">0</span>;  <span class="comment">// 运行状态 // 开启线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool); <span class="comment">// 创建管理者线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;min;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;workerIDs[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">pthread_create</span>(&amp;pool-&gt;workerIDs[i], <span class="literal">NULL</span>, working, pool); <span class="comment">// 创建工作者线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;workerIDs != <span class="literal">NULL</span>) <span class="comment">// 申请内存失败跳转到这里开始，依次析构 //这边是错误处理</span></span><br><span class="line">    <span class="built_in">free</span>(pool-&gt;workerIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;taskQueue != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @description: 线程池销毁函数，销毁一个线程池</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要销毁的线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thread pool is not existed ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;shutstatus = <span class="number">-1</span>;  <span class="comment">// 触发关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(pool-&gt;managerID, <span class="literal">NULL</span>); <span class="comment">// join掉managerID线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;numLive; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 唤醒所有存活线程，让其自杀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//信号量销毁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free掉空间</span></span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;workerIDs != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;workerIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;taskQueue != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread pool is going to be destroyed...&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread pool is going to be destroyed...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_addtask</span></span><br><span class="line"><span class="comment"> * @description: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要添加任务的线程池</span></span><br><span class="line"><span class="comment"> * @param - function: 任务函数</span></span><br><span class="line"><span class="comment"> * @param - arg     : 任务函数参数</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_addtask</span><span class="params">(ThreadPool_t *argPool, <span class="type">void</span> (*function)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span>*), <span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; pool-&gt;shutstatus == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool); <span class="comment">// 阻塞直到等待任务队列不为满</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutstatus == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread pool has been shutdown ...&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].function = function; <span class="comment">// 将任务存储到任务队列中</span></span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity; <span class="comment">// 移动队尾指针</span></span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 队列不为空，唤醒工作者线程</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadexit_unlock</span></span><br><span class="line"><span class="comment"> * @description: 线程退出函数，并将该线程 ID 从工作者线程数组中删除</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadexit_unlock</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">pthread_t</span> tmptid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;numMax; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;workerIDs[i] == tmptid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;workerIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread [%ld] is going to exit...&quot;</span>, tmptid);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is going to exit...\n&quot;</span>, tmptid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_live</span></span><br><span class="line"><span class="comment"> * @description: 获取线程池中存活线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 线程池中存活线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_live</span><span class="params">(ThreadPool_t *argPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    num = pool-&gt;numLive;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_busy</span></span><br><span class="line"><span class="comment"> * @description: 获取线程池中忙线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return : 线程池中忙线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_busy</span><span class="params">(ThreadPool_t *argPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    num = pool-&gt;numBusy;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tokenbucket"><a href="#tokenbucket" class="headerlink" title="tokenbucket"></a>tokenbucket</h3><p>令牌桶，涉及到一些流量控制，就是我们在读mp3媒体文件的时候，不是要传递一个读取多少字节的参数吗？ 这个时候咱们先从令牌桶里面取令牌，如果说令牌数量很充足，就是大于size (size是咱们想要读的字节) 的话就取出size个令牌，然后读size个字节。但是如果说令牌桶里面取令牌不足size，比如只有size1这么多了，那么咱们读数据的时候就取出size1这么多字节。</p><p>这里面有个计时器，每一秒会使得令牌桶里面的令牌的数量增加</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> cps;                    <span class="comment">// 步长</span></span><br><span class="line">    <span class="type">int</span> burst;                  <span class="comment">// 上限</span></span><br><span class="line">    <span class="type">int</span> token;                  <span class="comment">// 拥有的令牌</span></span><br><span class="line">    <span class="type">int</span> pos;                    <span class="comment">// 自述数组下标 在全局job数组中的位置索引,不是只有一个桶</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里看一下单个令牌桶的结构</p><p>注意的点：</p><p>1.这个定时器是额外定义的线程，他不会占用主线程。</p><p>2.并不是只有一个令牌桶，这里设计了一个令牌桶的数组 job数组。里面存储了好多令牌桶，这样针对每个频道，我们都可以为其分配一个令牌桶。让每个频道独立起来。而不是所有的频道公用一个令牌桶。</p><p>3.注意这个令牌桶使用的位置哈，并不是sendto和recvfrom这两个函数用，而是在读取mp3文件的时候来用，就是通过控制文件读取的速度来控制sendto发送数据包的速度。</p><p>4.这里有两种类型的锁，一个是job队列的锁，就是对job队列进行操作的时候必须得加锁。还有一个是桶内部的锁，看上面的结构，是不是每个桶都有一个锁，这是为了在实现安全的修改每个桶里面的数据。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TOKENBUCKET_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TOKENBUCKET_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKENBUCKET_MAX 1024    <span class="comment">//最大令牌桐对象数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="type">tokenbt_t</span>;         <span class="comment">//对外隐藏内部实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_init</span></span><br><span class="line"><span class="comment"> * @description: 令牌桶初始化，初始化一个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - cps     : 步长 每一s增加多少令牌数量</span></span><br><span class="line"><span class="comment"> * @param - burst   : 上限零牌数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌桶对象，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">tokenbt_t</span> *<span class="title">tokenbt_init</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_fetchtoken</span></span><br><span class="line"><span class="comment"> * @description: 从令牌桶对象中取令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 要取的零牌数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_fetchtoken</span><span class="params">(<span class="type">tokenbt_t</span> *, <span class="type">int</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_checktoken</span></span><br><span class="line"><span class="comment"> * @description: 检查令牌桶对象的令牌数</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_checktoken</span><span class="params">(<span class="type">tokenbt_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_returntoken</span></span><br><span class="line"><span class="comment"> * @description: 给令牌桶对象归还令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 令牌</span></span><br><span class="line"><span class="comment"> * @return : 成功返回归还的令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_returntoken</span><span class="params">(<span class="type">tokenbt_t</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy</span></span><br><span class="line"><span class="comment"> * @description: 销毁单个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy</span><span class="params">(<span class="type">tokenbt_t</span> *)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy_all</span></span><br><span class="line"><span class="comment"> * @description: 销毁所有令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy_all</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_shutdown</span></span><br><span class="line"><span class="comment"> * @description: 关闭令牌流控功能模块</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_shutdown</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__TOKENBUCKET_h__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> cps;                    <span class="comment">// 步长</span></span><br><span class="line">    <span class="type">int</span> burst;                  <span class="comment">// 上限</span></span><br><span class="line">    <span class="type">int</span> token;                  <span class="comment">// 拥有的令牌</span></span><br><span class="line">    <span class="type">int</span> pos;                    <span class="comment">// 自述数组下标 在全局job数组中的位置索引,不是只有一个桶</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在有TOKENBUCKET_MAX个桶</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *token_pool[TOKENBUCKET_MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护job数组的互斥锁，防止多线程并发修改</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_pool = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="comment">// 确保init模块只会加载一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> once_init = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="comment">// 定时器的线程ID</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : woking</span></span><br><span class="line"><span class="comment"> * @description: 任务函数，负责固定时间给令牌桶添加令牌数</span></span><br><span class="line"><span class="comment"> * @param - arg     : NULL</span></span><br><span class="line"><span class="comment"> * @return : NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">woking</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);     <span class="comment">// 屏蔽所有信号，只留主线程处理信号即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool); <span class="comment">//对token_pool加锁</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(token_pool[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">                token_pool[i]-&gt;token += token_pool[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span> (token_pool[i]-&gt;token &gt; token_pool[i]-&gt;burst)&#123; <span class="comment">//已经到最大值了</span></span><br><span class="line">                    token_pool[i]-&gt;token = token_pool[i]-&gt;burst;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">pthread_cond_broadcast</span>(&amp;token_pool[i]-&gt;cond); <span class="comment">//notifyAll</span></span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">        tv.tv_sec = <span class="number">1</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);       <span class="comment">// 安全定时 1 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_free_pos_unlocked</span></span><br><span class="line"><span class="comment"> * @description: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 失败返回 -1，成功返回 找到的空闲数组位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">()</span></span>&#123;  <span class="comment">//找到token_pool之中第一个空闲值</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(token_pool[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : module_unload</span></span><br><span class="line"><span class="comment"> * @description: 令牌桶模块卸载</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">module_unload</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_cancel</span>(tid);        <span class="comment">// 取消任务函数线程(负责固定时间给令牌桶添加令牌数)</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">tokenbt_destroy_all</span>();</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;free job is done ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : module_load</span></span><br><span class="line"><span class="comment"> * @description: 令牌桶模块加载</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">module_load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, woking, <span class="literal">NULL</span>);  <span class="comment">//创建计时器线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_init</span></span><br><span class="line"><span class="comment"> * @description: 令牌桶初始化，初始化一个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - cps     : 步长</span></span><br><span class="line"><span class="comment"> * @param - burst   : 上限零牌数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌桶对象，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">tokenbt_t</span> *<span class="title">tokenbt_init</span><span class="params">(<span class="type">int</span> cps, <span class="type">int</span> burst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>* tb;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;once_init, module_load);  <span class="comment">// 任务函数只执行一次</span></span><br><span class="line">    tb = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> <span class="type">tokenbt_t</span>));  <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">if</span>(tb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    tb-&gt;cps = cps;    <span class="comment">//1s增加多少令牌数</span></span><br><span class="line">    tb-&gt;burst = burst;<span class="comment">//令牌数最大值</span></span><br><span class="line">    tb-&gt;token = <span class="number">0</span>;    <span class="comment">//初始令牌数</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;tb-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;tb-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//加锁，要处理tb里面的值了</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">    pos = <span class="built_in">get_free_pos_unlocked</span>();</span><br><span class="line">    <span class="comment">// 没有空余的空间了</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);      <span class="comment">// 获取是失败别忘了解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;tb-&gt;mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;tb-&gt;cond);</span><br><span class="line">        <span class="built_in">free</span>(tb);</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;have not any pool pos...&quot;</span>);</span><br><span class="line">        <span class="comment">// fprintf(stderr, &quot;have not any pool pos...\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把tb插入到工作队之中</span></span><br><span class="line">    tb-&gt;pos = pos;</span><br><span class="line">    token_pool[pos] = tb;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">    <span class="keyword">return</span> tb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_fetchtoken</span></span><br><span class="line"><span class="comment"> * @description: 从令牌桶对象中取令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 要取的零牌数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_fetchtoken</span><span class="params">(<span class="type">tokenbt_t</span> *token, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || token == <span class="literal">NULL</span>)     <span class="comment">// 判断参数是否合法</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">//每一次操作tb内部的东西都要加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (tb-&gt;token &lt;= <span class="number">0</span>)&#123;  <span class="comment">//没有空余的token了，就等待</span></span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;tb-&gt;cond, &amp;tb-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    n = tb-&gt;token;</span><br><span class="line">    n = n &lt; size ? n : size;        <span class="comment">// 取得零牌数较小的那一个</span></span><br><span class="line">    tb-&gt;token -= n;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> n;   <span class="comment">//返回的并不是size，而是实际取到的令牌数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_checktoken</span></span><br><span class="line"><span class="comment"> * @description: 检查令牌桶对象的令牌数</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return : 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_checktoken</span><span class="params">(<span class="type">tokenbt_t</span> *token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="type">int</span> token_size;</span><br><span class="line">    <span class="keyword">if</span>(tb == <span class="literal">NULL</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    token_size = tb-&gt;token;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> token_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_returntoken</span></span><br><span class="line"><span class="comment"> * @description: 给令牌桶对象归还令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 令牌</span></span><br><span class="line"><span class="comment"> * @return : 成功返回归还的令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_returntoken</span><span class="params">(<span class="type">tokenbt_t</span> *token, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || token == <span class="literal">NULL</span>)&#123; <span class="comment">//参数正常</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    tb-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span> (tb-&gt;token &gt; tb-&gt;burst)</span><br><span class="line">        tb-&gt;token = tb-&gt;burst;</span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;tb-&gt;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy</span></span><br><span class="line"><span class="comment"> * @description: 销毁单个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy</span><span class="params">(<span class="type">tokenbt_t</span> *token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">    token_pool[tb-&gt;pos] = <span class="literal">NULL</span>;        <span class="comment">//要把这个令牌桶从工作队列中拿出去</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">    <span class="comment">// 然后再释放掉这个令牌桶内部的空间</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;tb-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(tb);</span><br><span class="line">    tb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy_all</span></span><br><span class="line"><span class="comment"> * @description: 销毁所有令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy_all</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (token_pool[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">            <span class="built_in">pthread_cond_destroy</span>(&amp;token_pool[i]-&gt;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(token_pool[i]);</span><br><span class="line">        token_pool[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_shutdown</span></span><br><span class="line"><span class="comment"> * @description: 关闭令牌流控功能模块</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">module_unload</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="medialib"><a href="#medialib" class="headerlink" title="medialib"></a>medialib</h3><p>这个的任务就是将我们本地的medialib文件夹里面的内容转化为广播频道</p><p>主要完成两项任务：</p><p>1.节目单的组合(mlib_getchnlist函数)</p><p>2.读取频道内部的数据（mlib_readchn函数）</p><p>这两个函数是最关键的，之前所说的令牌桶就是在mlib_readchn函数里面用的，就是读取mp3文件的操作</p><p>首先我们来说一下结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── medialib</span><br><span class="line">│   ├── ch1</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 世界这么大还是遇见你.mp3</span><br><span class="line">│   │   └── 起风了.mp3</span><br><span class="line">│   ├── ch2</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 带你去旅行.mp3</span><br><span class="line">│   │   └── 再见只是陌生人.mp3</span><br><span class="line">│   ├── ch3</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── Summertime Sadness.mp3</span><br><span class="line">│   │   └── 学猫叫.mp3</span><br><span class="line">│   └── ch4</span><br></pre></td></tr></table></figure><p>每个ch之中都会有一个desc.txt的文件，这个里面就写的一些频道的基本的描述，比如:</p><p>ch1中内容就一行: pop music,起风了,世界这么大还是遇见你</p><p>所以我们要获取一下这个节目单的描述啥的还是很简单的，就是读取desc.txt文件就行了</p><p>我们看一下每个频道的管理的结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">channel_context_t</span> &#123;   <span class="comment">//频道内容描述结构体</span></span><br><span class="line">    <span class="type">chnid_t</span> chnid;   <span class="comment">// 频道ID</span></span><br><span class="line">    <span class="type">char</span>* desc;      <span class="comment">// 频道描述</span></span><br><span class="line">    <span class="type">glob_t</span> globes;   <span class="comment">// 目录项</span></span><br><span class="line">    <span class="type">int</span> pos;         <span class="comment">// 当前歌曲在媒体库中的位置</span></span><br><span class="line">    <span class="type">int</span> fd;          <span class="comment">// 当前歌曲的文件描述符</span></span><br><span class="line">    <span class="type">off_t</span> offset;    <span class="comment">// 当前歌曲的读取偏移量</span></span><br><span class="line">    <span class="type">tokenbt_t</span> *tb;   <span class="comment">// 流量控制</span></span><br><span class="line">&#125; <span class="type">channel_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//   size_t   gl_pathc;    /* 匹配到的路径数目 */</span></span><br><span class="line"><span class="comment">//   char   **gl_pathv;    /* 匹配到的路径名指针数组 */ 是一个指向匹配到的路径名字符串数组的指针。数组中的每个元素是一个路径名字符串，最后一个元素为 NULL，表示数组结束。</span></span><br><span class="line"><span class="comment">//   size_t   gl_offs;     /* 起始位置索引 */ 表示起始位置索引。如果设置了 GLOB_DOOFFS 标志，glob() 函数会在 gl_pathv 的开头预留 gl_offs 个空指针，实际的匹配路径名从第 gl_offs 个位置开始。</span></span><br><span class="line"><span class="comment">// &#125; glob_t;</span></span><br></pre></td></tr></table></figure><p>这里主要是几个参数可能不好理解</p><p>1.glob_t globes 这个主要是用来搜索一下*mp3的内容的，搜索出来的文件路径会存在结构体的gl_pathv里面</p><p>2.pos 就是因为会有很多.mp3文件，这个就标志着这是第几个文件，从0开始，这样的话方便列表循环播放</p><p>3.fd 这个就是目前打开的mp3的文件描述符，用以后面读文件</p><p>4.offset 这个文件读到哪里了，用这个来表示，方便下次继续读</p><p>5.tokenbt_t *tb;   令牌桶就用在这里</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MEDIALIB_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MEDIALIB_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录每一条节目单信息：频道号chnid，描述信息char* desc</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">mlib_listdesc_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;  <span class="comment">// 频道唯一标识符，使用prot.h中定义的chnid_t类型</span></span><br><span class="line">    <span class="type">char</span>* desc;     <span class="comment">// 频道描述信息，动态分配的字符串指针</span></span><br><span class="line">&#125;<span class="type">mlib_listdesc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取频道列表</span></span><br><span class="line"><span class="comment"> * @param  [输出参数] 接收频道信息结构体数组指针的地址</span></span><br><span class="line"><span class="comment"> * @param  [输出参数] 接收频道数量的指针</span></span><br><span class="line"><span class="comment"> * @return  成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_getchnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> **,<span class="type">int</span> *)</span></span>; <span class="comment">// 从媒体库获取节目单信息和频道总个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放频道列表内存</span></span><br><span class="line"><span class="comment"> * @param  要释放的频道信息结构体数组指针</span></span><br><span class="line"><span class="comment"> * @return 总是返回0表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> *)</span></span>;       <span class="comment">// 释放节目单信息存储所占的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放chn_context数组的内存 </span></span><br><span class="line"><span class="comment"> * chn_context里面存储的是所有的广播频道号</span></span><br><span class="line"><span class="comment"> * @return 总是返回0表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechncontext</span><span class="params">()</span></span>;                            <span class="comment">// 释放chn_context数组的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_readchn</span></span><br><span class="line"><span class="comment"> * @description: 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @param - buf     : 存入流媒体内容的缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param - size    : buf的最大容量</span></span><br><span class="line"><span class="comment"> * @return : 返回读取到的有效内容总长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mlib_readchn</span><span class="params">(<span class="type">chnid_t</span>, <span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;        <span class="comment">// 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MEDIALIB_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHSIZE 4096      <span class="comment">// 文件路径最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 256       <span class="comment">// 文件名最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINEBUFSIZE 1024   <span class="comment">// 读文件行缓冲区</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MP3_BITRATE (128 * 1024)    <span class="comment">// 128 * 1024 bps</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">channel_context_t</span> &#123;   <span class="comment">//频道内容描述结构体</span></span><br><span class="line">    <span class="type">chnid_t</span> chnid;   <span class="comment">// 频道ID</span></span><br><span class="line">    <span class="type">char</span>* desc;      <span class="comment">// 频道描述</span></span><br><span class="line">    <span class="type">glob_t</span> globes;   <span class="comment">// 目录项</span></span><br><span class="line">    <span class="type">int</span> pos;         <span class="comment">// 当前歌曲在媒体库中的位置</span></span><br><span class="line">    <span class="type">int</span> fd;          <span class="comment">// 当前歌曲的文件描述符</span></span><br><span class="line">    <span class="type">off_t</span> offset;    <span class="comment">// 当前歌曲的读取偏移量</span></span><br><span class="line">    <span class="type">tokenbt_t</span> *tb;   <span class="comment">// 流量控制</span></span><br><span class="line">&#125; <span class="type">channel_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//   size_t   gl_pathc;    /* 匹配到的路径数目 */</span></span><br><span class="line"><span class="comment">//   char   **gl_pathv;    /* 匹配到的路径名指针数组 */ 是一个指向匹配到的路径名字符串数组的指针。数组中的每个元素是一个路径名字符串，最后一个元素为 NULL，表示数组结束。</span></span><br><span class="line"><span class="comment">//   size_t   gl_offs;     /* 起始位置索引 */ 表示起始位置索引。如果设置了 GLOB_DOOFFS 标志，glob() 函数会在 gl_pathv 的开头预留 gl_offs 个空指针，实际的匹配路径名从第 gl_offs 个位置开始。</span></span><br><span class="line"><span class="comment">// &#125; glob_t;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">channel_context_t</span> chn_context[MAXCHNID + <span class="number">1</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> total_chn = <span class="number">0</span>;           <span class="comment">// 总共的有效频道个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : getpathcontent</span></span><br><span class="line"><span class="comment"> * @description: 从指定的路径中取得该频道所有需要的信息</span></span><br><span class="line"><span class="comment"> * @param - path    : 文件路径</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 channel_context_t 对象地址; 失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">channel_context_t</span> *<span class="title">getpathcontent</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[LINEBUFSIZE];    <span class="comment">//行缓冲</span></span><br><span class="line">    <span class="type">char</span> pathbuf[PATHSIZE];       <span class="comment">//文件路径</span></span><br><span class="line">    <span class="type">char</span> namebuf[NAMESIZE];       <span class="comment">//文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> descfd, ret;</span><br><span class="line">    <span class="type">channel_context_t</span> *me;</span><br><span class="line">    <span class="comment">//由于是一个静态变量所以相当于一直在操作同一块内存 有叠加效果  静态频道ID计数器，初始为最小频道ID</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> curr_chnid = MINCHNID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先清空一下值</span></span><br><span class="line">    <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));</span><br><span class="line">    <span class="built_in">memset</span>(pathbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(pathbuf));</span><br><span class="line">    <span class="built_in">memset</span>(namebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(namebuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值，字符串操作</span></span><br><span class="line">    <span class="built_in">strncpy</span>(pathbuf, path, PATHSIZE - <span class="number">1</span>);                         <span class="comment">//path</span></span><br><span class="line">    <span class="built_in">strncpy</span>(namebuf, <span class="string">&quot;/desc.txt&quot;</span>, NAMESIZE - <span class="number">1</span>);                  <span class="comment">//desc name</span></span><br><span class="line">    <span class="built_in">strncat</span>(pathbuf, namebuf, PATHSIZE - <span class="built_in">strlen</span>(pathbuf) - <span class="number">1</span>);    <span class="comment">//完整path</span></span><br><span class="line"></span><br><span class="line">    descfd = <span class="built_in">open</span>(pathbuf, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (descfd &lt; <span class="number">0</span>)&#123;   <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%s is not a lib ...&quot;</span>, pathbuf);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">read</span>(descfd, linebuf, LINEBUFSIZE);  <span class="comment">//读文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%s haven&#x27;t anything ...&quot;</span>, pathbuf);</span><br><span class="line">        <span class="built_in">close</span>(descfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(descfd);  <span class="comment">//这里要注意哈，desc文件里面本来就只有一行</span></span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">channel_context_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(me == <span class="literal">NULL</span>)&#123; <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;desc = <span class="built_in">strdup</span>(linebuf); <span class="comment">//strdup 复制字符串</span></span><br><span class="line">    <span class="comment">// 令牌桶 流量控制</span></span><br><span class="line">    me-&gt;tb = <span class="built_in">tokenbt_init</span>(MP3_BITRATE / <span class="number">8</span>, MP3_BITRATE / <span class="number">8</span> * <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;tb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;tokenbt_init() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个时候已经把 desc.txt里的内容拿到了，现在该匹配mp3了</span></span><br><span class="line">    <span class="built_in">memset</span>(pathbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(pathbuf));</span><br><span class="line">    <span class="built_in">memset</span>(namebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(namebuf));</span><br><span class="line">    <span class="comment">// 一样的操作，path name path+name 只不过这里的是*.mp3</span></span><br><span class="line">    <span class="built_in">strncpy</span>(pathbuf, path, PATHSIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(namebuf, <span class="string">&quot;/*.mp3&quot;</span>, NAMESIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(pathbuf, namebuf, PATHSIZE - <span class="built_in">strlen</span>(pathbuf) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">glob</span>(pathbuf, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;me-&gt;globes);  <span class="comment">//glob 匹配.mp3文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;glob() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;pos = <span class="number">0</span>;     <span class="comment">//第1个pos，第一个mp3</span></span><br><span class="line">    me-&gt;offset = <span class="number">0</span>;  <span class="comment">//还没开始读，所以就offset（文件内部偏移）就是0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开第一个mp3文件</span></span><br><span class="line">    me-&gt;fd = <span class="built_in">open</span>(me-&gt;globes.gl_pathv[me-&gt;pos], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录当前的 curr_chnid</span></span><br><span class="line">    me-&gt;chnid = curr_chnid;</span><br><span class="line">    curr_chnid++;</span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : open_next</span></span><br><span class="line"><span class="comment"> * @description: 打开指定频道的下一首歌曲</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_next</span><span class="params">(<span class="type">chnid_t</span> chnid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chn_context[chnid].globes.gl_pathc; i++)&#123;</span><br><span class="line">        chn_context[chnid].pos++;</span><br><span class="line">        <span class="keyword">if</span> (chn_context[chnid].pos == chn_context[chnid].globes.gl_pathc)&#123;</span><br><span class="line">            chn_context[chnid].pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="comment">// 列表循环</span></span><br><span class="line">        <span class="built_in">close</span>(chn_context[chnid].fd); <span class="comment">//先关闭一下当前的</span></span><br><span class="line">        <span class="comment">// 打开下一首</span></span><br><span class="line">        chn_context[chnid].fd = <span class="built_in">open</span>(chn_context[chnid].globes.gl_pathv[chn_context[chnid].pos], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (chn_context[chnid].fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//打不开倒不至于直接退出，再继续循环打开下一首</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_getchnlist</span></span><br><span class="line"><span class="comment"> * @description: 从媒体库获取节目单信息和频道总个数</span></span><br><span class="line"><span class="comment"> * @param - list    : 传出参数，填入节目单信息</span></span><br><span class="line"><span class="comment"> * @param - size    : 传出参数，填入频道总个数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_getchnlist</span><span class="params">(<span class="type">mlib_listdesc_t</span> **list, <span class="type">int</span> *size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,ret;</span><br><span class="line">    <span class="type">glob_t</span> globes;</span><br><span class="line">    <span class="type">char</span> path[PATHSIZE];</span><br><span class="line">    <span class="type">channel_context_t</span> *retmp;</span><br><span class="line">    <span class="type">mlib_listdesc_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(chn_context, <span class="number">0</span>, <span class="built_in">sizeof</span>(chn_context));</span><br><span class="line">    <span class="comment">//初始化频道数组 </span></span><br><span class="line">    <span class="keyword">for</span> (i = MINCHNID; i &lt; MAXCHNID + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        chn_context[i].chnid = <span class="number">-1</span>; <span class="comment">//设置为无效频道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿到medialib path  /*表示medialib下面所有的文件夹(ch1 ch2 ch3 ch4....)</span></span><br><span class="line">    <span class="built_in">snprintf</span>(path, PATHSIZE, <span class="string">&quot;%s/*&quot;</span>, server_conf.media_dir);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">glob</span>(path, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;globes);  <span class="comment">//匹配一下</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;glob() : failed ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配一下空间</span></span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">mlib_listdesc_t</span>) * globes.gl_pathc);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; globes.gl_pathc; i++)&#123;       <span class="comment">// 分别获取 ch1 ch2 ch3 ch4 中的频道内容并保存在 chn_context 中</span></span><br><span class="line">        retmp = <span class="built_in">getpathcontent</span>(globes.gl_pathv[i]);</span><br><span class="line">        <span class="keyword">if</span> (retmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//注意这里会把retmp放到全局静态的chn_context之中</span></span><br><span class="line">            <span class="built_in">memcpy</span>(chn_context + retmp-&gt;chnid, retmp, <span class="built_in">sizeof</span>(*retmp));</span><br><span class="line">            tmp[total_chn].chnid = retmp-&gt;chnid;</span><br><span class="line">            tmp[total_chn].desc = <span class="built_in">strdup</span>(retmp-&gt;desc);</span><br><span class="line">            total_chn++;</span><br><span class="line">            <span class="built_in">free</span>(retmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *list = <span class="built_in">realloc</span>(tmp, <span class="built_in">sizeof</span>(<span class="type">mlib_listdesc_t</span>) * total_chn);      <span class="comment">// 给 *list 重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;realloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *size = total_chn;</span><br><span class="line">    <span class="built_in">globfree</span>(&amp;globes);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_freechnlist</span></span><br><span class="line"><span class="comment"> * @description: 释放节目单信息存储所占的内存</span></span><br><span class="line"><span class="comment"> * @param - list    : </span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> *list)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_chn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(list[i].desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_freechncontext</span></span><br><span class="line"><span class="comment"> * @description: 释放chn_context数组的内存</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechncontext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = MINCHNID; i &lt; MAXCHNID + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chn_context[i].chnid != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(chn_context[i].desc);</span><br><span class="line">            <span class="built_in">globfree</span>(&amp;chn_context[i].globes);</span><br><span class="line">            <span class="built_in">close</span>(chn_context[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_readchn</span></span><br><span class="line"><span class="comment"> * @description: 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @param - buf     : 存入流媒体内容的缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param - size    : buf的最大容量</span></span><br><span class="line"><span class="comment"> * @return : 返回读取到的有效内容总长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mlib_readchn</span><span class="params">(<span class="type">chnid_t</span> chnid, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> token, len;</span><br><span class="line">    <span class="comment">//获取一下令牌桶之中的令牌，返回的是实际获取的令牌数量，因为可能不够size这么多令牌</span></span><br><span class="line">    token = <span class="built_in">tokenbt_fetchtoken</span>(chn_context[chnid].tb, size);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//  从指定的偏移量处开始读取 read的话是从当前文件偏移量开始读取(当前文件偏移量存储再文件描述符之中)</span></span><br><span class="line">        <span class="comment">//  pread 1是可以指定偏移两 2是线程安全，不会引文其他线程读取了文件改变了文件偏移</span></span><br><span class="line">        len = <span class="built_in">pread</span>(chn_context[chnid].fd, buf, token, chn_context[chnid].offset);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;pread() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">open_next</span>(chnid);       <span class="comment">// 如果这首歌曲读取失败了，那就切换下一首歌曲播放</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;song: %s is over&quot;</span>, chn_context[chnid].globes.gl_pathv[chn_context[chnid].pos]);</span><br><span class="line">            <span class="built_in">open_next</span>(chnid);       <span class="comment">// 这首歌曲读取结束了，那就切换下一首歌曲播放</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chn_context[chnid].offset += len;  <span class="comment">//正常读取了就加offset</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; token)                <span class="comment">// 令牌没用完，归还令牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tokenbt_returntoken</span>(chn_context[chnid].tb, token - len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>之前不是medialib把咱么medialib文件夹里面的东西转化为频道了吗</p><p>这里就是组装一下，节目单频道，用来发送节目单的数据，代码很简单，看一下就好。</p><p>就是，拿到组装号的 节目点list，然后处理一下，然后发送就好。</p><p>这里的发送时调用的线程池（addtask）</p><p>就是一直发，1s发一次。另外频道号之前在protocol.h已经定义好了，频道列表的频道号固定是0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_list_create</span><span class="params">(<span class="type">mlib_listdesc_t</span> *, <span class="type">int</span>)</span></span>;   <span class="comment">// 节目单频道任务创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__LIST_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要发送的节目信息内容和内容的长度打包，传给线程池任务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">send_list_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">msg_list_t</span> msg[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="type">send_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : sendlist</span></span><br><span class="line"><span class="comment"> * @description: 定时发送节目单信息</span></span><br><span class="line"><span class="comment"> * @param - arg     : send_list_t类型</span></span><br><span class="line"><span class="comment"> * @param - shut    : 线程池当前开启状态</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendlist</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">volatile</span> <span class="type">int</span> *shut)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">send_list_t</span> *info = (<span class="type">send_list_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (*shut == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">sendto</span>(serversd, info-&gt;msg, info-&gt;len, <span class="number">0</span>, (<span class="type">void</span> *)&amp;sndaddr, <span class="built_in">sizeof</span>(sndaddr));</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%7s thread sendto %5d bytes, pool status is %d&quot;</span>, <span class="string">&quot;list&quot;</span>, len, *shut);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : thr_list_create</span></span><br><span class="line"><span class="comment"> * @description: 节目单频道任务创建</span></span><br><span class="line"><span class="comment"> * @param - list    : 从媒体库读取的原始节目信息数据</span></span><br><span class="line"><span class="comment"> * @param - size    : 频道总个数</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_list_create</span><span class="params">(<span class="type">mlib_listdesc_t</span> *list, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len, totalsize;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">msg_list_t</span> *msg_list;</span><br><span class="line">    <span class="type">msg_listdesc_t</span> *desc_list;</span><br><span class="line">    <span class="type">send_list_t</span> *info;</span><br><span class="line"></span><br><span class="line">    totalsize = <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        totalsize += <span class="built_in">sizeof</span>(<span class="type">msg_listdesc_t</span>) + <span class="built_in">strlen</span>(list[i].desc);     <span class="comment">// 统计节目单信息有效数据的总长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info = <span class="built_in">malloc</span>(totalsize + <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 1节目单1 这样的 所以最前面得加个int</span></span><br><span class="line">    <span class="keyword">if</span> (info == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, totalsize + <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    info-&gt;len = totalsize;              <span class="comment">// 将有效数据的总长度填入申请的内存中</span></span><br><span class="line">    msg_list = info-&gt;msg;</span><br><span class="line"></span><br><span class="line">    msg_list-&gt;chnid = LISTCHNID;        <span class="comment">// 填入 LISTCHNID 频道号 0 号只广播频道信息</span></span><br><span class="line">    desc_list = msg_list-&gt;list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)          <span class="comment">// 将节目单信息的有效数据内容填入申请的内存中</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">sizeof</span>(<span class="type">msg_listdesc_t</span>) + <span class="built_in">strlen</span>(list[i].desc);</span><br><span class="line">        desc_list-&gt;chnid = list[i].chnid;</span><br><span class="line">        desc_list-&gt;deslength = <span class="built_in">htons</span>(len);</span><br><span class="line">        <span class="built_in">strncpy</span>((<span class="type">void</span> *)desc_list-&gt;desc, list[i].desc, <span class="built_in">strlen</span>(list[i].desc));</span><br><span class="line">        desc_list = (<span class="type">void</span> *)(((<span class="type">char</span> *)desc_list) + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadpool_addtask</span>(pool, sendlist, info); <span class="comment">// 向任务队列添加一个任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>这个就是某个频道，一直发送数据了，不管有没有客户端都要一直发送</p><p>sendchannel里面调用了mlib_readchn，发送完一个mp3文件之后会列表循环，不会停止发送哈</p><p>之前也说了mlib_readchn里面使用了令牌桶进行了流量控制</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CHANNEL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CHANNEL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_channel_create</span><span class="params">(<span class="type">chnid_t</span>)</span></span>;    <span class="comment">// 流媒体音乐频道任务创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CHANNEL_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : sendchannel</span></span><br><span class="line"><span class="comment"> * @description: 读取媒体库中流媒体的内容并发送</span></span><br><span class="line"><span class="comment"> * @param - arg     : msg_channel_t类型</span></span><br><span class="line"><span class="comment"> * @param - shut    : 线程池当前开启状态</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sendchannel</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">volatile</span> <span class="type">int</span> *shut)</span></span>&#123;</span><br><span class="line">    <span class="type">msg_channel_t</span> *context = (<span class="type">msg_channel_t</span> *)arg;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (*shut == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(context-&gt;data, <span class="number">0</span>, MAX_CHANNEL_DATA - <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>));</span><br><span class="line">        <span class="comment">//读取频道里面的内容</span></span><br><span class="line">        len = <span class="built_in">mlib_readchn</span>(context-&gt;chnid, context-&gt;data, MAX_CHANNEL_DATA - <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>));</span><br><span class="line">        len = <span class="built_in">sendto</span>(serversd, context, len + <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>), <span class="number">0</span>, (<span class="type">void</span> *)&amp;sndaddr, <span class="built_in">sizeof</span>(sndaddr));</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%7s thread sendto %5d bytes, pool status is %d&quot;</span>, <span class="string">&quot;channel&quot;</span>, len, *shut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : thr_channel_create</span></span><br><span class="line"><span class="comment"> * @description: 流媒体音乐频道任务创建</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @return : 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_channel_create</span><span class="params">(<span class="type">chnid_t</span> chnid)</span></span>&#123;</span><br><span class="line">    <span class="type">msg_channel_t</span> *context;</span><br><span class="line">    context = <span class="built_in">malloc</span>(MAX_CHANNEL_DATA);     <span class="comment">// 申请内存，将本块内存地址传入线程池中</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="comment">// fprintf(stderr, &quot;malloc() : %s\n&quot;, strerror(errno));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(context, <span class="number">0</span>, MAX_CHANNEL_DATA);</span><br><span class="line">    context-&gt;chnid = chnid;</span><br><span class="line">    <span class="built_in">threadpool_addtask</span>(pool, sendchannel, context);     <span class="comment">// context指向的内存由线程池负责释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>前面都讲了，这里就没啥好讲的了，就是将所有的东西组合一下就好</p><p>两点注意：</p><p>1.守护进程</p><p>就是将整个的进程置于后台，终端就不输出了</p><p>就是fork一个子进程，然后脱离父进程，使用子进程来执行代码</p><p>将输出重定向到 &#x2F;dev&#x2F;null 里面，&#x2F;dev&#x2F;null是一个linux内置的一个设备，往里输出的话就表示，我不需要这些输出，直接丢弃</p><p>setsid 创建新会话，脱离终端，即使终端关闭了也不会断开</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">daemon_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;fork() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//退出父进程</span></span><br><span class="line">        <span class="comment">//确保守护进程脱离父进程控制，成为后台进程。</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dev/null 这是一个特殊的设备，输入进去之后，所有的东西都会被丢弃</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 守护进程的输入/输出/错误不再关联终端，避免干扰前台。</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);   <span class="comment">// 标准输入</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);  <span class="comment">// 标准输出</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);  <span class="comment">// 标准错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO)&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);    <span class="comment">// 更改工作目录到根目录</span></span><br><span class="line">    <span class="comment">// 设置文件创建时的默认权限掩码。umask(0) 表示新文件权限为 0777 &amp; ~0 = 0777（即 rwxrwxrwx）</span></span><br><span class="line">    <span class="comment">// 确保守护进程创建的文件/目录具有最大权限，由程序自行控制具体权限。</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);      <span class="comment">// 重置文件权限掩码</span></span><br><span class="line">    <span class="comment">// 创建一个新的会话（Session），并成为会话的首进程。</span></span><br><span class="line">    <span class="comment">// 确保守护进程没有控制终端（TTY），即使终端关闭，守护进程仍可运行。</span></span><br><span class="line">    <span class="built_in">setsid</span>();      <span class="comment">// 创建新会话，脱离终端控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就没啥了，就是socket的创建以及各个函数的调用，这个看代码一看就明白</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> serversd;                 <span class="comment">//全局性变量，在server_conf里面有声明 服务端套接字</span></span><br><span class="line">ThreadPool_t *pool;           <span class="comment">//全局性变量，在server_conf里面有声明 线程池</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sndaddr;   <span class="comment">//全局性变量，在server_conf里面有声明 发送目的地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">mlib_listdesc_t</span> *list; <span class="comment">//节目单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局性变量，在server_conf里面有声明 服务端的一些配置</span></span><br><span class="line"><span class="type">server_conf_t</span> server_conf =</span><br><span class="line">    &#123;</span><br><span class="line">        .media_dir  = DEFAULT_MEDIADIR,</span><br><span class="line">        .rcvport    = DEFAULT_RECVPORT,</span><br><span class="line">        .runmode    = RUN_FOREGROUND,</span><br><span class="line">        .ifname     = DEFAULT_IF,</span><br><span class="line">        .mgroup     = DEFAULT_MGROUP</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> opt[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;mgroup&quot;</span>  , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;M&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;port&quot;</span>    , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;P&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mediadir&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;D&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;runmode&quot;</span> , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;R&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ifname&quot;</span>  , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;I&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>    , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;H&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数帮助</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-M --mgroup     自定义多播组地址\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-P --port       自定义发送端口  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-D --mediadir   自定义媒体库路径\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-R --runmode    自定义运行模式  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-I --ifname     自定义网卡名称  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-H --help       显示帮助       \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">daemon_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;fork() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//退出父进程</span></span><br><span class="line">        <span class="comment">//确保守护进程脱离父进程控制，成为后台进程。</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dev/null 这是一个特殊的设备，输入进去之后，所有的东西都会被丢弃</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 守护进程的输入/输出/错误不再关联终端，避免干扰前台。</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);   <span class="comment">// 标准输入</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);  <span class="comment">// 标准输出</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);  <span class="comment">// 标准错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO)&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);    <span class="comment">// 更改工作目录到根目录</span></span><br><span class="line">    <span class="comment">// 设置文件创建时的默认权限掩码。umask(0) 表示新文件权限为 0777 &amp; ~0 = 0777（即 rwxrwxrwx）</span></span><br><span class="line">    <span class="comment">// 确保守护进程创建的文件/目录具有最大权限，由程序自行控制具体权限。</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);      <span class="comment">// 重置文件权限掩码</span></span><br><span class="line">    <span class="comment">// 创建一个新的会话（Session），并成为会话的首进程。</span></span><br><span class="line">    <span class="comment">// 确保守护进程没有控制终端（TTY），即使终端关闭，守护进程仍可运行。</span></span><br><span class="line">    <span class="built_in">setsid</span>();      <span class="comment">// 创建新会话，脱离终端控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号处理函数：清理资源并退出 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">threadpool_destroy</span>(pool);     <span class="comment">// 销毁线程池</span></span><br><span class="line">    <span class="built_in">mlib_freechnlist</span>(list);       <span class="comment">// 释放频道列表内存</span></span><br><span class="line">    <span class="built_in">mlib_freechncontext</span>();        <span class="comment">// 释放频道上下文资源</span></span><br><span class="line">    <span class="built_in">tokenbt_shutdown</span>();           <span class="comment">// 关闭令牌桶</span></span><br><span class="line">    <span class="built_in">close</span>(serversd);              <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">closelog</span>();                   <span class="comment">// 关闭系统日志</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);           <span class="comment">// 正常退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化UDP套接字 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">socket_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> mreq; <span class="comment">// 多播请求结构体</span></span><br><span class="line">    <span class="comment">/*struct ip_mreqn：用于配置多播组的参数，包含以下字段：</span></span><br><span class="line"><span class="comment">        imr_multiaddr：多播组 IP 地址。</span></span><br><span class="line"><span class="comment">        imr_address：本地接口 IP 地址。</span></span><br><span class="line"><span class="comment">        imr_ifindex：网卡接口的索引。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    serversd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serversd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;socket() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多播组参数</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_conf.mgroup, &amp;mreq.imr_multiaddr); <span class="comment">// 多播组地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;mreq.imr_address);           <span class="comment">// 本地任意地址</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(server_conf.ifname);     <span class="comment">// 网卡名称转索引</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_pton：将字符串形式的 IP 地址转换为二进制格式。</span></span><br><span class="line"><span class="comment">    server_conf.mgroup：配置中的多播组地址（如 &quot;239.0.0.1&quot;）。</span></span><br><span class="line"><span class="comment">    &quot;0.0.0.0&quot;：表示绑定到本地所有可用接口。</span></span><br><span class="line"><span class="comment">    if_nametoindex：将网卡名称（如 &quot;eth0&quot;）转换为系统索引。</span></span><br><span class="line"><span class="comment">    若网卡不存在，此函数会失败，但代码中未处理该错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 告诉内核通过指定的网卡（server_conf.ifname）发送多播数据。</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(serversd, IPPROTO_IP, IP_MULTICAST_IF, &amp;mreq, <span class="built_in">sizeof</span>(mreq));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;setsockopt() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sndaddr.sin_family = AF_INET;</span><br><span class="line">    sndaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(server_conf.rcvport));</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_conf.mgroup, &amp;sndaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">int</span> arg;</span><br><span class="line">    <span class="type">int</span> list_size;                <span class="comment">// 频道列表大小</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;      <span class="comment">// 信号处理结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开系统日志，标识为&quot;netradio&quot;，包含PID和输出到stderr</span></span><br><span class="line">    <span class="built_in">openlog</span>(<span class="string">&quot;netradio&quot;</span>, LOG_PID | LOG_PERROR, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        arg = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;M:P:D:R:I:H&quot;</span>, opt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">-1</span>) <span class="comment">//没有参数就都是默认的，不用解析</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            server_conf.mgroup = optarg; <span class="comment">// 设置多播组地址</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            server_conf.rcvport = optarg; <span class="comment">// 设置接收端口</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            server_conf.media_dir = optarg; <span class="comment">// 设置媒体目录</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            <span class="comment">// 设置运行模式（0:前台，1:守护进程）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">atoi</span>(optarg) == <span class="number">1</span> || <span class="built_in">atoi</span>(optarg) == <span class="number">0</span>) &#123;</span><br><span class="line">                server_conf.runmode = (<span class="keyword">enum</span> RNUMODE)<span class="built_in">atoi</span>(optarg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;参数错误！详见&quot;</span>);</span><br><span class="line">                <span class="built_in">print_help</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            server_conf.ifname = optarg; <span class="comment">// 设置网卡名称</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">            <span class="built_in">print_help</span>(); <span class="comment">// 显示帮助</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;参数错误！详见&quot;</span>);</span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;当前配置：\n多播组IP：\t%s\n端口：\t\t%s\n媒体库路径：\t%s\n运行模式：\t%d\n网卡名：\t%s\n&quot;</span>,</span><br><span class="line">        server_conf.mgroup,</span><br><span class="line">        server_conf.rcvport,</span><br><span class="line">        server_conf.media_dir,</span><br><span class="line">        server_conf.runmode,</span><br><span class="line">        server_conf.ifname);</span><br><span class="line">    <span class="comment">// 判断运行模式，如果是守护进程模式则初始化</span></span><br><span class="line">    <span class="keyword">if</span> (server_conf.runmode == RUN_DAEMON)  <span class="comment">// 判断系统运行模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">daemon_init</span>();</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;daemon_init() failed ...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理</span></span><br><span class="line">    action.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;action.sa_mask);    <span class="comment">// 清空信号掩码</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGINT);  <span class="comment">// Ctrl+C</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGQUIT); <span class="comment">// Ctrl+\ //</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGTSTP); <span class="comment">// Ctrl+Z</span></span><br><span class="line">    action.sa_handler = daemon_exit;      <span class="comment">// 绑定处理函数 //都是退出</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;action, <span class="literal">NULL</span>); <span class="comment">// 注册信号捕捉函数</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGQUIT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGTSTP, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化套接字</span></span><br><span class="line">    <span class="built_in">socket_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池（核心5线程，最大20线程，队列容量20）</span></span><br><span class="line">    pool = <span class="built_in">threadpool_create</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;threadpool_create() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取媒体库频道列表</span></span><br><span class="line">    ret = <span class="built_in">mlib_getchnlist</span>(&amp;list, &amp;list_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;mlib_getchnlist() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建频道列表线程</span></span><br><span class="line">    ret = <span class="built_in">thr_list_create</span>(list, list_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thr_list_create() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每个频道创建发送线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list_size; i++) &#123;</span><br><span class="line">        ret = <span class="built_in">thr_channel_create</span>(list[i].chnid);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thr_channel_create() : failed ...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环挂起，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">pause</span>();  <span class="comment">// 阻塞主线程，等待信号 这里要注意哈，为舍么要阻塞？因为ie前面发送节目单信息以及每个频道里面的信息都申请了 额外的线程来做了，这里就没必要再做了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>任务就是接收数据，两个进程，父进程进行数据的接收，输入到管道里面，然后子进程拿数据输入到ffmpeg里面来播放，就是这个流程, 基本没有啥坑</p><p>唯一需要注意的点就是如何选择自己的频道</p><p>首先要明白一点，加入到组播里面之后，client会接收所有的数据</p><p>因此需要先进行判断，首先得先拿到节目单，也就是ID为0的包。不是ID为0的包就丢弃。</p><p>然后把包里面的内容输出到终端让客户来选择那个频道，比如输入1，那么就选择1频道</p><p>后面拿到包之后先对比一下是不是1频道，是的话就拿过来，处理。不是的话就丢弃就好。</p><p>其他的就没啥的，下面是代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CLIENT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CLIENT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEFAULT_PALYERCMD &quot;/usr/bin/mplayer -&quot;     使用mpg123播放器并将输出重定向到/dev/null（静默模式）</span></span><br><span class="line"><span class="comment">// /dev/null 是一个特殊的文件，通常被称为“空设备”或“位桶”（bit bucket） </span></span><br><span class="line"><span class="comment">// 任何写入 /dev/null 的内容都会被永久丢弃，不会保存在任何地方。同时，从 /dev/null 读取内容时，总是会返回空（EOF，即文件结束符）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PALYERCMD <span class="string">&quot;/usr/bin/mpg123 - &gt; /dev/null&quot;</span> <span class="comment">//mpg123播放mp3文件，并且把一些输出给丢弃掉 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client_conf_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *mgroup;       <span class="comment">// 多播组IP地址</span></span><br><span class="line">    <span class="type">char</span> *revport;      <span class="comment">// 接收端口</span></span><br><span class="line">    <span class="type">char</span> *playercmd;    <span class="comment">// 播放器命令</span></span><br><span class="line">&#125; <span class="type">client_conf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CLIENT_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量，程序退出时释放内存。 </span></span><br><span class="line"><span class="type">msg_list_t</span> *msg_list = <span class="literal">NULL</span>;        <span class="comment">// 节目单数据缓冲区指针</span></span><br><span class="line"><span class="type">msg_channel_t</span> *msg_channel = <span class="literal">NULL</span>;  <span class="comment">// 频道数据缓冲区指针</span></span><br><span class="line"><span class="type">int</span> sfd;                            <span class="comment">// 套接字文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="type">client_conf_t</span> conf = <span class="comment">// client 配置</span></span><br><span class="line">    &#123;</span><br><span class="line">        .mgroup = DEFAULT_MGROUP,         <span class="comment">// 默认多播组地址</span></span><br><span class="line">        .revport = DEFAULT_RECVPORT,      <span class="comment">// 默认接收端口</span></span><br><span class="line">        .playercmd = DEFAULT_PALYERCMD&#125;;  <span class="comment">// 默认播放器命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数解析</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> opt[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;mgroup&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;M&#x27;</span>&#125;,       <span class="comment">// 多播组地址选项</span></span><br><span class="line">        &#123;<span class="string">&quot;port&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;P&#x27;</span>&#125;,         <span class="comment">// 接收端口选项</span></span><br><span class="line">        &#123;<span class="string">&quot;player&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,       <span class="comment">// 播放器命令选项</span></span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;H&#x27;</span>&#125;&#125;;              <span class="comment">// 帮助选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数帮助 // 打印帮助信息</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-M --mgroup 自定义多播组地址\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-P --port   自定义接收端口  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-p --player 自定义音乐解码器\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-H --help   显示帮助       \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : writen</span></span><br><span class="line"><span class="comment"> * @description: 自定义封装函数，保证写足 count 字节</span></span><br><span class="line"><span class="comment"> * @param - fd     : 文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写入的内容</span></span><br><span class="line"><span class="comment"> * @param - count : 要写入的内容总长度</span></span><br><span class="line"><span class="comment"> * @return : 成功返回写入的字节数; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len, total, ret;</span><br><span class="line">    total = count;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; total &gt; <span class="number">0</span>; len += ret, total -= ret)&#123;</span><br><span class="line">    again:</span><br><span class="line">        ret = <span class="built_in">write</span>(fd, buf + len, total);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">// 中断系统调用，重启 write</span></span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;write() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : exit_action</span></span><br><span class="line"><span class="comment"> * @description: 信号捕捉函数，用于退出前清理</span></span><br><span class="line"><span class="comment"> * @param - s     : 信号</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">exit_action</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = <span class="built_in">getpgid</span>(<span class="built_in">getpid</span>());  <span class="comment">// 获取进程组ID</span></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">if</span> (msg_list != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(msg_list);</span><br><span class="line">    <span class="keyword">if</span> (msg_channel != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(msg_channel);</span><br><span class="line">    <span class="built_in">close</span>(sfd);           <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">kill</span>(-pid, SIGQUIT);  <span class="comment">// 向进程组发送退出信号</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;\nthis programme is going to exit...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arg;       <span class="comment">// 临时存储getopt返回值</span></span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 通用返回值存储</span></span><br><span class="line">    <span class="type">int</span> len;       <span class="comment">// 接收数据长度</span></span><br><span class="line">    <span class="type">int</span> val;       <span class="comment">// 临时整数值存储</span></span><br><span class="line">    <span class="type">int</span> chosen;    <span class="comment">// 用户选择的频道ID</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];     <span class="comment">// 管道文件描述符数组</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">20</span>];   <span class="comment">// 存储IP字符串</span></span><br><span class="line">    <span class="type">pid_t</span> pid;     <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">socklen_t</span> socklen;   <span class="comment">// 套接字地址结构长度</span></span><br><span class="line">    <span class="type">uint64_t</span> receive_buf_size = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 20MB  // 接收缓冲区大小（20MB）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> group;      <span class="comment">// 多播组结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr,    <span class="comment">// 本地绑定地址</span></span><br><span class="line">                    list_addr,  <span class="comment">// 节目单来源地址</span></span><br><span class="line">                    data_addr;  <span class="comment">// 数据来源地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;    <span class="comment">// 信号处理结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;P:M:p:H&quot;</span>, opt, <span class="literal">NULL</span>); <span class="comment">// 命令行参数解析</span></span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (arg)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            conf.revport = optarg;      <span class="comment">// 设置接收端口</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            conf.mgroup = optarg;       <span class="comment">// 设置多播组地址</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            conf.playercmd = optarg;    <span class="comment">// 设置播放器命令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:                       <span class="comment">// 显示帮助</span></span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;参数错误！详见\n&quot;</span>);</span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印当前配置</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;当前配置：\n多播组IP:\t%s\n端口：\t\t%s\n播放器：\t%s\n&quot;</span>,</span><br><span class="line">            conf.mgroup, conf.revport, conf.playercmd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pipe</span>(fd); <span class="comment">// 创建匿名管道创建管道用于与播放器通信</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pipe() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork(); <span class="comment">// 创建子进程 // 创建子进程用于运行播放器</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;  <span class="comment">//创建失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fork() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  <span class="comment">//子进程负责将父进程读取到的数据通过管道馈入到ffmpeg里面播放</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);                 <span class="comment">// 关闭写端（子进程只读）</span></span><br><span class="line">        <span class="built_in">dup2</span>(fd[<span class="number">0</span>], STDIN_FILENO);    <span class="comment">// 将管道读端重定向到标准输入</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);                 <span class="comment">// 关闭原始读端</span></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, conf.playercmd, <span class="literal">NULL</span>); <span class="comment">// 使用shell解释器来运行 mpg123，子进程被替换成mpg123</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;execl() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">//父进程不需要读管道</span></span><br><span class="line">    <span class="comment">// 配置信号处理结构体</span></span><br><span class="line">    action.sa_flags = <span class="number">0</span>;                   <span class="comment">// 不使用特殊标志</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;action.sa_mask);          <span class="comment">// 清空信号屏蔽字</span></span><br><span class="line">    <span class="comment">// 添加要阻塞的信号（处理期间屏蔽这些信号）</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGINT);    <span class="comment">// Ctrl+C</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGQUIT);   <span class="comment">// Ctrl+\ //</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGTSTP);   <span class="comment">// Ctrl+Z</span></span><br><span class="line">    action.sa_handler = exit_action;       <span class="comment">// 设置统一信号处理函数</span></span><br><span class="line">    <span class="comment">// 注册信号处理器</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;action, <span class="literal">NULL</span>);   <span class="comment">// 注册Ctrl+C处理</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGQUIT, &amp;action, <span class="literal">NULL</span>);  <span class="comment">// 注册退出处理</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGTSTP, &amp;action, <span class="literal">NULL</span>);  <span class="comment">// 注册暂停处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置绑定地址结构</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(conf.revport));</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    ret = <span class="built_in">bind</span>(sfd, (<span class="type">void</span> *)&amp;addr, <span class="built_in">sizeof</span>(addr)); <span class="comment">// 绑定本地 IP ，端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;bind() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接收缓冲区大小</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, SOL_SOCKET, SO_RCVBUF, &amp;receive_buf_size, <span class="built_in">sizeof</span>(receive_buf_size)); <span class="comment">// 设置套接字接收缓冲区 20 MB</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SO_RCVBUF : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许组播数据回环（本机接收自己发送的数据）</span></span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;(val), <span class="built_in">sizeof</span>(val)); <span class="comment">// 允许组播数据包本地回环</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;IP_MULTICAST_LOOP : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置多播组参数</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, conf.mgroup, &amp;group.imr_multiaddr);       <span class="comment">// 多播组地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);           <span class="comment">// 本地接口地址</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);                                 <span class="comment">// 绑定自己的网卡</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="built_in">sizeof</span>(group)); <span class="comment">// 加入多播组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;IP_ADD_MEMBERSHIP() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配节目单数据缓冲区</span></span><br><span class="line">    msg_list = <span class="built_in">malloc</span>(MAX_LISTCHN_DATA);</span><br><span class="line">    <span class="keyword">if</span> (msg_list == <span class="literal">NULL</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    socklen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_list, <span class="number">0</span>, MAX_LISTCHN_DATA);    <span class="comment">// 清空缓冲区</span></span><br><span class="line">        len = <span class="built_in">recvfrom</span>(sfd, msg_list, MAX_LISTCHN_DATA, <span class="number">0</span>, (<span class="type">void</span> *)&amp;list_addr, &amp;socklen); <span class="comment">// 接收节目单包</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">sizeof</span>(<span class="type">msg_list_t</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is too short, len = %d...\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 检查是否为节目单数据（根据预设的LISTCHNID判断）</span></span><br><span class="line">        <span class="keyword">if</span> (msg_list-&gt;chnid == LISTCHNID) <span class="comment">// 如果是节目单包则保留，不是则丢弃</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;list from IP = %s, Port = %d\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;list_addr.sin_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">                    <span class="built_in">ntohs</span>(list_addr.sin_port));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并打印节目单信息</span></span><br><span class="line">    <span class="type">msg_listdesc_t</span> *desc;</span><br><span class="line">    <span class="keyword">for</span> (desc = msg_list-&gt;list; (<span class="type">char</span> *)desc &lt; (<span class="type">char</span> *)msg_list + len; desc = (<span class="type">void</span> *)((<span class="type">char</span> *)desc + <span class="built_in">ntohs</span>(desc-&gt;deslength)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;chnid = %d, description = %s\n&quot;</span>, desc-&gt;chnid, desc-&gt;desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(msg_list); <span class="comment">// 释放节目单缓冲区</span></span><br><span class="line">    msg_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户选择频道</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;请输入收听的频道号码，按回车结束！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fflush</span>(<span class="literal">NULL</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;chosen);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配频道数据缓冲区</span></span><br><span class="line">    msg_channel = <span class="built_in">malloc</span>(MAX_CHANNEL_DATA);</span><br><span class="line">    <span class="keyword">if</span> (msg_channel == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续接收数据</span></span><br><span class="line">    socklen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_channel, <span class="number">0</span>, MAX_CHANNEL_DATA);     <span class="comment">// 清空缓冲区</span></span><br><span class="line">        len = <span class="built_in">recvfrom</span>(sfd, msg_channel, MAX_CHANNEL_DATA, <span class="number">0</span>, (<span class="type">void</span> *)&amp;data_addr, &amp;socklen); <span class="comment">// 接收频道内容包</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">sizeof</span>(<span class="type">msg_channel_t</span>))&#123; <span class="comment">// UDP不是面向字节流的，接收的话就是一个包</span></span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is too short, len = %d...\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data_addr.sin_addr.s_addr != list_addr.sin_addr.s_addr || data_addr.sin_port != list_addr.sin_port)&#123;</span><br><span class="line">        <span class="comment">// 验证数据包和节目单数据包是否为同一服务端发送，防止干扰</span></span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is not match!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg_channel-&gt;chnid == chosen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;recv %d length data!\n&quot;</span>, len);</span><br><span class="line">            ret = <span class="built_in">writen</span>(fd[<span class="number">1</span>], msg_channel-&gt;data, len - <span class="built_in">sizeof</span>(msg_channel-&gt;chnid)); <span class="comment">// 写入管道</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉比webserver还要简单一些，就是这个里面的结构体各种定义很容易迷，这就是不如C++ class封装之处了。整体来看还是很值的做的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg</title>
      <link href="/2025/04/17/ffmpeg/"/>
      <url>/2025/04/17/ffmpeg/</url>
      
        <content type="html"><![CDATA[<h1 id="C-FFMPEG-项目"><a href="#C-FFMPEG-项目" class="headerlink" title="C++ FFMPEG 项目"></a>C++ FFMPEG 项目</h1><p>这个项目主要是为了学习FFMPEG</p><p>完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放</p><p>这里做了一些简化操作</p><p>完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件</p><p>整体的框架是这样的：</p><p><img src="/../0_images/ffmpeg/day3-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="alt text"></p><h1 id="FFMPEG介绍"><a href="#FFMPEG介绍" class="headerlink" title="FFMPEG介绍"></a>FFMPEG介绍</h1><p>对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++ FFMPEG的一些API</p><p>我们先来介绍一下一般FFMPEG的一些整体的流程，如下图所示：</p><p><img src="/../0_images/ffmpeg/day4_FFMPEG.png" alt="alt text"></p><h2 id="基本流程介绍"><a href="#基本流程介绍" class="headerlink" title="基本流程介绍"></a>基本流程介绍</h2><p>我们一般拿到一个音视频文件，首先需要对其进行拆分，得到音频和视频对应的包。</p><p>这里要注意，我们平时所接触到的视频都是以某一种封装格式封装压缩好的一些比如（视频H264,音频AAC等），所以我们得到的音频和视频对应的包都是编码之后的。</p><p>因此后面我们需要对其进行解码，然后得到相应的结果解码之后的视频帧(YUV数据)与音频帧（PCM数据）。</p><p>在这里我们就可以对原始的视频数据和音频数据进行处理了，比如加一些滤镜等操作。</p><p>后面我们将处理之后的原始数据再重新编码，在得到编码之后的视频包和音频包</p><p>最后我们可以把音视频包组合在一起，输出为最后的音视频文件。</p><p>所以使用C++调用FFMPEG API的时候一般都会有一些基本流程的</p><h2 id="基本API介绍"><a href="#基本API介绍" class="headerlink" title="基本API介绍"></a>基本API介绍</h2><h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1.打开文件"></a>1.打开文件</h3><h4 id="涉及到的结构："><a href="#涉及到的结构：" class="headerlink" title="涉及到的结构："></a>涉及到的结构：</h4><p><strong>AVFormatContext</strong></p><p>这个是管理媒体文件格式（容器格式）的核心结构体</p><p>下面是精简版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFormatContext</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *av_class;          <span class="comment">// FFmpeg内部使用的类信息</span></span><br><span class="line">    AVInputFormat *iformat;           <span class="comment">// 输入格式（如MP4、FLV等）</span></span><br><span class="line">    AVOutputFormat *oformat;          <span class="comment">// 输出格式（用于写入文件）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键成员</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nb_streams;          <span class="comment">// 流的数量（视频/音频/字幕等）</span></span><br><span class="line">    AVStream **streams;               <span class="comment">// 流数组指针（核心！）</span></span><br><span class="line">    <span class="type">int64_t</span> duration;                <span class="comment">// 媒体时长（微秒）</span></span><br><span class="line">    <span class="type">int64_t</span> bit_rate;                <span class="comment">// 全局比特率（bps）</span></span><br><span class="line">    AVDictionary *metadata;          <span class="comment">// 元数据（作者、标题等）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">    </span><br><span class="line">&#125; AVFormatContext;</span><br></pre></td></tr></table></figure><p>这个里面存储的数据信息有很多，上面只是列出一些基本的信息</p><p>有两个比较重要的值是：unsigned int nb_streams; 与 AVStream **streams; </p><ul><li>unsigned int nb_streams 存储的是流的数量</li><li>AVStream **streams用来存储流的数组，里面有很多流。比如视频流[AVStream1]，音频流[AVStream2]，字幕流[AVStream3]</li></ul><p>我们来介绍一下 AVStream 流 </p><p>流里面存储的一些视频与音频等的元数据，比如编码器参数AVCodecParameters等</p><p>我们来看一下 AVStream 一些基本结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVStream</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;  <span class="comment">// 流的索引号</span></span><br><span class="line">    AVCodecParameters *codecpar; <span class="comment">// 编解码参数</span></span><br><span class="line">    AVRational time_base; <span class="comment">// 时间基(time base)</span></span><br><span class="line">    AVRational avg_frame_rate; <span class="comment">// 平均帧率(视频流)</span></span><br><span class="line">    AVDictionary *metadata; <span class="comment">// 元数据</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他的就不多介绍了，主要是index和codecpar比较重要</p><ul><li>index是流的索引，也就是AVStream **streams 数组对应的下标</li><li>AVCodecParameters 是编码器参数，主要标注一些视频或者音频等的信息，下面来看一下基本结构</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecParameters</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type; <span class="comment">// 流类型(视频/音频/字幕等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span>   codec_id;   <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 视频相关</span></span><br><span class="line">    <span class="type">int</span> width, height;          <span class="comment">// 视频宽高</span></span><br><span class="line">    <span class="comment">// 音频相关</span></span><br><span class="line">    <span class="type">int</span> sample_rate;            <span class="comment">// 采样率</span></span><br><span class="line">    <span class="type">int</span> channels;               <span class="comment">// 声道数</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;    <span class="comment">// 声道布局</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么问题来了，流里面存储的是元数据或者是信息数据，那么视频包音频包存在那里，怎么区分这是视频包还是音频包？</p><p>首先视频包和音频包肯定不是存在流里面的，这样的话流就太大了。视频包和音频包还是存储在文件里面，只不过包里面有一个 stream_index 用来指示对应的那一个流（流里面的index），这样的话就可以区分视频包和音频包或者其他包了。（AVPacket咱们后面介绍）</p><p>这样抛析来讲是不是就理解AVFormatContext了</p><h4 id="涉及到的API"><a href="#涉及到的API" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_open_input</strong></p><p>原型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param ps   指向AVFormatContext指针的指针</span></span><br><span class="line"><span class="comment"> *  @param url  输入媒体文件的路径或URL（如文件路径、网络流地址等）。</span></span><br><span class="line"><span class="comment"> *  @param fmt  指定的输入格式（AVInputFormat）。若为NULL，则自动检测文件格式；</span></span><br><span class="line"><span class="comment"> *  @param options   额外选项的字典（如协议参数、解封装器选项等）</span></span><br><span class="line"><span class="comment"> *  @return 成功返回0，失败返回负的错误码（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="type">const</span> <span class="type">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>这个就是用来打开文件的，具体怎么做的就不多介绍了（我没看源码），咱们先知道其作用就好</p><p>一般在使用的时候都会把后面两个参数设成NULL除非有特殊的需求</p><p>比如在这个项目里面：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开输入文件</span></span><br><span class="line"><span class="type">int</span> openResult = <span class="built_in">avformat_open_input</span>(&amp;formatCtx,filePath,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (openResult!=<span class="number">0</span>) &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;不可以打开视频文件&quot;</span>&lt;&lt;filePath&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取流信息"><a href="#2-获取流信息" class="headerlink" title="2.获取流信息"></a>2.获取流信息</h3><h4 id="涉及到的API-1"><a href="#涉及到的API-1" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_find_stream_info</strong></p><p>这个函数主要是为了确定文件的流信息的完整性</p><p>在调用 avformat_open_input 后，文件的流信息可能不完整，此时调用avformat_find_stream_info 可以获取更完整的流信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param ic      指向AVFormatContext的指针，表示已经打开的媒体文件上下文。</span></span><br><span class="line"><span class="comment"> * @param options 额外选项的字典，用于为每个流的解码器传递选项。</span></span><br><span class="line"><span class="comment"> * @return 成功返回非负值，表示获取到的流信息的数量；失败返回负的错误码（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>说一下咱们一般会怎么用：</p><p>在打开文件之后，调用这个确保流信息完整，然后在遍历整个 AVStream 数组得到视频流和音频流的index</p><p>(这里就单处理音视频哈，其他的字幕流啥的就不处理了)</p><p>通过上面对流的介绍，那么就很容易写代码了，咱们来看一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vsIndex,asIndex;</span><br><span class="line">vsIndex = asIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 获取流信息</span></span><br><span class="line"><span class="type">int</span> findStreaResuly = <span class="built_in">avformat_find_stream_info</span>(formatCtx,<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span>(findStreaResuly&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到流信息&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找视频流   AVMEDIA_TYPE_VIDEO 为视频流 AVMEDIA_TYPE_AUDIO 音频流</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;formatCtx-&gt;nb_streams;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        vsIndex = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vsIndex==<span class="number">-1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到视频流&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找音频流   AVMEDIA_TYPE_VIDEO 为视频流 AVMEDIA_TYPE_AUDIO 音频流</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;formatCtx-&gt;nb_streams;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        asIndex = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asIndex==<span class="number">-1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到音频流&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-拆分视频包与音频包"><a href="#3-拆分视频包与音频包" class="headerlink" title="3.拆分视频包与音频包"></a>3.拆分视频包与音频包</h3><h4 id="涉及到的结构"><a href="#涉及到的结构" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVPacket</strong></p><p>用于存储压缩后的媒体数据（如 H.264 视频帧、AAC 音频帧等）的结构体</p><p>这个是GPT生成的，不一定对，还是要看源码的哈。这里咱们主要讲主要的东西</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPacket</span> &#123;</span><br><span class="line">    <span class="comment">// 数据缓冲区（存储压缩后的数据，如 H.264 NAL 单元、AAC 帧等）</span></span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">    <span class="type">int</span>      size;          <span class="comment">// 数据大小（字节数）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所属的流索引（对应 AVFormatContext-&gt;streams 的下标）</span></span><br><span class="line">    <span class="type">int</span>      stream_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳（单位：流的时间基 time_base）</span></span><br><span class="line">    <span class="type">int64_t</span>  pts;           <span class="comment">// 显示时间戳（Presentation TimeStamp）</span></span><br><span class="line">    <span class="type">int64_t</span>  dts;           <span class="comment">// 解码时间戳（Decoding TimeStamp）</span></span><br><span class="line">    <span class="type">int</span>      duration;      <span class="comment">// 持续时间（单位：time_base）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位置信息（用于字节流或文件定位）</span></span><br><span class="line">    <span class="type">int64_t</span>  pos;           <span class="comment">// 数据在文件中的偏移量（字节）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位（如关键帧、损坏数据等）</span></span><br><span class="line">    <span class="type">int</span>      flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_PKT_FLAG_KEY     0x0001  <span class="comment">// 关键帧（I帧）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_PKT_FLAG_CORRUPT 0x0002  <span class="comment">// 数据可能损坏</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加数据（如 SEI、编解码器私有数据）</span></span><br><span class="line">    <span class="type">uint8_t</span> *side_data;     <span class="comment">// 额外数据（如 H.264 SEI）</span></span><br><span class="line">    <span class="type">int</span>      side_data_elems; <span class="comment">// 附加数据数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数（用于内存管理）</span></span><br><span class="line">    AVPacketSideData *side_data; <span class="comment">// 更详细的附加数据</span></span><br><span class="line">    <span class="type">int</span>      side_data_elems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配信息</span></span><br><span class="line">    <span class="type">void</span>    *opaque;        <span class="comment">// 私有数据，由 FFmpeg 内部使用</span></span><br><span class="line">    <span class="built_in">void</span>    (*destruct)(<span class="keyword">struct</span> AVPacket *); <span class="comment">// 释放数据的回调函数</span></span><br><span class="line">    <span class="type">void</span>    *priv;          <span class="comment">// 内部使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间基（通常由流决定，但可能被修改）</span></span><br><span class="line">    AVRational time_base;   <span class="comment">// 时间基（pts/dts 的单位）</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>主要的东西</p><ul><li>缓冲区数据, 这个理解一下，就是包里面的数据<ul><li>uint8_t *data;</li><li>int      size;          &#x2F;&#x2F; 数据大小（字节数）</li></ul></li><li>流索引 int stream_index;<ul><li>这个就是咱们之前说的，指向对应类型的包的索引，这个很重要，可以区分这个包属于什么流（音频流视频流）</li></ul></li></ul><h4 id="涉及到的API-2"><a href="#涉及到的API-2" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>av_packet_alloc</strong></p><p>一般咱们获取包都是使用从音视频文件之中解析下来的，但是解析下来的时候咱们总得有个空的来接收把。</p><p>因此就需要申请一个空的AVPacket，这个函数就是用来干这件事的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVPacket 并初始化其字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVPacket 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>av_read_frame</strong></p><p>这个函数是用来读取包的，这个我觉得有点变态了，读包的函数名字是读帧，当时我还搞混了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从媒体文件中读取下一个数据包，并将其存储到提供的AVPacket中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s    指向AVFormatContext的指针，表示已经打开的媒体文件上下文。</span></span><br><span class="line"><span class="comment"> * @param pkt  指向AVPacket的指针，用于存储读取到的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回0，表示成功读取了一个数据包。</span></span><br><span class="line"><span class="comment"> *  - 如果已到达文件末尾或没有更多数据包可读，返回AVERROR_EOF。</span></span><br><span class="line"><span class="comment"> *  - 其他负的错误码表示读取过程中发生错误（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>av_packet_ref</strong></p><p>复制包的函数，很好理解</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 AVPacket 的内容复制到另一个 AVPacket 中，并增加引用计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dst 目标 AVPacket，即要复制到的 AVPacket。</span></span><br><span class="line"><span class="comment"> * 在调用此函数之前，dst 应该已经通过 av_packet_alloc 或其他方式分配好内存。</span></span><br><span class="line"><span class="comment"> * @param src 源 AVPacket，即要从中复制内容的 AVPacket。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_packet_ref</span><span class="params">(AVPacket *dst, <span class="type">const</span> AVPacket *src)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>av_packet_unref</strong></p><p>注意哈，咱们调用av_read_frame之后获取一个包，做了处理之后，要清空一下包里面的东西，以便于下一次再存储新的包，这个函数就是这么用的，就是清空包</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 AVPacket 中的内容，并将其字段重置为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要释放内容的 AVPacket。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_unref</span><span class="params">(AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>av_packet_free</strong></p><p>同理，最后咱们用完了这个临时的包，后面不需要再用了，就得释放掉咱们申请的空间，于是就有了av_packet_free</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放整个 AVPacket 对象及其内部资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 指针的指针，表示要释放的 AVPacket 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>那么到这里咱们来看一下拆分整个包的过程(这个项目是使用一个线程来进行操作的，所以会涉及到一些线程的操作，大家看一看，能理解就好)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配包</span></span><br><span class="line">AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"><span class="comment">//一直读包</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(formatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;stream_index == vsIndex) &#123;        <span class="comment">// 处理视频包</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(videoMtx)</span></span>;         <span class="comment">//上锁</span></span><br><span class="line">        AVPacket* videoPkt = <span class="built_in">av_packet_alloc</span>();   <span class="comment">//这里要注意，packet一直在被使用，不能直接push，否则会和解析的线程抢占这个packet</span></span><br><span class="line">        <span class="built_in">av_packet_ref</span>(videoPkt, packet);          <span class="comment">//复制一份再push进去</span></span><br><span class="line">        videoPacketQueue.<span class="built_in">push</span>(videoPkt);          <span class="comment">//push</span></span><br><span class="line">        videoCV.<span class="built_in">notify_one</span>();                     <span class="comment">//唤醒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;stream_index == asIndex) &#123; <span class="comment">// 处理音频包</span></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">lock</span>(audioMtx);         <span class="comment">//上锁</span></span><br><span class="line">        AVPacket* audioPkt = <span class="built_in">av_packet_alloc</span>();   <span class="comment">//这里要注意，packet一直在被使用，不能直接push，否则会和解析的线程抢占这个packet</span></span><br><span class="line">        <span class="built_in">av_packet_ref</span>(audioPkt, packet);          <span class="comment">//复制一份再push进去</span></span><br><span class="line">        audioPacketQueue.<span class="built_in">push</span>(audioPkt);          <span class="comment">//push</span></span><br><span class="line">        audioCV.<span class="built_in">notify_one</span>();                     <span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(packet); <span class="comment">//释放当前包的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;packet);     <span class="comment">//循环结束后释放packet</span></span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;packet);     <span class="comment">//循环结束后释放packet</span></span><br><span class="line">doneVideoReading = <span class="literal">true</span>;     <span class="comment">//视频读完了</span></span><br><span class="line">videoCV.<span class="built_in">notify_all</span>();        <span class="comment">//唤醒</span></span><br><span class="line">doneAudioReading = <span class="literal">true</span>;     <span class="comment">//音频读完了</span></span><br><span class="line">audioCV.<span class="built_in">notify_all</span>();        <span class="comment">//唤醒</span></span><br></pre></td></tr></table></figure><p>这里留个小问题哈，为啥要复制一下包av_packet_ref</p><h3 id="4-解码包"><a href="#4-解码包" class="headerlink" title="4.解码包"></a>4.解码包</h3><p>这里要注意哈，咱们得到的包是编码之后的结果，到这里才是解码的过程</p><p>这里以视频为例哈，音频是同样的操作</p><h4 id="涉及到的结构-1"><a href="#涉及到的结构-1" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVCodecParameters</strong></p><p>既然要解码，咱们就得获取一下<strong>编解码器</strong>的参数，获取参数之后才能做解码操作</p><p>这个咱们前面在介绍流的时候已经做了介绍，现在再拿下来说一下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecParameters</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type; <span class="comment">// 流类型(视频/音频/字幕等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span>   codec_id;   <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 视频相关</span></span><br><span class="line">    <span class="type">int</span> width, height;          <span class="comment">// 视频宽高</span></span><br><span class="line">    <span class="comment">// 音频相关</span></span><br><span class="line">    <span class="type">int</span> sample_rate;            <span class="comment">// 采样率</span></span><br><span class="line">    <span class="type">int</span> channels;               <span class="comment">// 声道数</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;    <span class="comment">// 声道布局</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里要特别注意哈，这里是一个结构体，里面存储的是<strong>编解码器</strong>的参数，不是所谓的<strong>编解码器</strong></p><p>注意这里比较重要的是 enum AVCodecID   codec_id;   &#x2F;&#x2F; <strong>编解码器</strong>ID</p><p>它是<strong>编解码器</strong>对应的id，我们点进去可以看到，这是一个枚举类型的数据，里面有好多比那解码器的类型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AVCodecID</span> &#123;</span><br><span class="line">    AV_CODEC_ID_NONE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* video codecs */</span></span><br><span class="line">    AV_CODEC_ID_MPEG1VIDEO,</span><br><span class="line">    AV_CODEC_ID_MPEG2VIDEO, <span class="comment">///&lt; preferred ID for MPEG-1/2 video decoding</span></span><br><span class="line">    AV_CODEC_ID_H261,</span><br><span class="line">    AV_CODEC_ID_H263,</span><br><span class="line">    <span class="comment">//其他....</span></span><br><span class="line">    <span class="comment">/* various PCM &quot;codecs&quot; */</span></span><br><span class="line">    AV_CODEC_ID_FIRST_AUDIO = <span class="number">0x10000</span>,     <span class="comment">///&lt; A dummy id pointing at the start of audio codecs</span></span><br><span class="line">    AV_CODEC_ID_PCM_S16LE = <span class="number">0x10000</span>,</span><br><span class="line">    AV_CODEC_ID_PCM_S16BE,</span><br><span class="line">    AV_CODEC_ID_PCM_U16LE,</span><br><span class="line">    <span class="comment">//其他....</span></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">/*其他*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AVCodec</strong></p><p>这个才是相应的<strong>编解码器</strong>，为什么我老是加粗这个<strong>编解码器</strong>，因为AVCodec这个结构既可以表示编码器又可以表示解码器！！！这里一定要注意，非常非常容易搞混乱</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodec</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;          <span class="comment">// 编解码器的简短名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *long_name;     <span class="comment">// 编解码器的描述性名称</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type;     <span class="comment">// 媒体类型(AVMEDIA_TYPE_VIDEO/AVMEDIA_TYPE_AUDIO等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id;         <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="type">const</span> AVRational *supported_framerates; <span class="comment">// 支持的帧率(视频)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> *pix_fmts;     <span class="comment">// 支持的像素格式(视频)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *supported_samplerates;       <span class="comment">// 支持的采样率(音频)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> *sample_fmts; <span class="comment">// 支持的采样格式(音频)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> *channel_layouts;        <span class="comment">// 支持的声道布局(音频)</span></span><br><span class="line">    <span class="type">int</span> priv_data_size;        <span class="comment">// 私有数据大小</span></span><br><span class="line">    <span class="comment">// 各种函数指针(init, encode, decode, close等)</span></span><br><span class="line">&#125; AVCodec;</span><br></pre></td></tr></table></figure><p>上面是一些常规的内容，区分编码器与解码器主要靠着下面两个：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encode data to an AVPacket.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param      avctx          codec context</span></span><br><span class="line"><span class="comment"> * @param      avpkt          output AVPacket</span></span><br><span class="line"><span class="comment"> * @param[in]  frame          AVFrame containing the raw data to be encoded</span></span><br><span class="line"><span class="comment"> * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a</span></span><br><span class="line"><span class="comment"> *                            non-empty packet was returned in avpkt.</span></span><br><span class="line"><span class="comment"> * @return 0 on success, negative error code on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">int</span> (*encode2)(<span class="keyword">struct</span> AVCodecContext *avctx, <span class="keyword">struct</span> AVPacket *avpkt,</span><br><span class="line">                   <span class="type">const</span> <span class="keyword">struct</span> AVFrame *frame, <span class="type">int</span> *got_packet_ptr);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decode picture or subtitle data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param      avctx          codec context</span></span><br><span class="line"><span class="comment"> * @param      outdata        codec type dependent output struct</span></span><br><span class="line"><span class="comment"> * @param[out] got_frame_ptr  decoder sets to 0 or 1 to indicate that a</span></span><br><span class="line"><span class="comment"> *                            non-empty frame or subtitle was returned in</span></span><br><span class="line"><span class="comment"> *                            outdata.</span></span><br><span class="line"><span class="comment"> * @param[in]  avpkt          AVPacket containing the data to be decoded</span></span><br><span class="line"><span class="comment"> * @return amount of bytes read from the packet on success, negative error</span></span><br><span class="line"><span class="comment"> *         code on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">int</span> (*decode)(<span class="keyword">struct</span> AVCodecContext *avctx, <span class="type">void</span> *outdata,</span><br><span class="line">                  <span class="type">int</span> *got_frame_ptr, <span class="keyword">struct</span> AVPacket *avpkt);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (codec-&gt;encode2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是一个编码器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (codec-&gt;decode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是一个解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意哈，这里只是简单的区分，其实在用的时候总得初始化吧，初始化的时候会针对编码器和解码器会调用不同的函数来做</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找解码器</span></span><br><span class="line">AVCodec *decoder = <span class="built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);</span><br><span class="line"><span class="comment">// 查找编码器</span></span><br><span class="line">AVCodec *encoder = <span class="built_in">avcodec_find_encoder</span>(AV_CODEC_ID_H264);</span><br></pre></td></tr></table></figure><p><strong>AVCodecContext</strong></p><p>AVCodec是<strong>编解码器</strong> 那么这个AVCodecContext就是*<em>编解码器的上下文</em></p><p>这是<strong>编解码器</strong>的上下文，保存了编解码过程中的所有状态信息：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecContext</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type;  <span class="comment">// 编解码器类型</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVCodec</span> *codec;  <span class="comment">// 使用的AVCodec</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> codec_id;      <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 各种编解码参数...</span></span><br><span class="line">    <span class="type">int</span> bit_rate;                 <span class="comment">// 比特率</span></span><br><span class="line">    <span class="type">int</span> width, height;            <span class="comment">// 图像尺寸(视频)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> pix_fmt;   <span class="comment">// 像素格式(视频)</span></span><br><span class="line">    <span class="type">int</span> sample_rate;              <span class="comment">// 采样率(音频)</span></span><br><span class="line">    <span class="type">int</span> channels;                 <span class="comment">// 声道数(音频)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> sample_fmt; <span class="comment">// 采样格式(音频)</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;      <span class="comment">// 声道布局(音频)</span></span><br><span class="line">    <span class="comment">// 更多字段...</span></span><br><span class="line">&#125; AVCodecContext;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意区分一下AVCodec与AVCodecContext哈，咱们来对比一下</p><p>你看上面的AVCodec的结构，一般里面是不是有很多的指针也就是数组的类型，这里表示这个<strong>编解码器</strong>锁支持的，举个简单的例子，比如对于与编码格式 支持 [A,B,C,D…G]编码格式</p><p>VCodecContext里面一般都是非常具体的值，比如还用那个例子，编码格式所对应的状态是<strong>A</strong> 具体的A</p><p>因此，咱们在后面进行编解码操作的时候使用的都是VCodecContext</p><p><strong>AVFrame</strong></p><p>咱们已经介绍了AVPacket，也就是咱们上一步所获取的压缩状态的数据包，那么AVFrame就是解码之后的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFrame</span> &#123;</span><br><span class="line">    <span class="comment">// 数据存储（核心字段）</span></span><br><span class="line">    <span class="type">uint8_t</span> *data[AV_NUM_DATA_POINTERS];      <span class="comment">// 数据指针数组（多平面存储）</span></span><br><span class="line">    <span class="type">int</span> linesize[AV_NUM_DATA_POINTERS];       <span class="comment">// 每个平面的行字节数（含对齐填充）</span></span><br><span class="line">    <span class="type">int</span> width, height;                        <span class="comment">// 视频帧尺寸</span></span><br><span class="line">    <span class="type">int</span> nb_samples;                           <span class="comment">// 音频样本数</span></span><br><span class="line">    <span class="type">int</span> format;                               <span class="comment">// 格式标识（对应 AVPixelFormat 或 AVSampleFormat）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间信息</span></span><br><span class="line">    <span class="type">int64_t</span> pts;                              <span class="comment">// 显示时间戳</span></span><br><span class="line">    <span class="type">int64_t</span> duration;                         <span class="comment">// 帧持续时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];   <span class="comment">// 数据缓冲引用</span></span><br><span class="line">    AVBufferRef *hw_frames_ctx;               <span class="comment">// 硬件加速上下文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元数据</span></span><br><span class="line">    AVDictionary *metadata;                   <span class="comment">// 附加信息字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他字段（色彩空间、音频声道布局等）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure><p>这里咱们就先知道AVFrame就是解码之后的数据就好了，里面涉及到一些平面存储的概念这个感兴趣的可以取搜索一下学习学习</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：分辨率为 1280x720 的 YUV420P 视频帧 (可以想一想，这个存储会压缩多少)</span></span><br><span class="line"><span class="comment">// 原来是1280x720 现在是1280 + 640 + 640 </span></span><br><span class="line">linesize[<span class="number">0</span>] = <span class="number">1280</span>;  <span class="comment">// Y平面每行字节数</span></span><br><span class="line">linesize[<span class="number">1</span>] = <span class="number">640</span>;   <span class="comment">// U平面每行字节数（宽度减半）</span></span><br><span class="line">linesize[<span class="number">2</span>] = <span class="number">640</span>;   <span class="comment">// V平面每行字节数</span></span><br></pre></td></tr></table></figure><h4 id="涉及到的API-3"><a href="#涉及到的API-3" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p>首先要获取<strong>编解码器</strong>的参数吧（这里不涉及API哈，别激动）就是从咱们刚得到的流中拿哈</p><p>这里以视频为例哈</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取视频流的编解码器参数</span></span><br><span class="line">videoCodecParams = formatCtx-&gt;streams[vsIndex]-&gt;codecpar;</span><br><span class="line"><span class="keyword">if</span> (!videoCodecParams) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法获取解码器参数-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm就这么简单，哈哈哈哈</p><p><strong>avcodec_find_decoder</strong></p><p>那么获取之后就要创建一个<strong>编解码器</strong>了，也就是一个 AVCodec 这里主要是解码，所以用decoder</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据编解码器ID查找解码器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param id 编解码器ID，是一个枚举值，例如 AV_CODEC_ID_H264 表示 H.264 编解码器。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回指向找到的解码器的 AVCodec 结构体指针。</span></span><br><span class="line"><span class="comment"> *  - 如果未找到匹配的解码器，返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure><p>avcodec_find_decoder 只是创建的一种哈，还有很多其他的函数比如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>那么这里咱们再和之前获取的videoCodecParams结合再一起，那就是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodec* videoCodec = <span class="built_in">avcodec_find_decoder</span>(videoCodecParams-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (!videoCodec) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法识别解码器-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得回想一下videoCodecParams-&gt;codec_id是什么，上面介绍了</p><p><strong>avcodec_alloc_context3</strong></p><p>那么创建完了之后就需要 创建AVCodecContext 保存咱们上面所创建的<strong>解码器</strong>（这里不是编解码器了哈，上面调用的是avcodec_find_decoder，创建的是解码器）上下文了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVCodecContext，并将其初始化为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param codec 指向 AVCodec 的指针，表示要使用的编解码器。如果为 NULL，则分配一个未绑定编解码器的 AVCodecContext。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVCodecContext 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodecContext* videoCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(videoCodec);</span><br></pre></td></tr></table></figure><p><strong>avcodec_parameters_to_context</strong></p><p>注意哈，上面创建只是创建一个空壳子，意味着videoCodecCtx可以保存videoCodec的状态，这里就需要给他赋值了，那么想到状态是不是就想到了之前提到的AVCodecParameters </p><p>没错，看看下面的函数原型</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AVCodecParameters 中的参数复制到 AVCodecContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param codec_ctx 目标 AVCodecContext，即要将参数复制到的解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param codec_par 源 AVCodecParameters，即要从中复制参数的结构体。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec_ctx, <span class="type">const</span> AVCodecParameters *codec_par)</span></span>;</span><br></pre></td></tr></table></figure><p>所以咱们就这么使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P2CResultVi = <span class="built_in">avcodec_parameters_to_context</span>(videoCodecCtx, videoCodecParams);</span><br><span class="line"><span class="keyword">if</span> (P2CResultVi&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法将解码器参数复制到解码器上下文之中-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>avcodec_open2</strong></p><p>OK,到这里就把所有的东西都初始化好了，最后一步就是打开解码器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开一个编解码器，并将其与指定的 AVCodecContext 绑定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示要绑定的编解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param codec 指向 AVCodec 的指针，表示要使用的编解码器。</span></span><br><span class="line"><span class="comment"> * @param options 指向 AVDictionary 的指针，表示编解码器的选项。如果为 NULL，则不传递任何选项。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> openAvcodecResultVi = <span class="built_in">avcodec_open2</span>(videoCodecCtx, videoCodec, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (openAvcodecResultVi&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法打开解码器-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>av_frame_alloc</strong></p><p>仿照之前的av_packet_alloc，这里就不过多介绍了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVFrame，并将其初始化为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVFrame 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>同样的还有 <strong>av_frame_unref</strong> 与 <strong>av_frame_free</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 AVFrame 中的引用，并将其重置为初始状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，表示要释放引用的 AVFrame。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_unref</span><span class="params">(AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放整个 AVFrame 对象及其内部资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 指针的指针，表示要释放的 AVFrame 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br></pre></td></tr></table></figure><p>OK,下面是两个非常关键的函数</p><p><strong>avcodec_send_packet</strong></p><p>第一个是 把文件packet放进解码器里面解码,然后解码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供原始数据包数据作为解码器的输入。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param avpkt 指向 AVPacket 的指针，表示要解码的数据包。通常是一个视频帧或多个音频帧。</span></span><br><span class="line"><span class="comment"> *              如果为 NULL 或数据为空，则视为刷新数据包，用于通知解码器流结束。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 0：成功，数据包被接受。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avcodec_receive_frame() 读取输出。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：解码器已被刷新，无法再发送新数据包。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EINVAL)：编解码器未打开，或为编码器，或需要刷新。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(ENOMEM)：内部队列添加数据包失败，或其他类似错误。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：合法的解码错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_send_packet</span>(videoCodecCtx, packet)</span><br></pre></td></tr></table></figure><p><strong>avcodec_receive_frame</strong></p><p>解码之后，咱们得拿一下所得到的解码帧</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从解码器中获取一个已解码的帧。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，用于存储解码后的帧。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0，表示成功获取了一个解码后的帧。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：解码器需要更多输入数据才能产生输出，需要先调用 avcodec_send_packet。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：解码器已处理完所有输入数据，没有更多输出。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：解码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_receive_frame</span>(videoCodecCtx, frame)</span><br></pre></td></tr></table></figure><p>这里就要注意理解一下哈，avcodec_send_packet解码之后会放入一个缓冲区里面，avcodec_receive_frame会来取</p><p>avcodec_receive_frame的返回值里面会有一个AVERROR(EAGAIN)：解码器需要更多输入数据才能产生输出，需要先调用 avcodec_send_packet。这里做一下简单的介绍</p><ul><li>关键帧（I帧）：通常一个AVPacket对应一个AVFrame。</li><li>B&#x2F;P帧：可能需要参考前后帧，解码器可能缓存多个AVPacket后才输出AVFrame。</li><li>分包处理：某些编码格式（如H.264）可能将一个帧拆分到多个AVPacket中。</li></ul><p>一般的使用的格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    <span class="built_in">avcodec_send_packet</span>(codec_ctx, packet); <span class="comment">// 将AVPacket送入解码器</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(codec_ctx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理AVFrame</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里再说一下为什么会有第二个循环，其实上面的已经可以解释了，这里再说一下音频</p><p>音频解码的典型场景，音频帧打包：一个AVPacket可能包含多个音频帧（如AAC每个包含1024帧）。解码时需循环调用avcodec_receive_frame()直到返回AVERROR(EAGAIN)，表示需要新输入。</p><p>到这里解码就结束了，那么来看一下这个项目里面完整的处理流程(初始化就不说了，这里还是涉及到一些线程安全的操作哈，记得理解一下)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processVideoPackets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化临时的负责接收的包和帧</span></span><br><span class="line">    AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果还在push视频或者videoPacketQueue还没有空，就要一直执行</span></span><br><span class="line">    <span class="keyword">while</span> (!doneVideoReading || !videoPacketQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(videoMtx)</span></span>;   <span class="comment">//上锁（队列）</span></span><br><span class="line">        videoCV.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !videoPacketQueue.<span class="built_in">empty</span>() || doneVideoReading; &#125;);  <span class="comment">//等待（队列）</span></span><br><span class="line">        <span class="keyword">if</span> (!videoPacketQueue.<span class="built_in">empty</span>()) &#123;              <span class="comment">//videoPacketQueue还没空</span></span><br><span class="line">            *packet = *videoPacketQueue.<span class="built_in">front</span>();      <span class="comment">//并且取头pop出去</span></span><br><span class="line">            videoPacketQueue.<span class="built_in">pop</span>();</span><br><span class="line">            lock.<span class="built_in">unlock</span>();                            <span class="comment">//用完了解锁</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">avcodec_send_packet</span>(videoCodecCtx, packet) == <span class="number">0</span>) &#123;      </span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(videoCodecCtx, frame) == <span class="number">0</span>)&#123;</span><br><span class="line">                    AVFrame* frameCopy = <span class="built_in">av_frame_alloc</span>();  <span class="comment">// 复制帧数据到新帧 防止当前帧正在使用出现资源争夺</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">av_frame_ref</span>(frameCopy, frame) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">av_frame_free</span>(&amp;frameCopy);</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;视频 复制失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// 复制失败则跳过该帧</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将复制的帧推入环形缓冲区</span></span><br><span class="line">                    <span class="function">unique_lock&lt;mutex&gt; <span class="title">frameLock</span><span class="params">(videoFrameMtx)</span></span>;</span><br><span class="line">                    <span class="comment">//这里是用来输出查看环形缓冲区是不是正常的</span></span><br><span class="line">                    <span class="comment">//if (videoFrameBuffer.full())&#123;</span></span><br><span class="line">                        <span class="comment">//cout&lt;&lt;&quot;视频环形缓冲区满了，一直等待&quot;&lt;&lt;endl;</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//等待缓冲区有空位  </span></span><br><span class="line">                    videoFrameCV.<span class="built_in">wait</span>(frameLock, [&amp;] &#123;</span><br><span class="line">                        <span class="keyword">return</span> !videoFrameBuffer.<span class="built_in">full</span>();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    videoFrameBuffer.<span class="built_in">push</span>(frameCopy);</span><br><span class="line">                    videoFrameCV.<span class="built_in">notify_all</span>(); <span class="comment">// 有新帧 唤醒</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doneVideoFrameReading = <span class="literal">true</span>;</span><br><span class="line">    videoFrameCV.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">//关文件，放资源</span></span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;packet);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--线程解析视频包完成！--&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-处理解码之后的数据"><a href="#5-处理解码之后的数据" class="headerlink" title="5.处理解码之后的数据"></a>5.处理解码之后的数据</h3><p>这里的操作有很多，主要是为解码之后的数据添加滤镜，比如旋转，倍速，变声等操作都是在这里完成的</p><p>你看上面的代码我是不是就只是单纯的拿到解码之后的数据，然后放在一个环形缓冲区里面，其实这里放在环形缓冲区之前还可以做我上面所说的加滤镜的操作，然后再放进去。</p><p>这里太多了，就不一一介绍了，感兴趣的可以搜一下，学习一下，很有意思的。</p><h3 id="6-再编码回去"><a href="#6-再编码回去" class="headerlink" title="6.再编码回去"></a>6.再编码回去</h3><p>哈哈哈哈，好不容易做了解码这里咋又编码回去了</p><p>我们看一下前面的 FFMPEG介绍 里面的那个图，我们可以看到，再解码之后我们再加上一些同步的机制就可以分别调用视频和音频的驱动进行播放了</p><p>这里之前做过安卓的 native C++的项目 是这样处理的</p><p>但是我们这里主要是工作是 解码之后 做出处理（比如添加滤镜等功能） 然后再合成最后输出的mp4</p><p>所以我们还得再编码回去</p><p>这里编码就会简单了</p><p>因为编码也是用的  AVCodec 这个东西咱们之前已经介绍了，这里就不多说了</p><p>这里主要说一下编码器的初始化的操作，这里使用不同的方式进行初始化</p><p>之前咱们做解码的时候直接使用的是AVCodecParameters里面参数（解码器这样处理是必须的，毕竟不使用原始音视频文件之中的参数进行初始化的话就无法解码了）</p><p>咱们再编码的时候就可以自己定制编码器的参数了（这里需要有一些专业的视频编码的一些知识，我也没有这个知识，我写的时候是GPT生成了，哈哈哈哈）</p><p>这边要一定要搞懂 AVCodec 与 AVCodecContext的关系哈，一定要清楚，不然就会糊里糊涂的，用的时候根本搞不明白</p><h4 id="涉及到的结构-2"><a href="#涉及到的结构-2" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVCodec</strong></p><p>看前面的介绍</p><p><strong>AVCodecContext</strong></p><p>看前面的介绍</p><h4 id="涉及到的API-4"><a href="#涉及到的API-4" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avcodec_find_encoder_by_name</strong></p><p>这里咱们前面其实也介绍了 avcodec_find_<strong>decoder</strong>_by_name</p><p>这个和那个是一样的，只不过这里是 avcodec_find_<strong>encoder</strong>_by_name</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据编码器名称查找编码器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name 编码器的名称，例如 &quot;libx264&quot; 或 &quot;aac&quot;。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回指向找到的编码器的 AVCodec 结构体指针。</span></span><br><span class="line"><span class="comment"> *  - 如果未找到匹配的编码器，返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">const</span> AVCodec *<span class="title">avcodec_find_encoder_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>可以通过这个来获取咱们指定的编码器格式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用的是 mpeg4 编码器</span></span><br><span class="line"><span class="type">const</span> AVCodec* videoEncoder = <span class="built_in">avcodec_find_encoder_by_name</span>(<span class="string">&quot;mpeg4&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>avcodec_alloc_context3</strong></p><p>后面就是创建编器的上下文状态（AVCodecContext）了</p><p>这个函数和之前的一样，就不介绍了哈</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodecContext* videoEncoderCtx = <span class="built_in">avcodec_alloc_context3</span>(videoEncoder);</span><br></pre></td></tr></table></figure><p>这里要注意了哈，之前 咱们是用的 avcodec_parameters_to_context 给 AVCodecContext赋值的</p><p>这里可以回头到前面看看，是咋处理的</p><p>在这里咱们需要手动赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">videoEncoderCtx-&gt;width = <span class="number">1024</span>;                     <span class="comment">// 视频宽度</span></span><br><span class="line">videoEncoderCtx-&gt;height = <span class="number">436</span>;                     <span class="comment">// 视频高度</span></span><br><span class="line">videoEncoderCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;     <span class="comment">// MPEG4 标准支持的像素格式</span></span><br><span class="line">videoEncoderCtx-&gt;time_base = &#123;<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">25</span> * playSpeed)&#125;; <span class="comment">// 25 FPS</span></span><br><span class="line">videoEncoderCtx-&gt;bit_rate = <span class="number">2500000</span>;               <span class="comment">// 2.5 Mbps 码率</span></span><br><span class="line">videoEncoderCtx-&gt;gop_size = <span class="number">12</span>;                    <span class="comment">// 关键帧间隔</span></span><br><span class="line">videoEncoderCtx-&gt;max_b_frames = <span class="number">10</span>;                <span class="comment">// B帧最大数量</span></span><br><span class="line">videoEncoderCtx-&gt;level = <span class="number">5</span>;                        <span class="comment">// Level 5</span></span><br></pre></td></tr></table></figure><p>说实话有些参说我也搞不动，我这个是GPT生成的</p><p>大概意思就是把那些重要的参数给赋值了，后面就直接用就好了</p><p><strong>avcodec_open2</strong></p><p>后面就是打开编码器了，这个前面已经说过了，就不再赘述了。</p><p><strong>avcodec_send_frame</strong></p><p>咱们之前已经说了解码的时候的 avcodec_send_packet 函数</p><p>packet是封住之后的包，那么咱们现在需要对原始数据frame做处理，自然就是 avcodec_send_frame</p><p>这个用法和avcodec_send_packet是一样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 AVFrame 发送到编码器进行编码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示编码器上下文。</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，表示要编码的帧。如果为 NULL，则表示刷新编码器。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avcodec_receive_packet 读取输出。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：编码器已被刷新，无法再发送新帧。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EINVAL)：输入参数无效，或编码器未打开。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：编码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_send_frame</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>avcodec_receive_packet</strong></p><p>同理哈，就和前面的一样， avcodec_send_packet 与  avcodec_receive_frame 配套出现</p><p>这里就是 avcodec_send_frame 与 avcodec_receive_packet 配套出现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从编码器中获取一个已编码的数据包。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示编码器上下文。</span></span><br><span class="line"><span class="comment"> * @param avpkt 指向 AVPacket 的指针，用于存储编码后的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0，表示成功获取了一个编码后的数据包。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：编码器需要更多输入帧才能产生输出，需要先调用 avcodec_send_frame。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：编码器已处理完所有输入帧，没有更多输出。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：编码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_receive_packet</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure><p>这里做一下说明哈，这里面的一些处理的操作基本上都是配套出现的，就比如咱们上面的所说的</p><p>avcodec_send_packet 与 avcodec_receive_frame</p><p>avcodec_send_frame 与 avcodec_receive_packet</p><p>还有其他的操作，比如说 滤镜 也是先把帧send进入，然后再receive一下</p><p>再比如音频的重定向 也是这样的。</p><p>那么咱们再来看一下视频部分的整体操作（同样的哈，我这里面有一些线程的操作，清稍微忽略一下哈）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int64_t</span> frame_pts = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//还在处理视频帧，或者videoFrameBuffer非空</span></span><br><span class="line"><span class="keyword">while</span> (!doneVideoFrameReading||!videoFrameBuffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">// 从队列中区取帧</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">frameLock</span><span class="params">(videoFrameMtx)</span></span>;    <span class="comment">//上锁</span></span><br><span class="line">    videoFrameCV.<span class="built_in">wait</span>(frameLock, [&amp;] &#123;<span class="keyword">return</span> !videoFrameBuffer.<span class="built_in">empty</span>() || doneVideoFrameReading;&#125;);  <span class="comment">//空等待</span></span><br><span class="line">    <span class="keyword">if</span>(!videoFrameBuffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        AVFrame* frame = videoFrameBuffer.<span class="built_in">front</span>();</span><br><span class="line">        videoFrameBuffer.<span class="built_in">pop</span>();</span><br><span class="line">        frame-&gt;pts = frame_pts++;        <span class="comment">//！！！很关键的pts设置</span></span><br><span class="line">        frameLock.<span class="built_in">unlock</span>();</span><br><span class="line">        videoFrameCV.<span class="built_in">notify_all</span>();       <span class="comment">//环形缓冲区有空间了</span></span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">lock</span>();       <span class="comment">//videoEncoderCtxMtx的锁，防止和输出的部分有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avcodec_send_frame</span>(videoEncoderCtx,frame)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;视频，发送帧到编码器失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame); <span class="comment">//释放帧资源</span></span><br><span class="line">        </span><br><span class="line">        AVPacket* encodedPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> receivePacketResult = <span class="built_in">avcodec_receive_packet</span>(videoEncoderCtx, encodedPacket);</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">while</span> (receivePacketResult == <span class="number">0</span>) &#123;</span><br><span class="line">            AVPacket* pkt = <span class="built_in">av_packet_clone</span>(encodedPacket);     <span class="comment">//克隆包并存入队列</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">encLock</span><span class="params">(videoFrameEncoderMtx)</span></span>;   <span class="comment">//上锁</span></span><br><span class="line">            videoFrameEncoderQueue.<span class="built_in">push</span>(pkt);                   <span class="comment">//push   结束了开锁</span></span><br><span class="line">            encLock.<span class="built_in">unlock</span>();</span><br><span class="line">            videoFrameEncoderCV.<span class="built_in">notify_all</span>();                    <span class="comment">// 通知有新包</span></span><br><span class="line">            <span class="built_in">av_packet_unref</span>(encodedPacket);</span><br><span class="line">            videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">            receivePacketResult = <span class="built_in">avcodec_receive_packet</span>(videoEncoderCtx, encodedPacket);</span><br><span class="line">            videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="built_in">av_packet_free</span>(&amp;encodedPacket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个点忘记说了，这里的frame_pts很重要，这是时间戳，一般会有编码时间戳和显示时间戳，这里要设置好，看这一行！frame-&gt;pts &#x3D; frame_pts++;        &#x2F;&#x2F;！！！很关键的pts设置</p><p>还有一点，音频在编码的时候如果像咱们这样 自己设置了编码器的参数，就需要有一个重定向的过程。</p><p>这个重定向的过程就不详细讲了。感兴趣的可以取搜一下</p><h3 id="7-最后就是封装在一起了"><a href="#7-最后就是封装在一起了" class="headerlink" title="7.最后就是封装在一起了"></a>7.最后就是封装在一起了</h3><p>这个过程就很简单了，理解了之前打开的例子，这个就好理解了</p><p>唯一一点需要注意的就是音视频的同步的问题</p><h4 id="涉及到的结构-3"><a href="#涉及到的结构-3" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p>没有新的结构，上面都介绍过了。</p><h4 id="涉及到的API-5"><a href="#涉及到的API-5" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_alloc_output_context2</strong></p><p>就是打开一个输出的AVFormatContext</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配并初始化一个用于输出多媒体文件的 AVFormatContext。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ctx 指向 AVFormatContext 指针的指针，用于存储分配的上下文。</span></span><br><span class="line"><span class="comment"> * @param oformat 指向 AVOutputFormat 的指针，指定输出格式。如果为 NULL，将根据 format_name 或 filename 自动推断输出格式。</span></span><br><span class="line"><span class="comment"> * @param format_name 指定输出格式的名称，例如 &quot;mp4&quot;。如果 oformat 为 NULL 且 format_name 非空，FFmpeg 会尝试根据这个名字找到合适的输出格式。</span></span><br><span class="line"><span class="comment"> * @param filename 输出文件的名称。如果 oformat 为 NULL，此参数用于根据文件扩展名自动生成输出格式。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误代码，例如 AVERROR_NOENT 或 AVERROR_INVALIDDATA。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_alloc_output_context2</span><span class="params">(AVFormatContext **ctx, <span class="type">const</span> AVOutputFormat *oformat, <span class="type">const</span> <span class="type">char</span> *format_name, <span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>没啥复杂的用法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化输出 MP4 文件</span></span><br><span class="line">AVFormatContext* outFormatCtx = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">avformat_alloc_output_context2</span>(&amp;outFormatCtx, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, outFilePath);</span><br><span class="line"><span class="keyword">if</span> (!outFormatCtx) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无法创建输出上下文&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单</p><p>后面就需要创建流了，咱们前面也说了，AVFormatContext有很多的流信息，现在咱们有个空的AVFormatContext就需要先把流信息填进取。</p><p>咱们这里只需要视频流和音频流就可以了</p><p><strong>avformat_new_stream</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的 AVStream 并将其添加到 AVFormatContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要添加新流的上下文。</span></span><br><span class="line"><span class="comment"> * @param c 指向 AVCodec 的指针，表示新流的编解码器。如果为 NULL，则不设置编解码器[^61^]。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回新创建的 AVStream 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure><p>相当于new一个</p><p>基本用法也很简单</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p><strong>avcodec_parameters_from_context</strong></p><p>注意哈，咱们用avformat_new_stream创建了一个流，并且放进了outFormatCtx里面，但是这个流是啥流还不知道哇，因此咱们需要给他的codecpar赋值（这里想一下前面是如何判断是啥流的的哈）</p><p>就是把咱们的编码器的参数给放进去哈</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的 AVStream 并将其添加到 AVFormatContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要添加新流的上下文。</span></span><br><span class="line"><span class="comment"> * @param c 指向 AVCodec 的指针，表示新流的编解码器。如果为 NULL，则不设置编解码器[^61^]。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回新创建的 AVStream 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure><p>基本用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br></pre></td></tr></table></figure><p>那么咱们看一下完整的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建视频流</span></span><br><span class="line">AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br><span class="line">videoStream-&gt;time_base = videoEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建音频流</span></span><br><span class="line">AVStream* audioStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(audioStream-&gt;codecpar, audioEncoderCtx);</span><br><span class="line">audioStream-&gt;time_base = audioEncoderCtx-&gt;time_base;</span><br></pre></td></tr></table></figure><p><strong>avio_open</strong></p><p>然后就需要打开文件了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开输出文件</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_READ：以只读方式打开文件。</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_WRITE：以只写方式打开文件。</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_READ_WRITE：以读写方式打开文件。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;outFormatCtx-&gt;pb, outFilePath, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法打开输出文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>avformat_write_header</strong></p><p>这些都是一些固定的操作了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入媒体文件的头部信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要写入头部信息的上下文。</span></span><br><span class="line"><span class="comment"> * @param options 指向 AVDictionary 的指针，表示写入头部时的额外选项。如果为 NULL，则不传递任何选项。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(ENOMEM)：内存分配失败。</span></span><br><span class="line"><span class="comment"> *    - 其他负值：写入过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_write_header</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写入文件头</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(outFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无法写入文件头&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>av_packet_rescale_ts</strong></p><p>咱们拿到一个包之后还不能直接写，得先调用av_packet_rescale_ts转化一下时间基，就是把原来的时间其转化到对应流的时间基下，这样才能保证正常的播放那个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AVPacket 中的时间戳从一个时间基转换为另一个时间基。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要调整时间戳的数据包。</span></span><br><span class="line"><span class="comment"> * @param tb_src 源时间基，即原始时间戳所依据的时间基。</span></span><br><span class="line"><span class="comment"> * @param tb_dst 目标时间基，即要转换到的时间基。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span>;</span><br></pre></td></tr></table></figure><p>咱们来看一下整体的流程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*videoPacket = *videoFrameEncoderQueue.<span class="built_in">front</span>();</span><br><span class="line">videoFrameEncoderQueue.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="built_in">av_packet_rescale_ts</span>(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);</span><br><span class="line">videoPacket-&gt;stream_index = videoStream-&gt;index;</span><br><span class="line">packetToWrite = videoPacket;</span><br><span class="line">streamIndex = videoStream-&gt;index;    </span><br></pre></td></tr></table></figure><p>其他的都不用多看哈，这里就两行比较重要，后面的都是逻辑处理的</p><p>1.转化时间基<br>av_packet_rescale_ts(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);</p><p>2.设置videoPacket的stream_index，这个非常重要，要不然不知道他是啥流</p><p><strong>av_interleaved_write_frame</strong></p><p>这里就是写的了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交错写入一个数据包到媒体文件中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要写入数据包的上下文。</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要写入的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(ENOMEM)：内存分配失败。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avformat_write_header。</span></span><br><span class="line"><span class="comment"> *    - 其他负值：写入过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_interleaved_write_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>注意哈，这里是交叉写入。这里可以搜一下为啥要交叉写入。</p><h4 id="同步的基本操作"><a href="#同步的基本操作" class="headerlink" title="同步的基本操作"></a>同步的基本操作</h4><p>后面就没啥了，但是这边还有一个比较重要的就是音频和视频的同步</p><p>如果不进行同步的话，就会发现 视频和音频各播各的</p><p>同步的思路：</p><p>获得到的视频和音频的 packet 先把两个包转化到同一个时间基下</p><p>比较一下那个时间基小，先把小的给写进取</p><p>（你品，你细品）</p><p>整体的代码(涉及的到线程的操作)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoOutMP4File</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* outFilePath)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//初始化输出 MP4 文件</span></span><br><span class="line">    AVFormatContext* outFormatCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">avformat_alloc_output_context2</span>(&amp;outFormatCtx, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, outFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!outFormatCtx) &#123;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法创建输出上下文&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建视频流</span></span><br><span class="line">    AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br><span class="line">    videoStream-&gt;time_base = videoEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建音频流</span></span><br><span class="line">    AVStream* audioStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">avcodec_parameters_from_context</span>(audioStream-&gt;codecpar, audioEncoderCtx);</span><br><span class="line">    audioStream-&gt;time_base = audioEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;outFormatCtx-&gt;pb, outFilePath, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法打开输出文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入文件头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(outFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法写入文件头&quot;</span> &lt;&lt; endl;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">avio_closep</span>(&amp;outFormatCtx-&gt;pb);</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用完了解锁 上锁和解锁的顺序是反者的，防止死锁</span></span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临时变量</span></span><br><span class="line">    AVPacket* videoPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">    AVPacket* audioPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环退出条件  只有当两个队列都是空的并且对视频和音频的编码的操作也都结束了才会停止 确保所有的数据都写进去</span></span><br><span class="line">    <span class="type">bool</span> videoDone = videoFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneVideoFrameEncoderReading;</span><br><span class="line">    <span class="type">bool</span> audioDone = audioFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneAudioFrameEncoderReading;</span><br><span class="line">    <span class="keyword">while</span> (!videoDone||!audioDone) &#123;</span><br><span class="line">        </span><br><span class="line">        AVPacket* packetToWrite = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> streamIndex = <span class="number">-1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">videoQueue</span><span class="params">(videoFrameEncoderMtx)</span></span>;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">audioQueue</span><span class="params">(audioFrameEncoderMtx)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待两个队列都有数据 或者两个队列都已经push完了，要保证两个队列之中都有数据</span></span><br><span class="line">            videoFrameEncoderCV.<span class="built_in">wait</span>(videoQueue,[]&#123;<span class="keyword">return</span> !videoFrameEncoderQueue.<span class="built_in">empty</span>()||doneVideoFrameEncoderReading; &#125;);</span><br><span class="line">            audioFrameEncoderCV.<span class="built_in">wait</span>(audioQueue,[]&#123;<span class="keyword">return</span> !audioFrameEncoderQueue.<span class="built_in">empty</span>()||doneAudioFrameEncoderReading; &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取音视频当前时间戳，要放在确定的时间基下</span></span><br><span class="line">            <span class="type">int64_t</span> video_pts = (!videoFrameEncoderQueue.<span class="built_in">empty</span>()) ? </span><br><span class="line">                <span class="built_in">av_rescale_q</span>(videoFrameEncoderQueue.<span class="built_in">front</span>()-&gt;pts,videoEncoderCtx-&gt;time_base,videoStream-&gt;time_base):INT64_MAX;</span><br><span class="line">            <span class="type">int64_t</span> audio_pts = (!audioFrameEncoderQueue.<span class="built_in">empty</span>()) ? </span><br><span class="line">                <span class="built_in">av_rescale_q</span>(audioFrameEncoderQueue.<span class="built_in">front</span>()-&gt;pts,audioEncoderCtx-&gt;time_base,audioStream-&gt;time_base):INT64_MAX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择时间戳较小的帧进行写入</span></span><br><span class="line">            <span class="keyword">if</span> (!videoFrameEncoderQueue.<span class="built_in">empty</span>()&amp;&amp;</span><br><span class="line">            (audioFrameEncoderQueue.<span class="built_in">empty</span>()||</span><br><span class="line">            <span class="built_in">av_compare_ts</span>(video_pts,videoStream-&gt;time_base,audio_pts,audioStream-&gt;time_base)&lt;=<span class="number">0</span>)) &#123;     <span class="comment">//通过av_compare_ts作比较（不同的时间基下）</span></span><br><span class="line">                *videoPacket = *videoFrameEncoderQueue.<span class="built_in">front</span>();                                         <span class="comment">//取包</span></span><br><span class="line">                videoFrameEncoderQueue.<span class="built_in">pop</span>();                                                           <span class="comment">//pop</span></span><br><span class="line">                <span class="built_in">av_packet_rescale_ts</span>(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);  <span class="comment">//转化到对应的时间基下</span></span><br><span class="line">                videoPacket-&gt;stream_index = videoStream-&gt;index;                                         <span class="comment">//设置stream_index（视频的）</span></span><br><span class="line">                packetToWrite = videoPacket;                                                            <span class="comment">//拷贝过来（这里还没有写入）</span></span><br><span class="line">                streamIndex = videoStream-&gt;index;                                                       <span class="comment">//当前的index（后面是醋糊错误信息用）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!audioFrameEncoderQueue.<span class="built_in">empty</span>()) &#123;                                               <span class="comment">//下面是一样的流程</span></span><br><span class="line">                *audioPacket = *audioFrameEncoderQueue.<span class="built_in">front</span>();</span><br><span class="line">                audioFrameEncoderQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">av_packet_rescale_ts</span>(audioPacket, audioEncoderCtx-&gt;time_base, audioStream-&gt;time_base);</span><br><span class="line">                audioPacket-&gt;stream_index = audioStream-&gt;index;</span><br><span class="line">                packetToWrite = audioPacket;</span><br><span class="line">                streamIndex = audioStream-&gt;index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while结束条件 只有当两个队列都是空的并且对视频和音频的编码的操作也都结束了才会停止</span></span><br><span class="line">            videoDone = videoFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneVideoFrameEncoderReading;</span><br><span class="line">            audioDone = audioFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneAudioFrameEncoderReading;</span><br><span class="line">            audioQueue.<span class="built_in">unlock</span>();</span><br><span class="line">            videoQueue.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packetToWrite) &#123;  <span class="comment">//这里一定要注意不可以视频和音频是交叉写入的，这样才是正确的效果（之前老师让我哦门使用CSV输出的信息的时候可以观察到）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_interleaved_write_frame</span>(outFormatCtx, packetToWrite) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;写入包失败: &quot;</span>&lt;&lt;streamIndex&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(packetToWrite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">avcodec_send_frame</span>(videoEncoderCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">avcodec_send_frame</span>(audioEncoderCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;videoPacket);</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;audioPacket);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(outFormatCtx);</span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;outFormatCtx-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--线程写入MP4完成！--&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>说实话有些不想写了，前面已经把所有的基本的流程给介绍过了，这里最多补充一下细节</p><h2 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h2><p>地址：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/1_ffmpeg">https://github.com/zqzhang2023/zzqStudy/tree/main/project/1_ffmpeg</a></p><p>环境：</p><p>linux ubuntu 20.04</p><p>C++ 11</p><p>ffmpeg（这个有没有都可以）</p><p>cmake</p><p>进入根目录文件夹</p><p>然后</p><p>cd build</p><p>cmake ..</p><p>make</p><p>.&#x2F;transcode</p><p>(要处理的是视频文件在resources里面 1.mp4 输出为 2.mp4)</p><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p><strong>transcode.cpp</strong>                 为入口程序</p><p><strong>lib&#x2F;include&#x2F;manageAll.h</strong>       为管理全局变量和函数以及参数的头文件</p><p><strong>src&#x2F;initGlobalVariable.cpp</strong>    为全局变量以及参数的初始化和释放</p><p><strong>src&#x2F;productionPackage.cpp</strong>     实现了拆分音视频为音频包和视频包的线程</p><p><strong>src&#x2F;videoAnalysis.cpp</strong>         实现了对视频包进行解码成视频帧的线程</p><p><strong>src&#x2F;videoFrameEncoding.cpp</strong>    实现了对视频帧重新编码成为视频包的线程</p><p><strong>src&#x2F;audioAnalysis.cpp</strong>         实现了对音频包进行解码成音频帧的线程</p><p><strong>src&#x2F;audioFrameEncoding.cpp</strong>    实现了对音频帧重新编码成为音频包的线程</p><p><strong>src&#x2F;videoOutMP4File.cpp</strong>       实现了重新整合音频包和视频包为MP4文件的线程</p><p><strong>lib&#x2F;include&#x2F;queue.h</strong>           队列的声明与实现</p><p><strong>lib&#x2F;include&#x2F;circularbuffer.h</strong>  环形缓冲区的声明与实现</p><h2 id="ffmpeg-库的编译"><a href="#ffmpeg-库的编译" class="headerlink" title="ffmpeg 库的编译"></a>ffmpeg 库的编译</h2><p>就是把ffmpeg的库编译成静态库，然后后面咱们使用的话就可以直接用这个库，不需要安装ffmpeg</p><p>这里很方便，比如我把我写的这些东西复制给其他人，他们不需要再配置ffmpeg的环境了，可以直接运行起来</p><p>（我现在的机子里面就没装ffmpeg，也可以正常运行）</p><p>方法：</p><p>1.把源码下下来 <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p><p>找一下适合的版本号就好</p><p>2.进入根目录创建一个build.sh的空文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PREFIX=<span class="string">&quot;/home/ubuntu2204/ffmpge/out_one&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">build</span></span>() &#123;   </span><br><span class="line">    make clean</span><br><span class="line">    ./configure \</span><br><span class="line">        --disable-shared \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --disable-doc \</span><br><span class="line">        --disable-programs \</span><br><span class="line">        --enable-avcodec \</span><br><span class="line">        --enable-avfilter \</span><br><span class="line">        --enable-avformat \</span><br><span class="line">        --enable-avutil \</span><br><span class="line">        --enable-swscale \</span><br><span class="line">        --enable-swresample \</span><br><span class="line">        --prefix=<span class="string">&quot;<span class="variable">$PREFIX</span>&quot;</span> \</span><br><span class="line">        --extra-cflags=<span class="string">&quot;-fPIC&quot;</span> \</span><br><span class="line">        --extra-ldflags=<span class="string">&quot;-Wl,-rpath=&#x27;\$ORIGIN&#x27;&quot;</span> </span><br><span class="line"></span><br><span class="line">    make -j$(<span class="built_in">nproc</span>) </span><br><span class="line">    make install</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用gcc链接共享库</span></span><br><span class="line">    gcc -shared -o libffmpeg.so \</span><br><span class="line">        -Wl,--whole-archive \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavcodec.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavfilter.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavformat.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libswscale.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libswresample.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavutil.a&quot;</span> \</span><br><span class="line">        -Wl,--no-whole-archive \</span><br><span class="line">        -Wl,-Bsymbolic -Wl,--no-undefined \</span><br><span class="line">        -lm -lz -pthread -ldl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译</span></span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>PREFIX 是 输出的目录</p><p>里面会有 一个  libffmpeg.so 的文件 还有 一个include文件夹，记得把这些都复制过来</p><p>为什么要有include 头文件，因为libffmpeg.so相当于对头文件的实现，必须得有include文件咱们才能在代码里面用</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>先写到这吧，一天复习了整个项目的流程，实在不想写了。等下次有时间再去写吧。不说了背八股去了</p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tinyWebServer</title>
      <link href="/2025/04/15/tinyWebServer/"/>
      <url>/2025/04/15/tinyWebServer/</url>
      
        <content type="html"><![CDATA[<h1 id="tinyWebServer-项目"><a href="#tinyWebServer-项目" class="headerlink" title="tinyWebServer 项目"></a>tinyWebServer 项目</h1><p>写在前面：</p><p>学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。</p><p>刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急，可以提前了解一下项目的知识再重新来做一下。</p><p>于是就先做了三个小项目，每个项目都挺经典的，而且项目的代码量也很小。</p><ul><li>线程池的项目：(主要学习线程池的概念和用法)<ul><li>项目介绍：<a href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/</a></li><li>git链接：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool">https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool</a></li></ul></li><li>tinyhttpd 项目：（主要HTTP协议）<ul><li>项目介绍：<a href="https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/">https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/</a></li><li>git链接：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/3_tinyhttpd">https://github.com/zqzhang2023/zzqStudy/tree/main/project/3_tinyhttpd</a></li></ul></li><li>chatRoom 项目：（主要学习socket和IO多路复用）<ul><li>项目介绍：<a href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a></li><li>git链接：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/4_chatRoom">https://github.com/zqzhang2023/zzqStudy/tree/main/project/4_chatRoom</a></li></ul></li></ul><p>学习完基础知识之后，就开始尝试学学习这个项目</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这个项目在github上面有很多的版本</p><p>先说一下我自己的（嘿嘿嘿）：</p><p>cmake版本：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer</a></p><p>makefile版本：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile</a></p><p>初始的应该是这个：<a href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer</a></p><p>但是这个确实有些久远，有些语法可能目前不太常使用了， 在这个最初的版本后面有贴C++ 11 实现的版本</p><p>也就是这个：<a href="https://github.com/markparticle/WebServer">https://github.com/markparticle/WebServer</a></p><p>这个C++ 11 的版本看着很舒心，于是我就选择了这个版本开始学习</p><p>介绍：(这个是官方git上的原话，我直接拿过来了)</p><p>Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.</p><ul><li><p>使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型</p></li><li><p>使用状态机解析HTTP请求报文，支持解析GET和POST请求</p></li><li><p>访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</p></li><li><p>实现同步&#x2F;异步日志系统，记录服务器运行状态</p></li><li><p>经Webbench压力测试可以实现上万的并发连接数据交换</p></li></ul><p><img src="/../0_images/tinyWebServer/0_tinyWebServer.jpg" alt="alt text"></p><h1 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h1><p>image<br>我的运行环境是Linux Ubuntu 20.04，Mysql，C++ 11</p><p>使用的版本是：<a href="https://github.com/markparticle/WebServer">https://github.com/markparticle/WebServer</a></p><p>1.首先要安装数据库（这个可以找一下教程，网上有很多，而且安装确实不难）</p><p>2.然后按照网站是给出的步骤来,建立数据库和创建表格添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 建立yourdb库</span><br><span class="line">create database yourdb;</span><br><span class="line"></span><br><span class="line">// 创建user表</span><br><span class="line">USE yourdb;</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">    username char(50) NULL,</span><br><span class="line">    password char(50) NULL</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">// 添加数据</span><br><span class="line">INSERT INTO user(username, password) VALUES(&#x27;name&#x27;, &#x27;password&#x27;);</span><br></pre></td></tr></table></figure><p>3.修改一下 code&#x2F;main.cpp 里面的参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 守护进程 后台运行 </span></span><br><span class="line">    <span class="function">WebServer <span class="title">server</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">1316</span>, <span class="number">3</span>, <span class="number">60000</span>,              <span class="comment">// 端口 ET模式 timeoutMs </span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">3306</span>, <span class="string">&quot;用户(一般是root)&quot;</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;数据库名&quot;</span>, <span class="comment">/* Mysql配置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">12</span>, <span class="number">8</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="number">1024</span>)</span></span>;             <span class="comment">/* 连接池数量 线程池数量 日志开关 日志等级 日志异步队列容量 */</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>4.在根目录下 执行  make</p><p>5.在根目录下 执行 sudo .&#x2F;bin&#x2F;server （这里要用sudo哈，要不然可能出现权限问题）</p><p>下面是运行成功图（这个是后面截的，我修改了一部分）：</p><p><img src="/../0_images/tinyWebServer/1_%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F%E5%9B%BE.png" alt="alt text"></p><h1 id="项目文件作用"><a href="#项目文件作用" class="headerlink" title="项目文件作用"></a>项目文件作用</h1><p>简单介绍一下各个文件的作用，官方给的是这个，但是咱们主要看code文件里面的东西</p><pre><code>.├── code           源代码的目录│   ├── buffer     │   ├── config     │   ├── http       │   ├── log│   ├── timer│   ├── pool│   ├── server│   └── main.cpp├── test           单元测试│   ├── Makefile│   └── test.cpp├── resources      静态资源│   ├── index.html│   ├── image│   ├── video│   ├── js│   └── css├── bin            可执行文件│   └── server├── log            日志文件├── webbench-1.5   压力测试├── build          │   └── Makefile├── Makefile├── LICENSE└── readme.md</code></pre><p>code文件夹目录：</p><pre><code>code/├── buffer/│   ├── buffer.cpp│   ├── buffer.h             缓冲区的实现│   └── readme.md├── http/│   ├── httpconn.cpp│   ├── httpconn.h           综合httprequest与httpresponse│   ├── httprequest.cpp│   ├── httprequest.h        处理http请求│   ├── httpresponse.cpp│   ├── httpresponse.h       处理http响应│   └── readme.md├── log/│   ├── blockqueue.h         阻塞队列(生产者消费者模式)│   ├── log.cpp│   ├── log.h                日志系统│   └── readme.md├── pool/│   ├── readme.md│   ├── sqlconnpool.cpp│   ├── sqlconnpool.h        mysql链接池│   └── threadpool.h         线程池├── server/│   ├── epoller.cpp│   ├── epoller.h            对epoll接口的封装│   ├── readme.md│   ├── webserver.cpp    │   └── webserver.h          最后的实现，综合了前面所有东西├── timer/│   ├── heap_timer.cpp │   ├── heap_timer.h         小根堆计时器│   └── readme.md└── main.cpp                 入口文件</code></pre><p>下面就开始复现该项目，这个是别人的思路：</p><ul><li><p>通过采用从局部到整体的设计思想。先使用单一线程完成串行的HTTP连接建立、HTTP消息处理和HTTP应答发送，然后围绕高并发这个核心扩展多个模块。</p></li><li><p>首先就是日志模块和缓冲区模块的一个设计，这里优先实现是为了下面各个模块的调试方便，记录各个模块运行的状况和打印输出模块运作情况来排除明显的BUG。</p></li><li><p>然后是引入I&#x2F;O多路复用实现单线程下也能在一次系统调用中同时监听多个文件描述符，再进一步搭配线程池实现多客户多任务并行处理，这是高并发的核心部分。</p></li><li><p>在这个基础上做一点优化，在应用层实现了心跳机制，通过定时器实现非活跃连接的一个检测和中断，减少系统资源（内存）不必要的浪费。最后将所有模块整合起来，实现一个单Reactor多线程的网络设计模式，将多个模块串联起来实现完整高并发的服务器程序。</p></li><li><p>线程安全这块是通过不断将锁的粒度降低，平衡性能和安全。一开始采用粒度较粗的锁实现互斥（通常是整个操作），然后慢慢分析将一些不共享的代码移出临界区，慢慢调整慢慢优化。</p></li><li><p>最后加入数据库部分，因为这一部分比较独立，采用RAII机制创建连接池，拿出连接来使用。在HTTP中加入数据库信息验证的功能。</p></li></ul><p>我确实水平有限，没有按上面的思路实现，我的实现方法是：过两遍</p><ul><li><p>先看一遍代码，为原先的代码添加注释，一行一行的添加，每一行都要理解</p></li><li><p>自己写一遍，写的时候只看头文件(第一遍加注释的时候已经在头文件上加上各个函数的功能了)，自己写cpp文件实现头文件，遇到不会的再看原作者的实现</p><ul><li>如何验证自己写的是对的？</li><li>刚开始已经把原项目跑起来了，把自己写好的cpp实现替换跑起来的原项目的文件，看能不能再跑起来，有问题就调整。</li></ul></li></ul><h1 id="项目复现流程"><a href="#项目复现流程" class="headerlink" title="项目复现流程"></a>项目复现流程</h1><p>建立复现的流程：</p><ul><li>buffer 缓冲区的实现，这个和其不依赖其他模块，但是其他模块很依赖这个</li><li>log    日志系统,这个只依赖buffer模块，而且实现这个之后咱们就可以通过日志来调试了</li><li>pool   线程池和数据库连接池模块，这个模块比较独立，也是只依赖log和buffer</li><li>http   处理http请求与响应，依赖buffer log pool<ul><li>内部建议实现顺序：</li><li>httprequest(http请求的处理)</li><li>httpresponse(根据http请求来生成响应)</li><li>httpconn(将上面两个连接在一起，包括请求的接收以及响应的发送等)</li></ul></li><li>timer  小根堆计时器，是一个工具，只依赖log，还是因为调试才依赖的，很独立</li><li>server 最后的综合实现<ul><li>内部建议实现顺序：</li><li>epoller 对IO多路复用技术 epoll进行了一个封装</li><li>webserver 最后对所有模块进行综合</li></ul></li></ul><h1 id="项目复现"><a href="#项目复现" class="headerlink" title="项目复现"></a>项目复现</h1><p>按照项目复现流程开始复现</p><p>因为我已经提前看了一遍代码了，确实不知道如何从0开始写介绍，所以针对每个模块，我主要介绍一下我当时闭环模糊的点</p><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><p>这是一个缓冲区模块模块，设计的非常的巧妙，通过两个指针来切分整个 vector ，我搜索的资料是这个设计的思路来源于 陈硕大佬的muduo网络库。</p><p>注意buffer的内容，要不然很容易搞迷糊，通过两个指针把buffer分成了三个区域 </p><p><img src="/../0_images/tinyWebServer/2_buffer%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p>|————-A———|————B———–|———–C————-|</p><ul><li>A区域：左侧是Buffer[0] 右侧是readPos_  这里表示prependable区域(正常情况下应该是读区域和写区域，读区域最开始的index应该是0，数据读除去之后 readPos_++ 就形成了这样一个区域，所以这个区域被称为备用区域，后续可以用这个区域来扩容写空间)</li><li>B区域：左侧是readPos_  右侧是writePos_ 这篇区域表示可以被读出去的区域</li><li>C区域：左侧是writePos_  右侧是readPos_ 这片区域表示便是可以写进来的区域</li></ul><p>那么我们模拟一下过程，假设一个buffer为1024这么大，那么初始的readPos_，writePos_均为0，现在进行模拟(记得在脑海里面想象一下过程)</p><ul><li>现在有一个socketfd要往buffer里面写东西，咱们调用他的read函数，然后把得到东西写入buffer中，假设使用了64字节那么大 (现在就是字节存进取，writePos_后移动64个位置)（现在写区域还剩下1024-64）</li><li>服务器读取内容，假设第一次读取32个字节(假设哈，这里是模拟，不是真实的)，那么readPos_向后移动32个位置，这个时候就形成了3个区域了，其中A区域，也就是0-31这些地方的内容已经被读出去了，不再需要了</li><li>现在服务器要把返回的东西写进来buffer，假设要写进来的东西是1024-64 + 16 比 还剩下的1024 - 64 多 16个字节，那么咱们就需要查找一下A区域的大小，咱们发现，A区域还有32个字节，可以支持，那么现在就需要合并一下A与C区域<ul><li>合并方法，移动B区域，将B区域移动到最前面，readPos_变成 0 writePos_变成 B.size B区域的大小</li><li>如果发现合并区域之后还是不行的话，那么就要给buffer多分配空间了</li></ul></li></ul><p><strong>代码（其实项目里面有，但是我这里加了注释可能比较清楚一些）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>    <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;         <span class="comment">// 地层的容器</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_; <span class="comment">// 原子类型的读指针(当前的读的位置)</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;<span class="comment">// 原子类型的写指针(当前的写的位置)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区起始地址（非常量）</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取缓冲区起始地址（常量）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 扩容或整理缓冲区以提供至少len字节可写空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数，初始化缓冲区大小及读写位置</span></span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize = <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//默认析构函数</span></span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//获取当前可写空间大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取当前可读数据大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取预留空间（已读区域）大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//返回当前可读数据的起始地址（常量指针）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//确保至少有len字节的可写空间，否则扩容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动写指针（数据写入后调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动读指针（消费len字节数据）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动读指针到指定地址（消费到end的数据）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line">    <span class="comment">//重置缓冲区（清空数据，读写指针归零）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//取出所有可读数据并转为字符串，清空缓冲区</span></span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回当前写位置常量指针</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//返回当前写位置指针</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//添加字符串到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="comment">//添加字符数组到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//添加任意类型数据到缓冲区（转换为char*）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//添加另一个缓冲区的可读数据到当前缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="comment">//从文件描述符读取数据到缓冲区（使用readv,并且注意这里是读数据到缓冲区，所以要放入C区域，操作的是writePos_）</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="comment">//将缓冲区的可读数据写入文件描述符(注意这里是写入文件描述符，因此要读缓冲区，是从B区域读出去，操作的是readPos_)</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="comment">//注意上面俩参数，非常容易搞混乱</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：初始化缓冲区大小和读写位置</span></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize):<span class="built_in">buffer_</span>(initBuffSize),<span class="built_in">readPos_</span>(<span class="number">0</span>),<span class="built_in">writePos_</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(initBuffSize &gt; <span class="number">0</span> ); <span class="comment">//确保initBuffSize的有效性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可写字节数 = 总容量 - 写位置</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可读字节数 = 写位置 - 读位置</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回预留空间（已读区域）大小 = 读位置 (已经读过的就没用了，等于读下标)</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可读数据起始地址（常量指针）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[readPos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保至少有len字节可写空间，否则扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="built_in">WritableBytes</span>())&#123;  <span class="comment">//目前的空间不足</span></span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);        <span class="comment">//整理(合并)一下空间，再不足就扩容了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(len &lt; <span class="built_in">WritableBytes</span>()); <span class="comment">//打个断言</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动写下标，更新写位置（数据写入后调用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    writePos_ += len; <span class="comment">// 写指针后移len字节 注意：可能会有疑问，这里就不怕越界吗？其实一般情况下，要写入输入之前会调用EnsureWriteable，再写再移动指针，但是说实话还是程序控制比较好，现在的方法全靠程序员自觉（而且这还是个public方法）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取len长度，移动读下标 消费数据：移动读指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    readPos_ += len; <span class="comment">//和HasWritten同理，如果跟着做完有时间的话，可以尝试一下重构一下代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费数据直到指定地址，这里没说要读哈，就是相当于把end之前的可读的区域都放弃掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end); <span class="comment">//你看这这里就打断言了， &amp;buffer_[readPos_] 要小于 end</span></span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>()); <span class="comment">// end指针 - 读指针 长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出所有数据，buffer归零，读写下标归零,在别的函数中会用到</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());  <span class="comment">// 覆盖原本数据 清空数据 可选，因为readPos_ = writePos_ = 0; 其实就代表归0了，里面的内容就相当于全部舍弃了</span></span><br><span class="line">    readPos_ = writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  取出剩余可读的str 取出所有可读数据并转为字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(),ReadableBytes())</span></span>; <span class="comment">//string字符串构造，记得看了解一下字符串</span></span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前写位置常量指针</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前写位置指针</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加str到缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);                       <span class="comment">// 确保可写的长度</span></span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());    <span class="comment">// 将str放到写下标开始的地方</span></span><br><span class="line">    <span class="built_in">HasWritten</span>(len);                            <span class="comment">// 移动写下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加字符串到缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型，强制转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加另一个缓冲区的可读数据到当前缓冲区(不是合并俩缓冲区哈，就相当与把buff之中的可读数据写在现在这个缓冲区里面哈，别搞错了)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区起始地址（内部使用）</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区起始地址（常量版本）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len)&#123;  <span class="comment">// C + A 区域 都无法满足 len大小的数据了，这时候就要扩容了</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>); <span class="comment">//  扩容至所需大小+1（保险）</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//合并空间</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>()); <span class="comment">//将缓冲区中从readPos_到writePos_之间的数据复制到缓冲区的起始位置</span></span><br><span class="line">        readPos_ = <span class="number">0</span>;          <span class="comment">// 读指针归零</span></span><br><span class="line">        writePos_ = readable;  <span class="comment">// 写指针指向原数据末尾</span></span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>()); <span class="comment">// 确保数据完整性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个最为重要的函数，放在最后来写</span></span><br><span class="line"><span class="comment">// 将buffer中可读的区域写入fd中</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span>* Errno)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd,<span class="built_in">Peek</span>(),<span class="built_in">ReadableBytes</span>()); <span class="comment">//将读区域内部的所有的东西都写进fd之中，一般情况下都不会出错，也就是 len 会= ReadableBytes()，但是也有可能会出错</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        *Errno = errno;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Retrieve</span>(len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将fd的内容读到缓冲区，即writable的位置</span></span><br><span class="line"><span class="comment">// 这里要注意哈，看咱们前面的函数，一般情况下，咱们会调用咱们的Append函数来向buffer里面写东西</span></span><br><span class="line"><span class="comment">// 但是碰到一个问题，如何判断咱们要写入的长度，这取决于fd要传给咱们多少东西，咱们现在也不知道，要传给咱多少</span></span><br><span class="line"><span class="comment">// 因此这里要使用 分散读写 通过定义一个 struct iovec 数组接收, struct iovec iov[2]; ssize_t len = readv(fd, iov, 2); 会优先向iov[0]之中写,如果不够写的话,会再向iov[1]写</span></span><br><span class="line"><span class="comment">// struct iovec &#123;</span></span><br><span class="line"><span class="comment">//     void  *iov_base;  // 指向缓冲区的指针</span></span><br><span class="line"><span class="comment">//     size_t iov_len;   // 缓冲区的长度</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span>* Errno)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];   <span class="comment">// 栈区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">size_t</span> writeable = <span class="built_in">WritableBytes</span>(); <span class="comment">// 获取现在缓冲区内部还有多少可写的空间</span></span><br><span class="line">    <span class="comment">// 分散读,保证数据能够读完</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginWrite</span>();</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writeable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff); <span class="comment">//65535</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>); <span class="comment">//开始读</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123; <span class="comment">// 出现错误了</span></span><br><span class="line">        *Errno = errno;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writeable)&#123; <span class="comment">//说明咱们基础的缓存空间是足够存储的,没有使用char buff[65535]; </span></span><br><span class="line">        writePos_ += len;   <span class="comment">// 直接移动写下标 //你看你看,我就说HasWritten函数有问题,这里估计作者自己都忘记了有这么一个函数</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 说明咱们的空间是不够的(同时说明了,咱们的buffer_空间内部已经填满了)</span></span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>(); <span class="comment">// 写区写满了,下标移到最后</span></span><br><span class="line">        <span class="built_in">Append</span>(buff, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len - writeable)); <span class="comment">// 剩余的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>日志系统</p><p>1.使用单例模式来实现，目的是保证一个类只有一个实例，并提供一个他的全局访问点，该实例被所有程序模块共享。</p><p>2.异步日志，日志写入的时候需要写入文件，因此需要进行IO操作，IO操作如果放在主线程的话就会很大的阻塞线程，因此需要再创建一个线程来进行这个IO操作</p><p>3.日志的分级与分文件</p><ul><li>Debug，调试代码时的输出，在系统实际运行时，一般不使用。</li><li>Warn，这种警告与调试时终端的warning类似，同样是调试代码时使用。</li><li>Info，报告系统当前的状态，当前执行的流程或接收的信息等。</li><li>Erro，输出系统的错误信息</li></ul><p>4.分文件情况</p><ul><li>按天分，日志写入前会判断当前today是否为创建日志的时间，若为创建日志时间，则写入日志，否则按当前时间创建新的log文件，更新创建时间和行数。</li><li>按行分，日志写入前会判断行数是否超过最大行限制，若超过，则在当前日志的末尾加lineCount &#x2F; MAX_LOG_LINES为后缀创建新的log文件。</li></ul><h3 id="blockqueue"><a href="#blockqueue" class="headerlink" title="blockqueue"></a>blockqueue</h3><p>这是一个安全队列，咱们普通的队列在进行多线程操作的时候会出现互斥，必须得先加锁，再进行队列操作才可以，现在将这些加锁的操作封装到队列之中，这就是安全队列。在其他多线程的地方调用安全队列的方法的的时候不需要加锁，因为内部已经加锁了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;T&gt; deq_;                      <span class="comment">// 底层双端队列容器</span></span><br><span class="line">    mutex mtx_;                         <span class="comment">// 互斥锁，保护队列操作</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                      <span class="comment">// 关闭标志</span></span><br><span class="line">    <span class="type">size_t</span> capacity_;                   <span class="comment">// 队列关闭标志</span></span><br><span class="line">    condition_variable condConsumer_;   <span class="comment">// 消费者条件变量（队列空时等待）</span></span><br><span class="line">    condition_variable condProducer_;   <span class="comment">// 生产者条件变量（队列满时等待）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockQueue</span><span class="params">(<span class="type">size_t</span> maxsize = <span class="number">1000</span>)</span></span>;   <span class="comment">// 构造函数，设置队列容量</span></span><br><span class="line">    ~<span class="built_in">BlockQueue</span>();                                <span class="comment">// 析构函数，关闭队列并释放资源</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;                                 <span class="comment">// 判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;                                  <span class="comment">// 判满</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;                <span class="comment">// 在队尾添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;               <span class="comment">// 在队头添加元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;                            <span class="comment">// 弹出的任务放入item</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> timeout)</span></span>;               <span class="comment">// 带超时的弹出操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                                 <span class="comment">// 清空队列</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;                                    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;                                     <span class="comment">// 获取队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;                            <span class="comment">// 获取队列容量</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;                                <span class="comment">// 获取当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;                                 <span class="comment">// 唤醒一个消费者线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                 <span class="comment">// 关闭队列，唤醒所有线程</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数</span></span><br><span class="line"><span class="comment"> * @param maxsize 队列最大容量，必须大于0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::<span class="built_in">BlockQueue</span>(<span class="type">size_t</span> maxsize):<span class="built_in">capacity_</span>(maxsize)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(maxsize &gt; <span class="number">0</span>);        <span class="comment">// 确保容量合法</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;           <span class="comment">// 初始化关闭标志为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数：调用Close清理资源 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::~<span class="built_in">BlockQueue</span>()&#123;  <span class="comment">// 析构函数：调用Close清理资源</span></span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空队列 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭队列：清空队列并唤醒所有等待线程 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">Close</span>()&#123;</span><br><span class="line">    <span class="built_in">clear</span>();  <span class="comment">//内部加锁了，咱们这里就不用加锁了</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有等待的消费者和生产者线程</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">empty</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否已满 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">full</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;<span class="comment">// 当前大小 &gt;= 容量即为满</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在队尾插入元素（生产者调用）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="comment">// 注意，条件变量需要搭配unique_lock</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    condProducer_.<span class="built_in">wait</span>(locker,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;deq_.<span class="built_in">size</span>() &gt;= <span class="keyword">this</span>-&gt;capacity_)||<span class="keyword">this</span>-&gt;isClose_;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClose_) &#123; <span class="comment">//关闭就抛出异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);               <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知一个消费者可以取数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在队头插入元素（生产者调用）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="comment">// 注意，条件变量需要搭配unique_lock</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    condProducer_.<span class="built_in">wait</span>(locker,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;deq_.<span class="built_in">size</span>() &gt;= <span class="keyword">this</span>-&gt;capacity_)||<span class="keyword">this</span>-&gt;isClose_;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClose_) &#123; <span class="comment">//关闭就return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);               <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知一个消费者可以取数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弹出队头元素（消费者调用，阻塞）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;    <span class="comment">// 必须使用unique_lock以便操作条件变量</span></span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>()) &#123;               <span class="comment">// 队列空则等待</span></span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);     <span class="comment">// 挂起消费者，等待队列非空信号</span></span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;                   <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();                <span class="comment">// 取队头元素</span></span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知生产者有空位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弹出队头元素（支持超时等待）</span></span><br><span class="line"><span class="comment"> * @param timeout 超时时间（秒）</span></span><br><span class="line"><span class="comment"> * @return 超时或队列关闭返回false，否则true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;   <span class="comment">// 必须使用unique_lock以便操作条件变量</span></span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout)) </span><br><span class="line">                == std::cv_status::timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 超时返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;                      <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队头元素（线程安全）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队尾元素（线程安全）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列容量 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前元素数量 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒一个消费者线程（常用于手动触发处理）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="log-1"><a href="#log-1" class="headerlink" title="log"></a>log</h3><p>(下面是我复现的时候的一些想法)</p><p>日志系统对整个项目来说非常重要，涉及到一些错误调试操作</p><ul><li><p>单例模式：确保整个程序中只有一个日志实例，在这样一个“庞大”的系统之中，无法避免的的要全局的访问日志系统，如果使用多个日志实例的话，那么就需要考虑很多很多的同步的问题，因此单例模式是最优解</p><ul><li>这里要注意，这个项目是C++11实现的 C++11标准 （§6.7 [stmt.dcl] 第4段） 如果控制流在变量初始化时并发进入声明，并发线程必须等待初始化完成。 也就是说 静态局部变量 是线程安全的</li></ul></li><li><p>同步与异步：这里又涉及到了同步与异步的概念，这个可以搜索了解一下，这里简单来说，就是：同步，在写入文件的时候直接在主线程里面写；异步：重新申请一个线程，在线程里面写，不会阻塞主线程</p><ul><li>咱们来理一下整个流程</li><li>1.向外接口是 LOG_INFO （以LOG_INFO为例哈，其他的还有LOG_DEBUG啥的）看下面的宏定义。首先会获取实例，然后经过判断调用write</li><li>2.在写的时候先判断一下对应的文件(比如日期，比如文件的行数是不是超过最大的行数)，如果有问题的话会重新生成一个新的日志文件</li><li>3.然后会组合日志的语句，存储到buffer之中。比如：一行日志：2025-04-11 10:58:46.397812 [info] : Client<a href="127.0.0.1:59563">23</a> in, userCount:6 这里需要生成前面的2025-04-11 10:58:46.397812 [info]还要组合后面的内容</li><li>4.最后才是写进去，这里要注意，写的时候就涉及到同步和异步了<ul><li>同步：直接在主线程里面写就行了，也就是说直接写，并不需要啥多余的操作，因此这里的IO操作就会对主线程造成阻塞</li><li>异步：通过申请一个新的线程来写。具体操作：设置一个阻塞队列，典型的生产者-消费者模型。咱们申请的线程会一直读取这个队列里面的的内容(也就是pop)，如果为空的话就会线程就会阻塞，但是只要有值push进去的话，就会重新唤醒线程<ul><li>因此，在异步的情况下，直接将buffer之中的内容push到队列之中就行了，push之后会唤醒线程从而执行写的操作</li></ul></li></ul></li></ul></li><li><p>还有一个小点，就是可变参数，这个不解释其实也能的懂，但是这边还是记录一下把</p><ul><li>正常的调用比如：LOG_INFO(“11111”) 这种是没有可变参数的</li><li>带有可变参数的比如：LOG_INFO(“%s,%s,%d”,str1,str2,int1) 这样就是有可变参数的</li></ul></li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>           <span class="comment">// 可变参数支持（va_start, va_end）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">// 目录操作（mkdir）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 常量定义  static const 可以直接在里面初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>; <span class="comment">// 日志文件最长文件名</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>; <span class="comment">// 日志最长名字</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;  <span class="comment">// 日志文件内的最长日志条数</span></span><br><span class="line">    <span class="comment">// 日志文件相关参数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;   <span class="comment">// 日志文件存储路径</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_; <span class="comment">// 日志文件后缀名</span></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;      <span class="comment">// 最大日志行数</span></span><br><span class="line">    <span class="comment">// 运行时状态</span></span><br><span class="line">    <span class="type">int</span> lineCount_;      <span class="comment">// 当前日志文件行数计数器</span></span><br><span class="line">    <span class="type">int</span> toDay_;          <span class="comment">// 记录当前日期（用于日志滚动）</span></span><br><span class="line">    <span class="type">bool</span> isOpen_;        <span class="comment">// 日志系统是否开启标志</span></span><br><span class="line">    <span class="comment">// 缓冲区与日志级别</span></span><br><span class="line">    Buffer buff_;        <span class="comment">// 输出的内容，缓冲区</span></span><br><span class="line">    <span class="type">int</span> level_;          <span class="comment">// 日志等级</span></span><br><span class="line">    <span class="type">bool</span> isAsync_;       <span class="comment">// 是否开启异步日志</span></span><br><span class="line">    <span class="comment">// 文件与线程相关</span></span><br><span class="line">    FILE* fp_;           <span class="comment">// 打开log的文件指针</span></span><br><span class="line">    std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; deque_; <span class="comment">// 阻塞队列（用于异步模式） //注意哈，这里设置的是一个智能指针因此用的时候注意一下，这是一个指针</span></span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;       <span class="comment">// 异步写线程 指针，同队列理</span></span><br><span class="line">    std::mutex mtx_;                                 <span class="comment">// 互斥锁（保证线程安全）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造与析构</span></span><br><span class="line">    <span class="built_in">Log</span>();                                          <span class="comment">// 构造函数（私有，单例模式）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;           <span class="comment">// 添加日志级别前缀</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();                                 <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;                             <span class="comment">// 异步写日志的实际执行方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化日志系统</span></span><br><span class="line">    <span class="comment">// 参数：level-日志级别, path-日志路径, suffix-日志后缀, maxQueueCapacity-阻塞队列容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>, <span class="type">const</span> <span class="type">char</span>* suffix = <span class="string">&quot;.log&quot;</span>,<span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;       <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>; <span class="comment">// 异步写日志公有方法，调用私有方法asyncWrite 异步写日志线程入口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写日志方法（核心方法</span></span><br><span class="line">    <span class="comment">// 参数：level-日志级别, format-格式化字符串, ...-可变参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span>;  <span class="comment">// 将输出内容按照标准格式整理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;                                  <span class="comment">// 刷新缓冲区到文件</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;                                <span class="comment">// 获取当前日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;                      <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isOpen_; &#125;              <span class="comment">// 判断日志系统是否开启</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 日志宏定义（对外接口） ********************/</span></span><br><span class="line"><span class="comment">// 基础日志宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个宏定义，主要用于不同类型的日志输出，也是外部使用日志的接口</span></span><br><span class="line"><span class="comment">// ...表示可变参数，__VA_ARGS__就是将...的值复制到这里</span></span><br><span class="line"><span class="comment">// 前面加上##的作用是：当可变参数的个数为0时，这里的##可以把把前面多余的&quot;,&quot;去掉,否则会编译出错。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">Log::<span class="built_in">Log</span>()&#123;</span><br><span class="line">    fp_ = <span class="literal">nullptr</span>;           <span class="comment">// 初始化文件指针为空</span></span><br><span class="line">    deque_ = <span class="literal">nullptr</span>;        <span class="comment">// 初始化阻塞队列为空</span></span><br><span class="line">    writeThread_ = <span class="literal">nullptr</span>;  <span class="comment">// 初始化写线程为空</span></span><br><span class="line">    lineCount_ = <span class="number">0</span>;          <span class="comment">// 初始化行计数器 </span></span><br><span class="line">    toDay_ = <span class="number">0</span>;              <span class="comment">// 初始化当前日期</span></span><br><span class="line">    isAsync_ = <span class="literal">false</span>;        <span class="comment">// 默认同步模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Log::~<span class="built_in">Log</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">empty</span>())&#123;</span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>();      <span class="comment">// 唤醒消费者，处理掉剩下的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    deque_-&gt;<span class="built_in">Close</span>();          <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="keyword">if</span>(writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>())&#123; <span class="comment">// 确保线程存在且可join</span></span><br><span class="line">        writeThread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp_)&#123;                  <span class="comment">// 冲洗文件缓冲区，关闭文件描述符</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">flush</span>();              <span class="comment">// 清空缓冲区中的数据</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);          <span class="comment">// 关闭日志文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞队列消费者，开始写日志 刷新缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isAsync_)&#123;         <span class="comment">// 只有异步日志才会用到deque</span></span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(fp_);           <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉模式 局部静态变量法（这种方法不需要加锁和解锁操作）</span></span><br><span class="line"><span class="function">Log* <span class="title">Log::Instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Log log;  <span class="comment">// C++11保证静态局部变量线程安全</span></span><br><span class="line">    <span class="keyword">return</span> &amp;log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步日志的写线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();   <span class="comment">// 调用实际写方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写线程真正的执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">pop</span>(str))&#123; <span class="comment">// 从队列获取日志字符串 //阻塞的地方在这里 writeThread_ 相当于deque_的消费者，当没有数据的时候会阻塞</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;     <span class="comment">// 这里的加锁不是针对队列(安全队列会自己加锁)哈，针对的是 fp_</span></span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);            <span class="comment">// 写入文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化日志系统</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix, <span class="type">int</span> maxQueCapacity)</span> </span>&#123;</span><br><span class="line">    isOpen_ = <span class="literal">true</span>;       <span class="comment">// 标记日志系统开启</span></span><br><span class="line">    level_ = level;       <span class="comment">// 设置日志级别</span></span><br><span class="line">    path_ = path;         <span class="comment">// 日志存储路径</span></span><br><span class="line">    suffix_ = suffix;     <span class="comment">// 文件后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(maxQueCapacity)&#123;   <span class="comment">// 异步方式 队列容量&gt;0启用异步</span></span><br><span class="line">        isAsync_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!deque_)&#123;      <span class="comment">// 为空则创建一个</span></span><br><span class="line">            unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; <span class="built_in">newQue</span>(<span class="keyword">new</span> BlockQueue&lt;std::string&gt;);</span><br><span class="line">            <span class="comment">// 因为unique_ptr不支持普通的拷贝或赋值操作,所以采用move</span></span><br><span class="line">            <span class="comment">// 将动态申请的内存权给deque，newDeque被释放</span></span><br><span class="line">            deque_ = <span class="built_in">move</span>(newQue);</span><br><span class="line">            <span class="comment">// 启动写线程</span></span><br><span class="line">            <span class="function">unique_ptr&lt;thread&gt;  <span class="title">newThread</span><span class="params">(<span class="keyword">new</span> thread(FlushLogThread))</span></span>;</span><br><span class="line">            writeThread_ = <span class="built_in">move</span>(newThread); <span class="comment">//注意这里哈，刚开始写的时候是不是有些疑问呀，就是这个时候已经对writeThread_进行初始化了，该线程已经执行了，但是他执行的啥呢？刚开始啥也么没有应当会阻塞的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置行计数器</span></span><br><span class="line">    lineCount_ = <span class="number">0</span>;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间处理（日志文件按日期滚动）</span></span><br><span class="line">    <span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建日志文件名</span></span><br><span class="line">    path_ = path;     <span class="comment">//和前面重复了，原作者没注意估计</span></span><br><span class="line">    suffix_ = suffix;</span><br><span class="line">    <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, </span><br><span class="line">        path_, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);</span><br><span class="line">    toDay_ = t.tm_mday;      <span class="comment">// 记录当前日期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作（加锁保证线程安全）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="keyword">if</span>(fp_) &#123;              <span class="comment">// 处理旧文件指针</span></span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">            <span class="built_in">fclose</span>(fp_);</span><br><span class="line">        &#125;</span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>); <span class="comment">// 追加模式打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(fp_ == <span class="literal">nullptr</span>)&#123;         <span class="comment">// 文件不存在时创建目录</span></span><br><span class="line">            <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);     <span class="comment">// 创建日志目录（rwx权限）</span></span><br><span class="line">            fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>); <span class="comment">// 生成目录文件（最大权限）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);  <span class="comment">// 确保文件打开成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心写日志方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);    <span class="comment">// 获取精确时间（微秒级）</span></span><br><span class="line">    <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    va_list vaList;                <span class="comment">// 可变参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志文件滚动判断 */</span></span><br><span class="line">    <span class="comment">// 条件1：日期变化 或 条件2：行数超过限制</span></span><br><span class="line">    <span class="keyword">if</span>(toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_  %  MAX_LINES == <span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        locker.<span class="built_in">unlock</span>();              <span class="comment">// 临时释放锁，避免阻塞其他线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个时候得重新创建一个新的文件了</span></span><br><span class="line">        <span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 时间戳部分（yyyy_mm_dd）</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday); <span class="comment">// 目前的精准事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(toDay_!=t.tm_mday)&#123;  <span class="comment">// 事件部匹配</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);  <span class="comment">//为啥要减72？</span></span><br><span class="line">            toDay_ = t.tm_mday;      <span class="comment">// 更新日期记录</span></span><br><span class="line">            lineCount_ = <span class="number">0</span>;          <span class="comment">// 重置行计数器</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 行数超了</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_  / MAX_LINES), suffix_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        locker.<span class="built_in">lock</span>();  <span class="comment">// 重新加锁</span></span><br><span class="line">        <span class="built_in">flush</span>();        <span class="comment">// 确保数据写入当前文件</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);    </span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(newFile, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 创建新日志文件</span></span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在buffer内生成一条对应的日志信息</span></span><br><span class="line">    <span class="comment">// 说实话，我说实话，我觉得这里的buff很没必要</span></span><br><span class="line">    <span class="comment">// 这是一条完整info log 2025-04-11 10:58:52.272179 [info] : Verify name:111 pwd:111 先看这个的话可能会好理解一些</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        lineCount_++; <span class="comment">// 行号递增</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">        t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">        t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);  <span class="comment">//这是一条完整info log 2025-04-11 10:58:52.272179 [info] : Verify name:111 pwd:111</span></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(n);           <span class="comment">// 移动写指针</span></span><br><span class="line">        <span class="built_in">AppendLogLevelTitle_</span>(level);    <span class="comment">// 添加日志级别前缀 [info]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理可变参数 注意哈，这里的可变参数，刚开始可能会不太明白，但是你看一下上面的int n = snprintf(buff_.BeginWrite(), 128, &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;,</span></span><br><span class="line">        <span class="comment">// 如果传递的是 format = &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot; vaList =         t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec</span></span><br><span class="line">        <span class="comment">// 这样是不是就明白了</span></span><br><span class="line">        <span class="built_in">va_start</span>(vaList, format);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);</span><br><span class="line">        <span class="built_in">va_end</span>(vaList);</span><br><span class="line"></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(m);      <span class="comment">// 更新缓冲区写位置</span></span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);  <span class="comment">// 添加换行和结束符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据模式选择写入方式</span></span><br><span class="line">        <span class="keyword">if</span>(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>())&#123;  <span class="comment">// 异步方式（加入阻塞队列中，等待写线程读取日志信息）</span></span><br><span class="line">            deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 同步方式（直接向文件中写入日志信息）</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);   <span class="comment">// 同步就直接写入文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加日志等级</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(level) &#123; <span class="comment">// 不同级别添加不同前缀</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前日志级别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>1.线程池</p><p>我在博客 <a href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/</a> 里面也做了一些介绍，现在再介绍一下</p><p>线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程</p><p>2.数据库连接池</p><p>这里仿照了线程池的一些思路</p><p>服务器在运行的时候肯定不只一个用户连接，每个用户连接的时候都需要进行数据库操作，在连接的时候要对数据库连接进行初始化，那样就非常的耗时，因此引入了 数据库连接池</p><ul><li>先进行数据库连接，把连接好的标识放入一个池子里面（这里是queue），然后用户来的时候只需要把这些连接好的标识非配给他就好了</li></ul><p>因此：数据库连接池就需要使用 <strong>单例模式</strong> 了，为什么？</p><ul><li>整个系统就只需要一个池子，不需要多个池子，也就是说不需要多个实例</li><li>如果想要更多的池子的话，把的第一个池子扩大一些不就好了吗</li><li>因此单例模式是最为合适的</li></ul><p>3.RAII</p><p>这个就是说，由系统来管理资源的申请和释放。智能指针就是用这个来思路来实现的，咱们不需要手动释放资源了，系统会帮忙管理。</p><p>再说白了：其实就是再单独设计一个class，用来申请资源，比如在构造的时候new 一个 地址空间，在析构的时候delete一下，设计一个向外的接口，可以获取这个地址空间的指针。那么咱们在用的时候就不需要考虑这个地址空间的释放问题了，因为随着这个class生命周期的结束，就会自动释放这个空间。</p><p>这个可以看一下智能指针的实现的思路就理解了</p><p>我在这里介绍了 <a href="https://blog.zqzhang2025.com/2025/04/13/C++pointer/">https://blog.zqzhang2025.com/2025/04/13/C++pointer/</a></p><h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>这里的实现比较简单了，因为task只需要接收void类型的函数，就是说没有返回值的函数，我之前实现的theadpool(<a href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/)%E6%98%AF%E7%BB%BC%E5%90%88%E8%80%83%E8%99%91%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%AD%89%E9%97%AE%E9%A2%98%E7%9A%84">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/)是综合考虑到返回值和可变参数等问题的</a></p><p>这里的比较简单</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用一个结构体封装起来，方便调用  其实我感觉没必要，CLASS 已经有了很好的封装性了 再说了，你一个私有的，你让谁调用，你的友元吗</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span>&#123;</span><br><span class="line">        std::mutex mtx_;</span><br><span class="line">        std::condition_variable cond_;</span><br><span class="line">        <span class="type">bool</span> isClosed;</span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;  <span class="comment">// 任务队列，函数类型为void()</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_; <span class="comment">//这个意思就是用智能指针管理Pool然后咱们不用手动释放了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数（C++11特性）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动构造函数（默认实现）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/* 主要构造函数</span></span><br><span class="line"><span class="comment">     * @param threadCount: 线程数量，默认为8</span></span><br><span class="line"><span class="comment">     * @note 使用make_shared创建共享资源池，保证内存连续性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尽量用make_shared代替new，如果通过new再传递给shared_ptr，内存是不连续的，会造成内存碎片化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">int</span> threadCount = <span class="number">8</span>)</span> : pool_(std::make_shared&lt;Pool&gt;()) &#123;</span> <span class="comment">// make_shared:传递右值，功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr</span></span><br><span class="line">        <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);                  <span class="comment">// 校验线程数量合法性</span></span><br><span class="line">        <span class="comment">// 创建指定数量的工作线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            std::<span class="built_in">thread</span>([<span class="keyword">this</span>]&#123; <span class="comment">//注意哈，这里一定要把this传进去</span></span><br><span class="line">                std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool_-&gt;mtx_);    <span class="comment">// 自动加锁</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">// 任务队列非空时处理任务</span></span><br><span class="line">                    <span class="keyword">if</span>(!pool_-&gt;tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="comment">// 获取队列首个任务（使用移动语义转移所有权） 左值变右值,资产转移</span></span><br><span class="line">                        <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool_-&gt;tasks.<span class="built_in">front</span>());    </span><br><span class="line">                        pool_-&gt;tasks.<span class="built_in">pop</span>(); <span class="comment">// 移除队列元素</span></span><br><span class="line">                        locker.<span class="built_in">unlock</span>();    <span class="comment">// 因为已经把任务取出来了，所以可以提前解锁了</span></span><br><span class="line">                        <span class="built_in">task</span>();             <span class="comment">// 执行任务</span></span><br><span class="line">                        locker.<span class="built_in">lock</span>();      <span class="comment">// 马上又要取任务了，上锁</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pool_-&gt;isClosed)&#123; <span class="comment">// 池关闭时退出线程</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 队列空时进入等待状态</span></span><br><span class="line">                        pool_-&gt;cond_.<span class="built_in">wait</span>(locker); <span class="comment">// 等待,如果任务来了就notify的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>(); <span class="comment">// 分离线程（线程生命周期与主线程无关）  其实更好的操作是用一个vector来管理线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构函数 */</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool_)&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx_)</span></span>;</span><br><span class="line">            pool_-&gt;isClosed = <span class="literal">true</span>; <span class="comment">// 设置关闭标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond_.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加任务到队列</span></span><br><span class="line"><span class="comment">     * @tparam T: 可调用对象类型（自动推导）</span></span><br><span class="line"><span class="comment">     * @param task: 要添加的任务（通用引用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(T&amp;&amp; task)</span></span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx_)</span></span>; <span class="comment">//上锁</span></span><br><span class="line">        <span class="comment">// 使用完美转发保持参数的值类别</span></span><br><span class="line">        pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(task));</span><br><span class="line">        pool_-&gt;cond_.<span class="built_in">notify_one</span>();                       <span class="comment">// 通知一个等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="sqlconnpool"><a href="#sqlconnpool" class="headerlink" title="sqlconnpool"></a>sqlconnpool</h3><p>在看这个之前记得先了解一下C++数据库的基本操作哈，其实就是几个函数，挺简单了，去搜一下大概10分钟就业能了解了。</p><p>数据库的连接 数据库的查询 查询结果获取 数据库的插入 等</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据库连接池类（单例模式） */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_CONN_; <span class="comment">//最大连接数</span></span><br><span class="line">    std::queue&lt;MYSQL* &gt; connQue_; <span class="comment">//连接队列</span></span><br><span class="line">    std::mutex mtx_;  <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> semId_;     <span class="comment">// 信号量（控制并发访问） PV操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">SqlConnPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 析构时自动关闭</span></span><br><span class="line">    ~<span class="built_in">SqlConnPool</span>() &#123; <span class="built_in">ClosePool</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例（C++11线程安全实现）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SqlConnPool* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取一个数据库连接</span></span><br><span class="line">    <span class="function">MYSQL* <span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 释放连接回池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL* conn)</span></span>;</span><br><span class="line">    <span class="comment">// 获取空闲连接数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 初始化连接池</span></span><br><span class="line"><span class="comment">     * @param host:     数据库主机地址</span></span><br><span class="line"><span class="comment">     * @param port:     端口号</span></span><br><span class="line"><span class="comment">     * @param user:     用户名</span></span><br><span class="line"><span class="comment">     * @param pwd:      密码</span></span><br><span class="line"><span class="comment">     * @param dbName:   数据库名</span></span><br><span class="line"><span class="comment">     * @param connSize: 连接池大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">uint16_t</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源在对象构造初始化 资源在对象析构时释放  RAII数据库连接管理类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *sql_;               <span class="comment">// 持有的数据库连接</span></span><br><span class="line">    SqlConnPool* connpool_;    <span class="comment">// 关联的连接池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造函数获取连接</span></span><br><span class="line"><span class="comment">     * @param sql:     输出参数，用于返回获得的连接</span></span><br><span class="line"><span class="comment">     * @param connpool: 连接池实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool *connpool)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(connpool);</span><br><span class="line">        *sql = connpool-&gt;<span class="built_in">GetConn</span>();   <span class="comment">// 从池中获取连接</span></span><br><span class="line">        sql_ = *sql;                  <span class="comment">// 保存连接指针</span></span><br><span class="line">        connpool_ = connpool;         <span class="comment">// 保存连接池引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构时自动释放连接</span></span><br><span class="line">    ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(sql_) &#123; connpool_-&gt;<span class="built_in">FreeConn</span>(sql_); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SQLCONNPOOL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例实例（线程安全）</span></span><br><span class="line"><span class="function">SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> SqlConnPool pool; <span class="comment">// C++11保证静态变量初始化线程安全</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数据库连接池</span></span><br><span class="line"><span class="comment"> * @param host     : 数据库主机名/IP</span></span><br><span class="line"><span class="comment"> * @param port     : 端口号（无符号16位）</span></span><br><span class="line"><span class="comment"> * @param user     : 用户名</span></span><br><span class="line"><span class="comment"> * @param pwd      : 密码</span></span><br><span class="line"><span class="comment"> * @param dbName   : 数据库名称</span></span><br><span class="line"><span class="comment"> * @param connSize : 连接池容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">uint16_t</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>); <span class="comment">// connSize 连接池容量 得大于 0 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;connSize;i++)&#123;   <span class="comment">// 创建连接</span></span><br><span class="line">        MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">        conn = <span class="built_in">mysql_init</span>(conn);   <span class="comment">// 初始化MYSQL结构体</span></span><br><span class="line">        <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);     <span class="comment">// 记录错误日志</span></span><br><span class="line">            <span class="built_in">assert</span>(conn);                       <span class="comment">// 调试模式终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立实际连接</span></span><br><span class="line">        conn = <span class="built_in">mysql_real_connect</span>(conn, host, user, pwd, dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);   <span class="comment">// 连接失败记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        connQue_.<span class="built_in">emplace</span>(conn);   <span class="comment">// 将连接加入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    MAX_CONN_ = connSize;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);  <span class="comment">// 初始化信号量（进程间不共享，初始值为MAX_CONN_）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取数据库连接</span></span><br><span class="line"><span class="comment"> * @return: 可用MYSQL连接指针，无可用时返回nullptr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);    <span class="comment">// 记录警告日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;                   <span class="comment">// 无可用时返回nullptr </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);                    <span class="comment">// P操作（信号量-1），阻塞直到&gt;0</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;       <span class="comment">// 加锁</span></span><br><span class="line">    conn = connQue_.<span class="built_in">front</span>();              <span class="comment">// 获取队首连接</span></span><br><span class="line">    connQue_.<span class="built_in">pop</span>();                       <span class="comment">// 移除队列元素</span></span><br><span class="line">    <span class="keyword">return</span> conn;                          <span class="comment">// 可用MYSQL连接指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放连接回池（实际上没有释放，只是放到池子里面去了）</span></span><br><span class="line"><span class="comment"> * @param conn: 要释放的数据库连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* conn)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(conn);                       <span class="comment">// 确保连接有效</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    connQue_.<span class="built_in">push</span>(conn);                <span class="comment">// 将连接放回队列</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);                  <span class="comment">// V操作（信号量+1）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接池（释放所有连接）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!connQue_.<span class="built_in">empty</span>()) &#123;    <span class="comment">// 关闭数据库连接</span></span><br><span class="line">        <span class="keyword">auto</span> conn = connQue_.<span class="built_in">front</span>(); </span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">mysql_close</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_library_end</span>();  <span class="comment">// 清理MySQL库资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前空闲连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>这里主要是针对HTTP的一些操作，注意学习一下HTTP报本的一些基本结构，包括请求报文以及响应报文</p><p>我在 <a href="https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/">https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/</a> 里面做了一些基本介绍</p><p>在这里再说一下 报文结构</p><p><img src="/../0_images/tinyWebServer/3_HTTP%E6%8A%A5%E6%96%87.png" alt="alt text"></p><p>那么我们举个例子：</p><p>以下是百度的请求包</p><pre><code>&gt; GET / HTTP/1.1\r\n&gt; Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n&gt; Accept-Encoding: gzip, deflate, br\r\n&gt; Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n&gt; Connection: keep-alive\r\n&gt; Host: www.baidu.com\r\n&gt; Sec-Fetch-Dest: document\r\n&gt; Sec-Fetch-Mode: navigate\r\n&gt; Sec-Fetch-Site: none\r\n&gt; Sec-Fetch-User: ?1\r\n&gt; Upgrade-Insecure-Requests: 1\r\n&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.41 Safari/537.36 Edg/101.0.1210.32\r\n&gt; sec-ch-ua: &quot; Not A;Brand&quot;;v=“99”, “Chromium”;v=“101”, “Microsoft Edge”;v=“101”\r\n&gt; sec-ch-ua-mobile: ?0\r\n&gt; sec-ch-ua-platform: “Windows”\r\n</code></pre><p>上面只包括请求行、请求头和空行，请求数据为空。请求方法是GET，协议版本是HTTP&#x2F;1.1；请求头是键值对的形式。（注意哈，上面的\r\n是我自己添加的哈，去掉才是正常的，我添加上只是为了表示，每一行的结尾是\r\n）</p><p>响应报文：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT\r\n</span><br><span class="line">Content-Type: text/html; charset=UTF-8\r\n</span><br><span class="line">\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--body goes here--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="httprequest"><a href="#httprequest" class="headerlink" title="httprequest"></a>httprequest</h3><p>这个class主要是针对http请求的，所以看这部分代码之前务必要先了解HTTP请求，了解请求报文的基本结构</p><p>注意这里不做逻辑处理哈，比如一个get请求一个页面，这里只是找到这个html，不会返回给客户，只有post的登陆和注册会在这做逻辑处理，但是也是只处理，相当于处理出来一个结果，保存下来。到这里就这个class的任务就结束了，剩下的响应就交给httpresponse了</p><p>这里有个很重要的概念：有限状态机</p><p>我们再来看一下请求报文。第一行为请求行，往后为请求头，再后面就是请求数据了</p><p>因此一般是按照顺序来解析这个请求报文</p><ul><li>先解析请求行 获取 请求方法，版本号 以及请求的url等</li><li>再解析请求头</li><li>最后看有没有请求体，有的话就需要解析了</li></ul><p>因此这个有限状态机就是这样的：</p><p><img src="/../0_images/tinyWebServer/4_%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="alt text"></p><p>来看一下代码吧：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_REQUEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_REQUEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span>          <span class="comment">// 正则表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>        <span class="comment">// 错误号处理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span>  <span class="comment">//mysql</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义HTTP解析状态机的状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PARSE_STATE</span> &#123;</span><br><span class="line">        REQUEST_LINE,  <span class="comment">// 正在解析请求行（如 GET / HTTP/1.1）</span></span><br><span class="line">        HEADERS,       <span class="comment">// 正在解析请求头部</span></span><br><span class="line">        BODY,          <span class="comment">// 正在解析请求体</span></span><br><span class="line">        FINISH,        <span class="comment">// 解析完成</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HttpRequest</span>() &#123; <span class="built_in">Init</span>(); &#125;  <span class="comment">// 构造函数初始化解析状态</span></span><br><span class="line">    ~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;  <span class="comment">// 默认析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;               <span class="comment">// 初始化/重置解析器状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;  <span class="comment">// 主解析函数，传入数据缓冲区</span></span><br><span class="line">    <span class="comment">// 获取解析结果的访问方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">path</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 获取请求路径（常量）</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;           <span class="comment">// 获取请求路径（可修改）</span></span><br><span class="line">    <span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">version</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 获取HTTP版本</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;   <span class="comment">// 获取POST表单值</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;           <span class="comment">// 重载版本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 判断是否保持连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;    <span class="comment">// 处理请求行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;         <span class="comment">// 处理请求头</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;           <span class="comment">// 处理请求体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;                                  <span class="comment">// 处理请求路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;                                  <span class="comment">// 处理Post事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;                        <span class="comment">// 从url种解析编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户验证（静态方法，与具体请求实例无关）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd, <span class="type">bool</span> isLogin)</span></span>;  <span class="comment">// 用户验证</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    PARSE_STATE state_;                        <span class="comment">// 当前解析状态</span></span><br><span class="line">    std::string method_,path_,version_,body_;  <span class="comment">// 请求方法（GET/POST等） 请求路径  HTTP版本（如HTTP/1.1） 请求体内容</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; header_;   <span class="comment">// 请求头键值对</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; post_;     <span class="comment">// POST表单键值对</span></span><br><span class="line">    <span class="comment">// 静态常量：预定义的HTML页面和标签</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DEFAULT_HTML;   <span class="comment">// 默认支持的页面</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFAULT_HTML_TAG; <span class="comment">// 页面类型标记</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ConverHex</span><span class="params">(<span class="type">char</span> ch)</span></span>;  <span class="comment">// 十六进制字符转换辅助函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 定义HTTP解析状态机的状态</span></span><br><span class="line"><span class="comment">// enum PARSE_STATE &#123;</span></span><br><span class="line"><span class="comment">//     REQUEST_LINE,  // 正在解析请求行（如 GET / HTTP/1.1）</span></span><br><span class="line"><span class="comment">//     HEADERS,       // 正在解析请求头部</span></span><br><span class="line"><span class="comment">//     BODY,          // 正在解析请求体</span></span><br><span class="line"><span class="comment">//     FINISH,        // 解析完成</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义的默认支持HTML页面（自动添加.html后缀）</span></span><br><span class="line"><span class="type">const</span> unordered_set&lt;string&gt; HttpRequest::DEFAULT_HTML &#123;</span><br><span class="line">    <span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;/video&quot;</span>, <span class="string">&quot;/picture&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面类型映射（登录页为1，注册页为0）</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, <span class="type">int</span>&gt; HttpRequest::DEFAULT_HTML_TAG &#123;</span><br><span class="line">    &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化HTTP请求解析器状态 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state_ = REQUEST_LINE;                    <span class="comment">// 初始状态为解析请求行</span></span><br><span class="line">    method_ = path_ = version_= body_ = <span class="string">&quot;&quot;</span>;   <span class="comment">// 清空请求方法 请求路径 HTTP版本  请求体</span></span><br><span class="line">    header_.<span class="built_in">clear</span>();    <span class="comment">// 清空请求头</span></span><br><span class="line">    post_.<span class="built_in">clear</span>();      <span class="comment">// 清空POST数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主解析函数（核心状态机）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> END[] = <span class="string">&quot;\r\n&quot;</span>;      <span class="comment">// HTTP换行符定义  HTTP每一行都是以 &quot;\r\n&quot; 结尾的 (请求体不是哈)</span></span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() == <span class="number">0</span>)&#123;  <span class="comment">// 没有可读的字节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取数据开始 当缓冲区有数据且未完成解析时循环处理</span></span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_!= FINISH)&#123;</span><br><span class="line">        <span class="comment">// 从buff中的读指针开始到读指针结束，这块区域是未读取得数据并去处&quot;\r\n&quot;，返回有效数据得行末指针</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineend = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), END, END<span class="number">+2</span>);  <span class="comment">//查找子串 返回第一个子串的首地址</span></span><br><span class="line">        <span class="function">string <span class="title">line</span><span class="params">(buff.Peek(),lineend)</span></span>; <span class="comment">// 提取当前行内容（不包含换行符）这样就是一个完整的报文行了</span></span><br><span class="line">        <span class="keyword">switch</span> (state_)&#123; <span class="comment">// 根据当前状态处理不同部分</span></span><br><span class="line">            <span class="keyword">case</span> REQUEST_LINE:&#123;</span><br><span class="line">                <span class="type">bool</span> res = <span class="built_in">ParseRequestLine_</span>(line); <span class="comment">//解析请求行，返返回解析结果</span></span><br><span class="line">                <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">ParsePath_</span>();   <span class="comment">// 处理请求路径（添加.html后缀等）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> HEADERS:&#123;</span><br><span class="line">                <span class="built_in">ParseHeader_</span>(line);  <span class="comment">// 解析头部字段</span></span><br><span class="line">                <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;  <span class="comment">// 说明是get请求，后面为\r\n 如果剩余数据&lt;=2字节（只剩\r\n），说明没有请求体，直接完成</span></span><br><span class="line">                    state_ = FINISH;   <span class="comment">// 提前结束</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BODY:&#123;</span><br><span class="line">                <span class="built_in">ParseBody_</span>(line);  <span class="comment">// 处理请求体</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理缓冲区：移动读指针到下一行开始</span></span><br><span class="line">        <span class="comment">// 处理缓冲区：移动读指针到下一行开始</span></span><br><span class="line">        <span class="keyword">if</span>(lineend == buff.<span class="built_in">BeginWrite</span>()) &#123;  <span class="comment">// 读完了</span></span><br><span class="line">            buff.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineend + <span class="number">2</span>);        <span class="comment">// 跳过已处理的\r\n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>()); <span class="comment">//这就是之前提的带参的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析请求行（格式：方法 路径 HTTP/版本） // 注意一正则操作哈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParseRequestLine_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^ ]*) ([^ ]*) HTTP/([^ ]*)$&quot;</span>)</span></span>;  <span class="comment">//  // 正则表达式匹配三部分</span></span><br><span class="line">    smatch Match;   <span class="comment">// 用来匹配patten得到结果</span></span><br><span class="line">    <span class="comment">// 在匹配规则中，以括号()的方式来划分组别 一共三个括号 [0]表示整体</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, Match, patten)) &#123;  <span class="comment">// 匹配指定字符串整体是否符合</span></span><br><span class="line">        method_ = Match[<span class="number">1</span>];  <span class="comment">// 第1组：方法（GET/POST）</span></span><br><span class="line">        path_ = Match[<span class="number">2</span>];    <span class="comment">// 第2组：请求路径</span></span><br><span class="line">        version_ = Match[<span class="number">3</span>]; <span class="comment">// 第3组：HTTP版本</span></span><br><span class="line">        state_ = HEADERS;    <span class="comment">// 状态转移到解析头部</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析路径，统一一下path名称,方便后面解析资源（添加默认页面或后缀）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path_ == <span class="string">&quot;/&quot;</span>) &#123; <span class="comment">//说明刚来请求，还没请求东西，先来给个首页</span></span><br><span class="line">        path_ = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否是预定义的页面，自动添加.html后缀</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML.<span class="built_in">find</span>(path_) != DEFAULT_HTML.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            path_ += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单个请求头字段（格式：Key: Value）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^:]*): ?(.*)$&quot;</span>)</span></span>; <span class="comment">// 匹配键值对</span></span><br><span class="line">    smatch Match;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, Match, patten)) &#123;</span><br><span class="line">        header_[Match[<span class="number">1</span>]] = Match[<span class="number">2</span>];   <span class="comment">// 存储到header_哈希表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 匹配失败说明首部行匹配完了，状态变化</span></span><br><span class="line">        state_ = BODY;  <span class="comment">// 转移到解析请求体状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体（目前直接存储，后续处理由ParsePost_完成）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    body_ = line;       <span class="comment">// 暂存请求体内容</span></span><br><span class="line">    <span class="built_in">ParsePost_</span>();       <span class="comment">// 解析POST数据</span></span><br><span class="line">    state_ = FINISH;    <span class="comment">// 状态转换为下一个状态</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制转化为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpRequest::ConverHex</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;     <span class="comment">// A(10) ~ F(15)</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;f&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;     <span class="comment">// a(10) ~ f(15)</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;0&#x27;</span>;          <span class="comment">// 0(0) ~9(9)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 非法字符可返回0或抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理POST请求（表单数据解析和用户验证）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否为表单提交</span></span><br><span class="line">    <span class="keyword">if</span>(method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp; header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析URL编码的表单数据（处理%编码和键值对） 比如：name=John%20Doe&amp;age=25%26under20</span></span><br><span class="line">        <span class="built_in">ParseFromUrlencoded_</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前路径是否需要验证（登录/注册）</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML_TAG.<span class="built_in">count</span>(path_))&#123; <span class="comment">// 如果是登录/注册的path</span></span><br><span class="line">            <span class="type">int</span> tag = DEFAULT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;   <span class="comment">// 获取页面类型标记</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Tag:%d&quot;</span>, tag);</span><br><span class="line">            <span class="keyword">if</span>(tag==<span class="number">0</span>||tag==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);  <span class="comment">// 为1则是登录，处理登陆（数据库select，处理注册的话数据库得insert 无论是登陆还是注册，数据库都得select哈，毕竟得确认用户名未被使用）</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin)) &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/welcome.html&quot;</span>;  <span class="comment">//匹配成功则path_改成welcome</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/error.html&quot;</span>;    <span class="comment">//匹配不成功则path_改成error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析URL编码的表单数据（处理%编码和键值对）</span></span><br><span class="line"><span class="comment">// 比如：name=John%20Doe%26age=25</span></span><br><span class="line"><span class="comment">// 处理name=John%20Doe %20解码为空格，键值对变为name=John Doe。</span></span><br><span class="line"><span class="comment">// %26解码为&amp;，键值对变为name=John Doe&amp;age=25</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(body_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;  <span class="comment">//空则return</span></span><br><span class="line"></span><br><span class="line">    string key, value;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> ch = body_[i];</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="comment">// 键值分隔符</span></span><br><span class="line">            key = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 空格替换</span></span><br><span class="line">            body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="comment">// 处理%编码（如%20为空格）</span></span><br><span class="line">            num = <span class="built_in">ConverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">ConverHex</span>(body_[i + <span class="number">2</span>]);</span><br><span class="line">            body_[i + <span class="number">2</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            body_[i + <span class="number">1</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">// 跳过两个十六进制字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:  <span class="comment">// 键值对分隔符</span></span><br><span class="line">            value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            post_[key] = value; <span class="comment">//存储一下</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(j &lt;= i);</span><br><span class="line">    <span class="comment">// 处理最后一个键值对</span></span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">        post_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户验证（查询数据库）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;pwd, <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;  <span class="comment">//为空直接返回</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从连接池获取数据库连接（RAII方式自动释放）</span></span><br><span class="line">    MYSQL* sql;</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(&amp;sql, SqlConnPool::<span class="built_in">Instance</span>()); <span class="comment">// SqlConnRAII Name(&amp;sql, SqlConnPool::Instance()); 只不过这里不需要name来操作</span></span><br><span class="line">    <span class="built_in">assert</span>(sql);  <span class="comment">//判断是拿到正常的sql</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//这个flag 前边表示是否需要执行注册(insert) 后面表示执行的结果 成功与否</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> order[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MYSQL_FIELD *fields = <span class="literal">nullptr</span>;</span><br><span class="line">    MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isLogin)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//说明是注册操作 数据库得 insert 登陆的话 数据库只需要select  无论是登陆还是注册，数据库都得select哈，毕竟得确认用户名未被使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户及密码</span></span><br><span class="line">    <span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;SELECT username, password FROM user WHERE username=&#x27;%s&#x27; LIMIT 1&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql,order))&#123;</span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">mysql_store_result</span>(sql);</span><br><span class="line">    j = <span class="built_in">mysql_num_fields</span>(res);</span><br><span class="line">    fields = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">    <span class="keyword">while</span>(MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res))&#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>; <span class="comment">// 数据库中的密码</span></span><br><span class="line">        <span class="keyword">if</span>(isLogin)&#123;  <span class="comment">//登陆表单 比对一下密码</span></span><br><span class="line">            <span class="keyword">if</span>(pwd == password) &#123; </span><br><span class="line">                flag = <span class="literal">true</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">LOG_INFO</span>(<span class="string">&quot;pwd error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//注册表单 //既然能够查询到用户名和密码，那么说明用户名已经存在了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;user used!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册行为 且 用户名未被使用</span></span><br><span class="line">    <span class="keyword">if</span>(!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;regirster!&quot;</span>);</span><br><span class="line">        <span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(order, <span class="number">256</span>,<span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;Insert error!&quot;</span>);</span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;UserVerify success!!&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里要注意哈， SqlConnRAII 会自动释放，执行析构函数，也就是说自动释放sql资源到池子里面，注意回去看看这个是怎么操作的 </span></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">HttpRequest::path</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> version_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否保持连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> header_.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>)-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp; version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="httpresponse"><a href="#httpresponse" class="headerlink" title="httpresponse"></a>httpresponse</h3><p>这里就很常规了，和之前的httprequest类似，主要是组合响应报文，并不会将响应报文返回给客户端,这里一定要注意一下响应报文的格式</p><p>这里一定要注意，组合响应报文，并不会将响应报文返回给客户端</p><p>我举个例子：</p><ul><li><p>比如httprequest解析了一个GET请求的，请求的是一个index.html的文件</p></li><li><p>那么httpresponse任务就是组合响应报文，比如响应报文的状态行  响应头 以及 添加响应内容</p></li><li><p>其中涉及到一些判断，比如状态行，如果发现没有index.html那个就是404 如果发现有但是咱们没有操作的权限就是403等。</p></li><li><p>这里会把状态行以及响应头放在一个buffer里面方便后面httpconn取</p></li><li><p>响应内容 是一个文件，那么就会把这个文件放到内存映射里面，这里不会放在buffer里面哈，毕竟文件很大，就是映射到内存，方便后面httpconn取</p><ul><li>简单介绍一下内存映射，比如一个文件里面存储abcd，内存映射就是把文件映射到内存里面，分配一个连续的空间存储abcd，给一个首地址，指向a，那么后续咱们要拿就直接操作这个地址就行了。</li><li>这个就是简单理解哈，想要搞懂可以取网上搜一下，有很多的介绍。</li></ul></li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// mmap, munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="type">int</span> code_;                           <span class="comment">// HTTP状态码</span></span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;                   <span class="comment">// 是否保持长连接</span></span><br><span class="line">    std::string path_;                   <span class="comment">// 也就是文件名</span></span><br><span class="line">    std::string srcDir_;                 <span class="comment">// 资源的根目录（绝对）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mmFile_;                       <span class="comment">// 内存映射的文件指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;             <span class="comment">// 文件状态信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;  <span class="comment">// 后缀类型集</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;          <span class="comment">// 编码状态集</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;            <span class="comment">// 编码路径集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;    <span class="comment">// 添加状态行到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;       <span class="comment">// 添加响应头到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer &amp;buff)</span></span>;      <span class="comment">// 添加响应内容到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;                   <span class="comment">// 处理错误页面路径</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;          <span class="comment">// 获取文件类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">HttpResponse</span>(); <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化HTTP响应对象</span></span><br><span class="line">    <span class="comment">// 参数: srcDir-资源根目录，path-请求路径，isKeepAlive-是否保持连接，code-初始状态码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 构建完整的HTTP响应到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="comment">// 获取内存映射的文件指针</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 解除内存映射</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取文件长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 生成错误内容到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="comment">// 获取当前状态码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_RESPONSE_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP/1.1 200 OK\r\n</span></span><br><span class="line"><span class="comment">// Date: Fri, 22 May 2009 06:07:21 GMT\r\n</span></span><br><span class="line"><span class="comment">// Content-Type: text/html; charset=UTF-8\r\n</span></span><br><span class="line"><span class="comment">// \r\n</span></span><br><span class="line"><span class="comment">// &lt;html&gt;</span></span><br><span class="line"><span class="comment">//       &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">//       &lt;body&gt;</span></span><br><span class="line"><span class="comment">//             &lt;!--body goes here--&gt;</span></span><br><span class="line"><span class="comment">//       &lt;/body&gt;</span></span><br><span class="line"><span class="comment">// &lt;/html&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件后缀到MIME类型的映射</span></span><br><span class="line"><span class="comment">// 告诉浏览器如何处理文件</span></span><br><span class="line"><span class="comment">// 例如：text/html 表示 HTML 文档，浏览器会渲染它；application/pdf 表示 PDF 文件，浏览器可能会调用 PDF 阅读器。</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态码到状态描述的映射</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123; <span class="number">200</span>, <span class="string">&quot;OK&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态码到错误页面路径的映射</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数初始化成员变量</span></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    code_ = <span class="number">-1</span>;              <span class="comment">// 初始无效状态码</span></span><br><span class="line">    path_ = srcDir_ = <span class="string">&quot;&quot;</span>;    <span class="comment">// 清空路径</span></span><br><span class="line">    isKeepAlive_ = <span class="literal">false</span>;    <span class="comment">// 默认关闭长连接</span></span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>;       <span class="comment">// 初始无内存映射</span></span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;     <span class="comment">// 清空文件状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数确保解除内存映射</span></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> string&amp; srcDir, string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);             <span class="comment">// 确保资源目录有效</span></span><br><span class="line">    <span class="keyword">if</span>(mmFile_)&#123;</span><br><span class="line">        <span class="built_in">UnmapFile</span>();                  <span class="comment">// 首先解除之前的内存映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置成员变量</span></span><br><span class="line">    code_ = code;</span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建HTTP响应主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="comment">// 检查文件是否存在且不是目录</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;</span><br><span class="line">        code_ = <span class="number">404</span>;   <span class="comment">// 不存在或为目录</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH))&#123;</span><br><span class="line">        code_ = <span class="number">403</span>;   <span class="comment">// 无读取权限</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>)&#123; </span><br><span class="line">        code_ = <span class="number">200</span>;   <span class="comment">// 未指定状态码时默认成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();           <span class="comment">// 处理错误页面路径 这里相当于先判断一下是否存在错误(400,403,404)，如果存在的话就把文件换成响应的错误的页面</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);    <span class="comment">// 构建状态行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);       <span class="comment">// 构建头部</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);      <span class="comment">// 构建内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内存映射文件指针\r\n</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;  <span class="comment">// 从文件状态获取大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误页面路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态码有对应错误页面</span></span><br><span class="line">    <span class="keyword">if</span>(CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;         <span class="comment">// 更新路径为错误页面</span></span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);  <span class="comment">// 重新获取文件状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加状态行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    string status;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;  <span class="comment">// 已知状态码</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        code_ = <span class="number">400</span>;    <span class="comment">// 未知状态码默认400</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(<span class="number">400</span>)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 格式：HTTP/1.1 200 OK\r\n</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + <span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接状态</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(isKeepAlive_)&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容类型</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcFd &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);  <span class="comment">// 文件打开失败</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件映射到内存提高文件的访问速度  MAP_PRIVATE 建立一个写入时拷贝的私有映射</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">        <span class="comment">// mmap 是一个系统调用，用于将文件或设备映射到进程的地址空间，从而可以通过指针操作来访问文件内容。</span></span><br><span class="line">    <span class="comment">// 表示映射的地址由系统选择。 mmFileStat_.st_size：表示映射的长度，即文件的大小。mmFileStat_ 是一个 struct stat 类型的变量，st_size 是文件的大小。</span></span><br><span class="line">    <span class="comment">// PROT_READ表示映射区域的保护属性，只允许读取。  MAP_PRIVATE表示映射是私有的，对映射区域的修改不会写回文件。 文件描述符，表示要映射的文件。0 表示从文件的偏移量为 0 的位置开始映射。</span></span><br><span class="line">    <span class="comment">// 返回一个指向映射区域的指针。如果映射失败，返回 (void*)-1。 这里将返回值强制转换为 int* 类型，并赋值给 mmRet。</span></span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*mmRet == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);   <span class="comment">// 映射失败</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;  <span class="comment">// 保存映射指针</span></span><br><span class="line">    <span class="built_in">close</span>(srcFd);</span><br><span class="line">    <span class="comment">// 添加内容长度头</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>); <span class="comment">//注意看上面的HTTP响应报文格式，就知道这里为啥会有两个&quot;\r\n\r\n&quot;了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除内存映射</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size); <span class="comment">// 释放映射内存</span></span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件类型 </span></span><br><span class="line"><span class="function">string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找最后一个.的位置 得找到后缀，然后查表</span></span><br><span class="line">    string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos) &#123;   <span class="comment">// 最大值 find函数在找不到指定值得情况下会返回string::npos 这个说明没有 .  也就是说没有后缀</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;    <span class="comment">// 默认纯文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    string suffix = path_.<span class="built_in">substr</span>(idx);   <span class="comment">// 提取后缀</span></span><br><span class="line">    <span class="keyword">if</span>(SUFFIX_TYPE.<span class="built_in">count</span>(suffix)==<span class="number">1</span>)&#123;    <span class="comment">// 查找已知类型</span></span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;    <span class="comment">// 默认纯文本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成错误内容HTML</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, string message)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string body;</span><br><span class="line">    string status;</span><br><span class="line">    <span class="comment">// 构建HTML结构</span></span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充错误信息</span></span><br><span class="line">    body += <span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status  + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    <span class="comment">// 添加内容长度和内容本身</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="httpconn"><a href="#httpconn" class="headerlink" title="httpconn"></a>httpconn</h3><p>这里是综合了前面 httprequest 与 httpresponse</p><p>什么意思呢？就是向外面提供一些接口，这个类里面会存储客户端的文件描述符(fd)，以及相应的客户端的地址（sockaddr_in），里面实现了读fd内容的操作，向fd里面写的操作，等。</p><p>httprequest 负责解析 请求内容</p><p>httpresponse 负责生成 响应内容</p><p>整体大概的流程：</p><p>相当于将 请求内容 读取到 readBuff_ 之中 然后 httprequest 负责解析 后面 httpresponse 负责生成响应的内容，写到 writeBuff_ 里面 然后再写到 fd 里面</p><p>1.这里简单介绍一下ET和LT，简单解释一下：</p><ul><li>相当于通知我们有数据来了</li><li>LT模式下如果缓冲区里面有数据就会一直不停的通知，一直到咱们把缓冲区里面的数据全部读完才会停止通知。因此LT模式下支持分次读或者写，因为如果咱们一次没读完，后面还会不停的继续通知咱们。这样虽然有效，但是确实会浪费系统资源，因为要不停通知</li><li>ET模式下只有缓冲区里面来数据了才会通知一次，也只会通知一次。因此，咱们在进行读写的时候必须要保证一次性读完才可以。</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>       <span class="comment">//  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接相关成员</span></span><br><span class="line">    <span class="type">int</span> fd_;                      <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_;     <span class="comment">// 客户端地址结构</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                <span class="comment">// 连接是否已关闭标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作相关</span></span><br><span class="line">    <span class="type">int</span> iovCnt_;                  <span class="comment">// iov数组有效元素个数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];         <span class="comment">// 分散写结构数组</span></span><br><span class="line">    Buffer readBuff_;             <span class="comment">// 读缓冲区    读缓冲区（存储客户端请求数据）</span></span><br><span class="line">    Buffer writeBuff_;            <span class="comment">// 写缓冲区    写缓冲区（存储生成的响应头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP处理对象</span></span><br><span class="line">    HttpRequest request_;         <span class="comment">// HTTP请求解析器</span></span><br><span class="line">    HttpResponse response_;       <span class="comment">// HTTP响应生成器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 &amp; 析构函数</span></span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                   <span class="comment">// 从socket读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                  <span class="comment">// 向socket写入数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                   <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;                              <span class="comment">// 获取文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// 获取客户端端口</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// 获取客户端IP字符串</span></span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 获取客户端地址结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;                                 <span class="comment">// 处理HTTP请求生成响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写的总长度              // 计算待发送数据总长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否保持连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员（类级别共享）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;                    <span class="comment">// 标记是否使用ET（边沿触发）模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;           <span class="comment">// 服务器资源目录路径</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;   <span class="comment">// 原子计数器，记录当前连接数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;         <span class="comment">// 资源目录路径（由外部设置）</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount; <span class="comment">// 原子连接计数器初始化为0</span></span><br><span class="line"><span class="type">bool</span> HttpConn::isET;                  <span class="comment">// ET模式标记（默认false，需外部设置）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;                <span class="comment">// 初始无效文件描述符</span></span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 清空地址结构</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;         <span class="comment">// 初始为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>();                 <span class="comment">// 确保连接关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化新连接</span></span><br><span class="line"><span class="comment"> * @param fd 客户端socket描述符</span></span><br><span class="line"><span class="comment"> * @param addr 客户端地址结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);        <span class="comment">// 确保有效fd</span></span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();  <span class="comment">// 清空写缓冲区</span></span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空读缓冲区</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;          <span class="comment">// 标记为打开状态</span></span><br><span class="line">    <span class="comment">// 记录日志：客户端IP、端口和当前连接数</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();     <span class="comment">// 释放内存映射文件（如果有）</span></span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>;      <span class="comment">// 标记为已关闭</span></span><br><span class="line">        userCount--;          <span class="comment">// 连接数-1</span></span><br><span class="line">        <span class="built_in">close</span>(fd_);           <span class="comment">// 关闭socket</span></span><br><span class="line">        <span class="comment">// 记录客户端退出日志</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取客户端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端IP字符串（点分十进制）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);  <span class="comment">//还有记得大端转小端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端端口号（网络字节序）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取数据到读缓冲区</span></span><br><span class="line"><span class="comment"> * @param saveErrno 用于保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 读取的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 使用Buffer的ReadFd读取数据到读缓冲区</span></span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 出错或读完了,关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET); <span class="comment">// ET模式需一次性读完所有数据 //这里要理解一下为什么ET模式要一次性读完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写数据到socket（使用writev聚合写）</span></span><br><span class="line"><span class="comment"> * @param saveErrno 保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 写入的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_,iov_,iovCnt_); <span class="comment">// writev将iov数组内容写入socket</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数据是否全部写完</span></span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 传输结束 */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len)&#123;  <span class="comment">// 处理部分写入情况（先写iov[0]响应头，再写iov[1]文件内容）</span></span><br><span class="line">            <span class="comment">// 这里详细解释一下,很容易搞不懂(先看下面那个else)</span></span><br><span class="line">            <span class="comment">// OK 这里仿照 下面那个else就好理解了</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len); <span class="comment">// iov_[0]已写完，调整iov_[1]的指针和长度</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="comment">// 但是着一块又难理解了</span></span><br><span class="line">            <span class="comment">// 首先咱们要知道一点 writeBuff_ 里面存储的是响应头部分,刚开始被赋予了iov_[0].iov_base,因此当iov_[0]写完了那么writeBuff_就没有用了,就清空一下就好了</span></span><br><span class="line">            <span class="comment">// 我们主要理解一下为什么到这个位置了iov_[0].iov_len还不为0</span></span><br><span class="line">            <span class="comment">// 举个例子好理解,比如原始的iov_[0].iov_len = 100 原始的iov_[1].iov_len = 1000 那么第一次写的时候len为200,那么是不是就理解了,这个时候不会进入下面那个else,只会进入这个,因此我们需要处理iov_[0]</span></span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;</span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>(); <span class="comment">// 清空写缓冲区</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;      <span class="comment">// iov_[0]长度置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// iov_[0]未写完，调整其指针和长度</span></span><br><span class="line">            <span class="comment">// 里详细解释一下,很容易搞不懂</span></span><br><span class="line">            <span class="comment">// 写的时候总得知道写的其实地址和写的总长度把</span></span><br><span class="line">            <span class="comment">// 刚开始第一个缓冲区的起始地址是 iov_[0].iov_base 和 长度是 iov_[0].iov_len  这个没的说</span></span><br><span class="line">            <span class="comment">// 到这里表示前面的 len = writev(fd_,iov_,iovCnt_);  正常执行了,并且已经写进入len这么多了,而且len要小于iov_[0].iov_len表示iov_[0]还没写完</span></span><br><span class="line">            <span class="comment">// 这个时候就需要调整一下后面写的其实地址和写的总长度了</span></span><br><span class="line">            <span class="comment">// 那么后面就好理解了 起始地址不就是 iov_base往后移动 len 个位置马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len; </span><br><span class="line">            <span class="comment">// 剩下的长度不就是iov_len减去len马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len); <span class="comment">// 更新写缓冲区读指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>); <span class="comment">// ET模式或数据量大时循环写 这里同样理解一下为什么T模式要一次性写完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理HTTP请求生成响应</span></span><br><span class="line"><span class="comment"> * @return 处理是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    request_.<span class="built_in">Init</span>();    <span class="comment">// 初始化请求对象</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 无数据可处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))&#123;     <span class="comment">// 解析请求（成功则生成200响应，失败400）</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成响应到写缓冲区</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_); <span class="comment">// 生成响应报文放入writeBuff_中</span></span><br><span class="line">    <span class="comment">// 设置iov[0]指向响应头数据</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;  <span class="comment">// 默认只有响应头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在内存映射文件（如请求的文件），设置iov[1]</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>先说一下为什么要有这个，有些socket连接很长事件不进行操作，还白白占用一个连接，这就很不合理，因此设置一个计时器，当超过一定时间之后就断开连接</p><p>通过小顶堆来实现，放在最前面的永远是最早就要超时的，对于超时的就调用回调函数来处理（一般情况下这里的回调函数就是断开连接了）</p><p>时钟操作，小根堆的实现，小根堆的下沉与上浮，小根堆的删除与添加</p><p>下面是代码：（务必注意一下回调函数是怎么搞的以及回调函数是什么时候调用的）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义超时回调函数类型</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="comment">// 使用高精度时钟</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;</span><br><span class="line"><span class="comment">// 毫秒时间单位</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;</span><br><span class="line"><span class="comment">// 时间点类型</span></span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;             <span class="comment">// 节点唯一标识</span></span><br><span class="line">    TimeStamp expires;  <span class="comment">// 超时的时间点</span></span><br><span class="line">    TimeoutCallBack cb; <span class="comment">// 回调function&lt;void()&gt;</span></span><br><span class="line">    <span class="comment">// 重载小于运算符，用于比较两个节点的超时时间</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;    <span class="comment">// 重载比较运算符</span></span><br><span class="line">        <span class="keyword">return</span> expires &lt; t.expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载大于运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> TimerNode&amp; t) &#123;    <span class="comment">// 重载比较运算符</span></span><br><span class="line">        <span class="keyword">return</span> expires &gt; t.expires;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆定时器类（最小堆实现）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;TimerNode&gt; heap_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;   <span class="comment">// id对应的在heap_中的下标，方便用heap_的时候查找</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;                    <span class="comment">// 删除指定位置的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;                 <span class="comment">// 将节点上浮以维护堆结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> n)</span></span>;     <span class="comment">// 将节点下沉，返回是否进行了下沉</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;     <span class="comment">// 交换两个节点的位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;      <span class="comment">// 预分配空间以减少扩容开销</span></span><br><span class="line">    ~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;    <span class="comment">// 调整指定id节点的超时时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span></span>;     <span class="comment">// 添加新节点或更新已有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;                    <span class="comment">// 执行指定id节点的回调并删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                           <span class="comment">// 清空所有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;                            <span class="comment">// 心跳，很重要很重要！！！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                             <span class="comment">// 删除堆顶节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;                      <span class="comment">// 获取下一个即将超时节点的剩余时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAP_TIMER_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个节点的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt;heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt;heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">swap</span>(heap_[i], heap_[j]);</span><br><span class="line">    <span class="comment">// 更新交换后的id索引映射</span></span><br><span class="line">    ref_[heap_[i].id] = i;    <span class="comment">// 结点内部id所在索引位置也要变化</span></span><br><span class="line">    ref_[heap_[j].id] = j;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> parent = (i<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// 父节点下标计算</span></span><br><span class="line">    <span class="keyword">while</span>(parent &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[parent] &gt; heap_[i])&#123;  <span class="comment">//如果父节点比较大，那么就交换一下，让现在的节点上浮</span></span><br><span class="line">            <span class="built_in">SwapNode_</span>(i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">            parent = (i<span class="number">-1</span>)/<span class="number">2</span>;          <span class="comment">//继续判断需不需要上浮动</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉调整</span></span><br><span class="line"><span class="comment">// false：不需要下滑  true：下滑成功</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());    <span class="comment">// n:共几个结点</span></span><br><span class="line">    <span class="keyword">auto</span> index = i;</span><br><span class="line">    <span class="keyword">auto</span> child = <span class="number">2</span> * index + <span class="number">1</span>;             <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 选择较小的子节点 child+1为右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(child<span class="number">+1</span> &lt; n &amp;&amp; heap_[child<span class="number">+1</span>] &lt; heap_[child]) &#123;</span><br><span class="line">            child++;<span class="comment">//右子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap_[child] &lt; heap_[index]) &#123; <span class="comment">//当前节点比子结点要大，则需要下沉</span></span><br><span class="line">            <span class="built_in">SwapNode_</span>(index, child);</span><br><span class="line">            index = child;</span><br><span class="line">            child = <span class="number">2</span> * child + <span class="number">1</span>;        <span class="comment">//继续看孩子节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 需要跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index &gt; i; <span class="comment">//说明有下沉，如果index == i 便是没有变动 不需要下沉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 将要删除的结点换到队尾，然后调整堆</span></span><br><span class="line">    <span class="type">size_t</span> tmp = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">assert</span>(tmp &lt;= n);</span><br><span class="line">    <span class="comment">// 如果就在队尾，就不用移动了,反之就需要交换了</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; heap_.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(tmp, heap_.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 尝试下沉新节点</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(tmp, n))&#123;</span><br><span class="line">            <span class="built_in">siftup_</span>(tmp); <span class="comment">// 若不需要下沉则尝试上浮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除末尾节点</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整指定id的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id));</span><br><span class="line">    heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(newExpires);</span><br><span class="line">    <span class="comment">// 同理，修改完之后要调整堆</span></span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">        <span class="built_in">siftup_</span>(i);  <span class="comment">// 若不需要下沉则尝试上浮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新节点或者调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有，则调整</span></span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id))&#123;</span><br><span class="line">        <span class="type">int</span> tmp = ref_[id];</span><br><span class="line">        heap_[tmp].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeOut);</span><br><span class="line">        heap_[tmp].cb = cb;</span><br><span class="line">        <span class="comment">//同理，修改完之后要调整堆</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(tmp, heap_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="built_in">siftup_</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = n;</span><br><span class="line">        <span class="comment">// 这里应该算是结构体的默认构造</span></span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeOut), cb&#125;);  <span class="comment">// 右值</span></span><br><span class="line">        <span class="built_in">siftup_</span>(n);  <span class="comment">// 上浮新节点 因为已经是在最后了，不需要下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定id，并触发回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123; <span class="comment">//heap_是空的或者id不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    <span class="keyword">auto</span> node = heap_[i];</span><br><span class="line">    node.<span class="built_in">cb</span>();  <span class="comment">// 触发回调函数</span></span><br><span class="line">    <span class="built_in">del_</span>(i);    <span class="comment">// 删除节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有超时节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环检查堆顶节点</span></span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();  <span class="comment">//取堆顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;   <span class="comment">// 未超时则停止</span></span><br><span class="line">        node.<span class="built_in">cb</span>(); <span class="comment">// 执行超时回调</span></span><br><span class="line">        <span class="built_in">pop</span>();     <span class="comment">// 删除堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除堆顶节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个超时时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">tick</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 计算堆顶节点的剩余时间</span></span><br><span class="line">        res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; res = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>这里就是最后把所有的模块综合在一起的地方了</p><h3 id="epoller"><a href="#epoller" class="headerlink" title="epoller"></a>epoller</h3><p>这里要注意IO多路复用的概念</p><p>我在 <a href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a> 做了一些基本的介绍</p><p>这里就说一下为什么要有这个技术</p><ul><li>socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。</li><li>有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程</li><li>而且每一次切换线程 可能会需要 进行上下文操作，这就会很大的限制运行速度</li></ul><p>因此引入了IO多路复用的技术，相当于咱们把咱们的socket连接之后的文件描述符交给epoll托管，每当有事件发生的时候，epoll就会向咱们发送通知，咱们可以获取那些发生事件的fd，从而执行操作。</p><p>（这里还是建议先学习一下IO多路复用的概念，以及epoll的基本操作，学习完之后就会发现这个epoller特别简单，就是把epoll的命令封装一下）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：创建 epoll 实例并初始化事件数组</span></span><br><span class="line">    <span class="comment">// 参数 maxEvent: 预分配的事件数组大小（默认 1024）</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 析构函数：关闭 epoll 文件描述符</span></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加文件描述符到 epoll 实例的监控列表中</span></span><br><span class="line">    <span class="comment">// 参数 fd: 要监控的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 events: 监控的事件类型（如 EPOLLIN、EPOLLOUT、EPOLLET 等）</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功（true 成功，false 失败）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改已监控文件描述符的事件类型</span></span><br><span class="line">    <span class="comment">// 参数 fd: 已监控的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 events: 新的事件类型</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 epoll 实例中删除文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 fd: 要删除的文件描述符</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件就绪（核心函数）</span></span><br><span class="line">    <span class="comment">// 参数 timeoutMs: 超时时间（毫秒，-1 表示阻塞等待）</span></span><br><span class="line">    <span class="comment">// 返回值: 就绪的事件数量（出错时返回 -1）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第 i 个就绪事件对应的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 i: 事件数组的索引</span></span><br><span class="line">    <span class="comment">// 返回值: 文件描述符（需确保 i 在有效范围内）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第 i 个就绪事件的事件类型</span></span><br><span class="line">    <span class="comment">// 参数 i: 事件数组的索引</span></span><br><span class="line">    <span class="comment">// 返回值: 事件类型（如 EPOLLIN、EPOLLOUT 等）</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;   <span class="comment">// epoll 实例的文件描述符</span></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;   <span class="comment">// 存储就绪事件的数组 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 参数 maxEvent: 预分配事件数组的大小</span></span><br><span class="line"><span class="comment">// 创建 epoll 实例，参数 512 是历史遗留值（内核自动调整） 现在可以使用epoll_create1(0) 来创建</span></span><br><span class="line"><span class="comment">// 初始化事件数组大小为 maxEvent</span></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;</span><br><span class="line">    <span class="comment">// 断言检查：确保 epoll 实例创建成功且事件数组非空</span></span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);  <span class="comment">// 关闭 epoll 文件描述符，释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文件描述符到 epoll 监控列表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;     <span class="comment">// 初始化事件结构体（清零防止脏数据）</span></span><br><span class="line">    ev.data.fd = fd;          <span class="comment">// 关联目标文件描述符</span></span><br><span class="line">    ev.events = events;       <span class="comment">// 设置监控的事件类型</span></span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 添加监控（EPOLL_CTL_ADD 模式）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改已监控文件描述符的事件类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 修改事件（EPOLL_CTL_MOD 模式）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 epoll 监控列表中删除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 删除监控（EPOLL_CTL_DEL 模式，最后一个参数可忽略）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回事件数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 epoll_wait 获取就绪事件</span></span><br><span class="line">    <span class="comment">// 参数 1: epoll 实例的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 2: 事件数组首地址（底层数组需连续，vector 保证这一点）</span></span><br><span class="line">    <span class="comment">// 参数 3: 最多返回的事件数（设为数组大小避免溢出）</span></span><br><span class="line">    <span class="comment">// 参数 4: 超时时间（-1 表示无限等待）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="comment">// 返回值:</span></span><br><span class="line">    <span class="comment">// - 正数: 就绪事件数</span></span><br><span class="line">    <span class="comment">// - 0: 超时无事件</span></span><br><span class="line">    <span class="comment">// - -1: 出错（需检查 errno）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件的fd // 获取第 i 个事件关联的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言确保索引 i 在合法范围内（注意实际就绪事件数可能小于数组大小）</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件属性 // 获取第 i 个事件的事件类型</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h3><p>最后的所有模块的封装，前面咱们已经把所有的功能实现了，这里就吧前面所有的功能组合在一起，拼接成咱们的服务器。</p><p>初始化任务：</p><ul><li>初始化日志系统（log模块）</li><li>初始化数据库连接池 （pool&#x2F;sqlconnpool模块）</li><li>辅助功能的初始化（HeapTimer，ThreadPool，Epoller）</li><li>开启服务器，socket套接字创建，绑定，监听</li><li>获取资源的位置(resources文件夹的位置)</li></ul><p>服务器运行的函数（Start函数流程，也就是那个主循环的流程）</p><ul><li>开始的时候先让timer tick一下并获取下一次超时的时间，tick会这里就是处理那些长时间不干活的client</li><li>调用epoller的Wait，设置超时事件为上面获取的下一次超时的时间（这里挺巧妙的，可以想一下为啥）</li><li>后面正常执行的话，就会获取那些就绪client的fd，然后分事件执行就好<ul><li>如果是服务器收到消息，那么一定是来新的连接了 那么 accept 一下，添加新客户就好</li><li>如果是异常事件就直接断开连接就好</li><li>如果是读事件就 为线程池添加读任务，线程池会自动分配线程来执行读任务</li><li>如果是写事件就 为线程池添加读任务，线程池会自动分配线程来执行写任务</li></ul></li></ul><p>这里要注意读写的整体的过程，也就是webserver设计的核心：</p><p>（这段来源于 <a href="https://blog.csdn.net/weixin_51322383/article/details/130545172">https://blog.csdn.net/weixin_51322383/article/details/130545172</a> ）</p><p>浏览器向服务器发出request的时候，epoll会接收到EPOLL_IN读事件，此时调用OnRead去解析，将fd(浏览器)的request内容放到读缓冲区，并且把响应报文写到写缓冲区，这个时候调用OnProcess()是为了把该事件变为EPOLL_OUT，让epoll下一次检测到写事件，把写缓冲区的内容写到fd。当EPOLL_OUT写完后，整个流程就结束了，此时需要再次把他置回原来的EPOLL_IN去检测新的读事件到来。</p><p>理解了这段话就理解了整个webserver的设计</p><p>这里我还是想再解释解释epoll的机制，虽然在 <a href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a> 里面已经解释过了，这里就当成补充吧。</p><p>1.socket收发信息</p><ul><li>这个大家应该都知道，我再废话说一遍</li><li>对于socket中的recv和send 这些函数，都有响应的缓冲区</li><li>比如：recv，外面的数据来了，会先放在内核之中的读缓冲区里面，然后咱们调用recv才能拿到数据</li><li>相应的send的时候，咱们会把数据发送到内核的写缓冲区里面，然后内核会调用网络操作把东西给发出去</li></ul><p>2.epoll的触发</p><p>前面也提到了epoll的触发有两种模式：水平触发（LT）与边缘触发（ET）这里就详细的解释一下怎么触发的</p><ul><li>水平触发（LT）<ul><li>对于读（EPOLLIN）事件：当内核之中的读缓冲区存在数据的时候，就会一直触发，就是不停的向用户通知，还有东西可以读。</li><li>对于写（EPOLLOUT）事件：当内核之中的写缓冲区还可以写，也就是说写缓冲区还没满的时候就会不停的触发</li><li>所以对于LT，并不会要求一次必须要把事情处理完，比如读的话，如果这次没读完，下次还可以继续读，因为epoll会一直通知我们读事件</li></ul></li><li>边缘触发（ET）<ul><li>对于读（EPOLLIN）事件：内核之中的读缓冲区状态变化的时候才会触发，比如：有新的数据来了，就会触发一次，但也只会触发这一次，如果这次你读不完数据也没办法，后续也不会触发。</li><li>对于写（EPOLLOUT）事件：内核之中的写缓冲区状态变化的时候才会触发，这个状态变化指的是 不可写-&gt;可写，就是缓冲区满-&gt;缓冲区不满。如果缓冲区满了的话会出现errno事件，事件为EAGAIN。</li><li>对于写（EPOLLOUT）事件：还有另外一种情况，就是第一次绑定EPOLLOUT事件的时候会触发，这个时候写缓冲区肯定是可写的，因此先触发一次，让用户先写。</li></ul></li></ul><p>这样的话就很好理解了吧</p><p>再把上面那句话拷贝下来看一看，是不是就理解了</p><p>浏览器向服务器发出request的时候，epoll会接收到EPOLL_IN读事件，此时调用OnRead去解析，将fd(浏览器)的request内容放到读缓冲区（这里不是内核里面的哈，指的是咱们写的那个buffer），并且把响应报文写到写缓冲区这里不是内核里面的哈，指的是咱们写的那个buffer），这个时候调用OnProcess()是为了把该事件变为EPOLL_OUT，让epoll下一次检测到写事件，把写缓冲区的内容写到fd。当EPOLL_OUT写完后，整个流程就结束了，此时需要再次把他置回原来的EPOLL_IN去检测新的读事件到来。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>       <span class="comment">//  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接相关成员</span></span><br><span class="line">    <span class="type">int</span> fd_;                      <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_;     <span class="comment">// 客户端地址结构</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                <span class="comment">// 连接是否已关闭标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作相关</span></span><br><span class="line">    <span class="type">int</span> iovCnt_;                  <span class="comment">// iov数组有效元素个数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];         <span class="comment">// 分散写结构数组</span></span><br><span class="line">    Buffer readBuff_;             <span class="comment">// 读缓冲区    读缓冲区（存储客户端请求数据）</span></span><br><span class="line">    Buffer writeBuff_;            <span class="comment">// 写缓冲区    写缓冲区（存储生成的响应头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP处理对象</span></span><br><span class="line">    HttpRequest request_;         <span class="comment">// HTTP请求解析器</span></span><br><span class="line">    HttpResponse response_;       <span class="comment">// HTTP响应生成器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 &amp; 析构函数</span></span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                   <span class="comment">// 从socket读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                  <span class="comment">// 向socket写入数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                   <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;                              <span class="comment">// 获取文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// 获取客户端端口</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// 获取客户端IP字符串</span></span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 获取客户端地址结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;                                 <span class="comment">// 处理HTTP请求生成响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写的总长度              // 计算待发送数据总长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否保持连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员（类级别共享）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;                    <span class="comment">// 标记是否使用ET（边沿触发）模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;           <span class="comment">// 服务器资源目录路径</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;   <span class="comment">// 原子计数器，记录当前连接数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;         <span class="comment">// 资源目录路径（由外部设置）</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount; <span class="comment">// 原子连接计数器初始化为0</span></span><br><span class="line"><span class="type">bool</span> HttpConn::isET;                  <span class="comment">// ET模式标记（默认false，需外部设置）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;                <span class="comment">// 初始无效文件描述符</span></span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 清空地址结构</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;         <span class="comment">// 初始为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>();                 <span class="comment">// 确保连接关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化新连接</span></span><br><span class="line"><span class="comment"> * @param fd 客户端socket描述符</span></span><br><span class="line"><span class="comment"> * @param addr 客户端地址结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);        <span class="comment">// 确保有效fd</span></span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();  <span class="comment">// 清空写缓冲区</span></span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空读缓冲区</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;          <span class="comment">// 标记为打开状态</span></span><br><span class="line">    <span class="comment">// 记录日志：客户端IP、端口和当前连接数</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();     <span class="comment">// 释放内存映射文件（如果有）</span></span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>;      <span class="comment">// 标记为已关闭</span></span><br><span class="line">        userCount--;          <span class="comment">// 连接数-1</span></span><br><span class="line">        <span class="built_in">close</span>(fd_);           <span class="comment">// 关闭socket</span></span><br><span class="line">        <span class="comment">// 记录客户端退出日志</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取客户端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端IP字符串（点分十进制）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);  <span class="comment">//还有记得大端转小端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端端口号（网络字节序）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取数据到读缓冲区</span></span><br><span class="line"><span class="comment"> * @param saveErrno 用于保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 读取的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 使用Buffer的ReadFd读取数据到读缓冲区</span></span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 出错或读完了,关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET); <span class="comment">// ET模式需一次性读完所有数据 //这里要理解一下为什么ET模式要一次性读完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写数据到socket（使用writev聚合写）</span></span><br><span class="line"><span class="comment"> * @param saveErrno 保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 写入的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_,iov_,iovCnt_); <span class="comment">// writev将iov数组内容写入socket</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数据是否全部写完</span></span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 传输结束 */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len)&#123;  <span class="comment">// 处理部分写入情况（先写iov[0]响应头，再写iov[1]文件内容）</span></span><br><span class="line">            <span class="comment">// 这里详细解释一下,很容易搞不懂(先看下面那个else)</span></span><br><span class="line">            <span class="comment">// OK 这里仿照 下面那个else就好理解了</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len); <span class="comment">// iov_[0]已写完，调整iov_[1]的指针和长度</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="comment">// 但是着一块又难理解了</span></span><br><span class="line">            <span class="comment">// 首先咱们要知道一点 writeBuff_ 里面存储的是响应头部分,刚开始被赋予了iov_[0].iov_base,因此当iov_[0]写完了那么writeBuff_就没有用了,就清空一下就好了</span></span><br><span class="line">            <span class="comment">// 我们主要理解一下为什么到这个位置了iov_[0].iov_len还不为0</span></span><br><span class="line">            <span class="comment">// 举个例子好理解,比如原始的iov_[0].iov_len = 100 原始的iov_[1].iov_len = 1000 那么第一次写的时候len为200,那么是不是就理解了,这个时候不会进入下面那个else,只会进入这个,因此我们需要处理iov_[0]</span></span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;</span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>(); <span class="comment">// 清空写缓冲区</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;      <span class="comment">// iov_[0]长度置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// iov_[0]未写完，调整其指针和长度</span></span><br><span class="line">            <span class="comment">// 里详细解释一下,很容易搞不懂</span></span><br><span class="line">            <span class="comment">// 写的时候总得知道写的其实地址和写的总长度把</span></span><br><span class="line">            <span class="comment">// 刚开始第一个缓冲区的起始地址是 iov_[0].iov_base 和 长度是 iov_[0].iov_len  这个没的说</span></span><br><span class="line">            <span class="comment">// 到这里表示前面的 len = writev(fd_,iov_,iovCnt_);  正常执行了,并且已经写进入len这么多了,而且len要小于iov_[0].iov_len表示iov_[0]还没写完</span></span><br><span class="line">            <span class="comment">// 这个时候就需要调整一下后面写的其实地址和写的总长度了</span></span><br><span class="line">            <span class="comment">// 那么后面就好理解了 起始地址不就是 iov_base往后移动 len 个位置马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len; </span><br><span class="line">            <span class="comment">// 剩下的长度不就是iov_len减去len马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len); <span class="comment">// 更新写缓冲区读指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>); <span class="comment">// ET模式或数据量大时循环写 这里同样理解一下为什么T模式要一次性写完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理HTTP请求生成响应</span></span><br><span class="line"><span class="comment"> * @return 处理是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    request_.<span class="built_in">Init</span>();    <span class="comment">// 初始化请求对象</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 无数据可处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))&#123;     <span class="comment">// 解析请求（成功则生成200响应，失败400）</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成响应到写缓冲区</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_); <span class="comment">// 生成响应报文放入writeBuff_中</span></span><br><span class="line">    <span class="comment">// 设置iov[0]指向响应头数据</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;  <span class="comment">// 默认只有响应头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在内存映射文件（如请求的文件），设置iov[1]</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="github链接"><a href="#github链接" class="headerlink" title="github链接"></a>github链接</h1><p>我平时比较喜欢用cmake，感觉这个比较方便一些，因此就整了两个版本，一个是cmake版本一个是makefile版本（原来的是makefile版本）</p><p>cmake 版本运行：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer</a></p><p>（刚开始记得先把build里面东西给删除掉）</p><p>cd build</p><p>cmake ..</p><p>make</p><p>cd ..&#x2F;</p><p>sudo .&#x2F;main</p><p><a href="http://127.0.0.1:1316/">http://127.0.0.1:1316/</a></p><p>makefile版本：<a href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile</a></p><p>make</p><p>sudo ..&#x2F;bin&#x2F;server</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/weixin_51322383/article/details/130464403">https://blog.csdn.net/weixin_51322383/article/details/130464403</a></p><p><a href="https://blog.csdn.net/qq_44184756/article/details/130140778">https://blog.csdn.net/qq_44184756/article/details/130140778</a></p><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>我自己的学习用的github仓库：</p><p><a href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p><p>我的个人博客：</p><p><a href="https://blog.zqzhang2025.com/">https://blog.zqzhang2025.com/</a></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>里面有很多都是我自己的理解，作为初学者，文章里面肯定会有一些错误。大家看的时候记得加上自己的理解去看，如果发现我那里理解有问题，非常欢迎大家能够指出来，咱们共同进步。非常感谢大家。</p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatRoom</title>
      <link href="/2025/04/15/chatRoom/"/>
      <url>/2025/04/15/chatRoom/</url>
      
        <content type="html"><![CDATA[<h1 id="chatRoom-项目"><a href="#chatRoom-项目" class="headerlink" title="chatRoom 项目"></a>chatRoom 项目</h1><p>git:<a href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p><p>简单介绍：socket的简单应用，简单来说，就是一个服务端：server 许多个客户端：client1 client2 client3 client4… 现在要把这么多客户端拉到一个聊天室里面，实现群聊通信</p><p>实现方式：其实思想很简单，就是 client_i 向 server发送消息，然后server接收到消息之后，把消息转发给除却 client_i 之外的所有的 客户</p><p>这里主要学习 I&#x2F;O多路复用技术 之前学习的基础的 socket 是客户端 服务器 一对一的，现在需要服务器接收多个客户端的连接，因此需要用到 I&#x2F;O多路复用技术</p><h1 id="I-O多路复用技术"><a href="#I-O多路复用技术" class="headerlink" title="I&#x2F;O多路复用技术"></a>I&#x2F;O多路复用技术</h1><h2 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h2><p>socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。</p><p>有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程</p><p>而且每一次切换线程 可能会需要 进行上下文操作，这就会很大的限制运行速度</p><h2 id="select-技术"><a href="#select-技术" class="headerlink" title="select 技术"></a>select 技术</h2><p>这是比较早的技术</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//select函数接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数据结构 (bitmap)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> max_fd, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readset, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writeset, </span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> timeval *timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span>                              <span class="comment">// 返回值就绪描述符的数目</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除  </span></span></span><br></pre></td></tr></table></figure><p>主要再于 select API </p><p>说一下怎么工作的：我们注意到select之中会有三个 fd_set ，第一个是读事件，第二个是写事件，第三个是异常事件 这三个是咱们需要监听的事件</p><h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><ul><li>比如咱们有 5 个 文件描述符需要监控 3 5 7 8 10，咱们需要告诉内核态，咱们需要监控这些 文件描述符 的那些事件</li><li>对于 readset 咱们传入 (注意下标)0 0 0 1 0 1 0 1 1 0 0 (咱们将这个bitmap命名为readsetName哈)  表示 对于 3 5 7 8 咱们要监控读事件<ul><li>注意哈，这里是举个例子，并不是真实的，因为有些位置是操作系统专用的(我记得有些资料上说前三个是系统专用的)，咱们不能使用，这只是便于理解，其实不是这样的</li></ul></li><li>同理，对于 writeset 咱们传入 0 0 0 1 0 1 0 0 0 0 1 (咱们将这个bitmap命名为writesetName哈)表示 对于 3 5 10 咱们要监控写事件  exceptset 同理</li><li>这个时候会将 <strong>全部的文件描述符都放入内核态</strong> 内核态会一直 <strong>遍历轮询查询</strong>，直到咱们监控的事件发生，其会修改咱们传入的readsetName等，这里以readsetName为例<ul><li>首先会将readsetName都重置为0</li><li>比如 3 5 这两个事件发生了 read事件(有字符传进来了) 那么内核态度就会修改readsetName对应位置为1,就是：</li><li>readsetName &#x3D; 0 0 0 1 0 1 0 0 0 0 0 表示 3 5 两个事件发生了read事件</li><li>select返回值是发生事件文件描述符的数量</li></ul></li><li>后面咱们通过对readsetName进行遍历，就能知道那那一个 文件描述符 发生事件，然后做对应的处理就好</li></ul><h3 id="select的缺点："><a href="#select的缺点：" class="headerlink" title="select的缺点："></a>select的缺点：</h3><ul><li>select 使用固定长度的 BitsMap表示文件描述符集合，单个进程所打开的fd是有限制的，通过FD_SETSIZE设置，默认1024</li><li>每次调用select，都要把fd集合从用户态拷贝到内核态，在多个fd时开销较大</li><li>对socket扫描时是线性扫描，采用轮询的方式，效率较低（高并发时）</li></ul><h2 id="poll-技术"><a href="#poll-技术" class="headerlink" title="poll 技术"></a>poll 技术</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;                  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>引入了pollfd结构体，不需要咱们再定义三个BitsMap来监控了，但是其实还是和select 技术差不多</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul><li>还是比如咱们有 5 个 文件描述符需要监控 3 5 7 8 10，这个时候咱们有 5 个 上面所说的结构体</li><li>咱们通过定义 events 来定义咱们需要监控的事件</li><li>还是 <strong>全部的文件描述符都放入内核态</strong>  内核态还是会一直 <strong>遍历轮询查询</strong> 当有事件发生的时候，修改 对应结构体的 revents 然后返回 </li><li>咱们在用户态一个一个查询对应结构体的revents，就能知道是那个文件描述符发生了啥事件</li><li>后面咱们再做对应处理<ul><li>这里要注意，咱们做处理之后要把对应的revents置0,这里和select还是有些差别的select会自动置0</li></ul></li><li>这个其实和 select 技术差不多，相当于 select 的一个小优化</li></ul><p>会使用 一个数组存储(其实是链表) pollfd 结构体，因此不会存在1024的限制</p><h3 id="poll的缺点"><a href="#poll的缺点" class="headerlink" title="poll的缺点"></a>poll的缺点</h3><ul><li>每次调用poll，都需要把fd集合从用户态拷贝到内核态，多个fd时开销很大</li><li>对socket扫描时是线性扫描，采用轮询的方式，效率较低（高并发时）</li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="comment">// 每一个epoll对象都有一个独立的eventpoll结构体</span></span><br><span class="line"><span class="comment">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span></span><br><span class="line"><span class="comment">// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span>  rbr;</span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// API</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>; <span class="comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>; <span class="comment">// epoll_ctl 负责把 socket 增加、删除到内核红黑树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;<span class="comment">// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="介绍以及原理简单理解"><a href="#介绍以及原理简单理解" class="headerlink" title="介绍以及原理简单理解"></a>介绍以及原理简单理解</h3><p>注意这里介绍一下基础的功能(我查询资料的时候eventpoll还有一些其他的像阻塞进程队列的功能，有些有有些没有，我拿最为基础的功能来理解了)和自己的理解，可能有些不对的地方</p><p>以上两种方式没有解决需要多次在用户态和内核态切换造成大量数据开销和轮询扫描socket导致效率低的问题 epoll 就解决了这个问题</p><h4 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h4><ul><li>eventpoll在创建好之后就会直接放进内核态，因此不需要像select 和 poll那样反复的</li><li>首先eventpoll会维护两个“存储的桶” 一个用来存储<strong>需要监控的文件描述符</strong> 一个用来存储<strong>发生事件</strong>的文件描述符</li><li>eventpoll会为 需要监控的文件描述符 维护一个独特的 回调机制，这里不再需要轮询遍历查询，当某个 文件描述符 的事件发生时，内核会通过回调函数，将这个 文件描述符 放入 存储 发生事件 的 桶 里面 (这个回调机制我也没搞懂)</li><li>后面 epoll_wait 只需要 将 发生事件 的 桶 里面的事件返回就好</li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>对于存储 需要监控的文件描述符 的 桶<ul><li>要方便的添加和移除，还要便于搜索还要避免重复添加 因此 选择 红黑树</li></ul></li><li>对于存储 发生事件的文件描述符 的 桶<ul><li>可能随时添加可能随时删除，因此就绪列表应是一种能够快速插入和删除的数据结构，epoll选择了双向链表来实现就绪队列</li></ul></li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><ul><li>还是比如咱们有 5 个 文件描述符需要监控 3 5 7 8 10</li><li>先创建一个eventpoll(epoll_create)，这个时候eventpoll已经在内核态里面了</li><li>咱们通过epoll_ctl将这5个文件描述符逐一ADD进eventpoll之中，eventpoll会使用一个红黑树来存储（rbr）</li><li>调用epoll_wait来监听 (epoll_wait会阻塞进程哈)</li><li>当有某个文件描述符发生了对应的监听的事件之后，eventpoll会将对应的文件描述符添加到发生事件的文件描述符 的 桶 也就是 队列 rdlist 之中</li><li>epoll_wait将对应文件描述符号写入 events(这是个数组，是epoll_wait的参数) 之中，返回的是发生事件的个数</li><li>因此，咱们可以直接访问events数组来处理对应的事件 并且 因为返回了发生事件的个数，也不怕数组越界</li></ul><h3 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h3><ul><li>创建epoll函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys / epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">size：最大监听的fd+1</span></span><br><span class="line"><span class="function"><span class="keyword">return</span>：成功返回文件描述符fd；失败返回-1，可根据错误码判断错误类型</span></span><br></pre></td></tr></table></figure><ul><li>epoll事件的注册函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">epfd：<span class="title">epoll_create</span><span class="params">()</span>返回的epoll fd</span></span><br><span class="line"><span class="function">op：操作值</span></span><br><span class="line"><span class="function">fd：需要监听的fd</span></span><br><span class="line"><span class="function">event：需要监听的事件</span></span><br><span class="line"><span class="function"><span class="keyword">return</span>：成功返回0；失败返回-1，可根据错误码判断错误类型</span></span><br></pre></td></tr></table></figure><ul><li>epoll事件的注册函数<ul><li>epoll_ctl()中操作数op的三种操作类型<ul><li>EPOLL_CTL_ADD：注册目标fd到epoll fd中，同时关联event到fd上</li><li>EPOLL_CTL_MOD：修改已经注册到fd的监听事件</li><li>EPOLL_CTL_DEL：从epoll fd中删除&#x2F;移除已注册的fd</li></ul></li><li>epoll_ctl()中事件event的枚举如下:<ul><li>EPOLLIN：表示关联的fd可以进行读操作</li><li>EPOLLOUT：表示关联的fd可以进行写操作</li><li>EPOLLRDHUP：表示socket关闭了连接（Linux2.6.17后上层只需通过EPOLLRDHUP判断对端是否关闭socket，减少一次系统调用）</li><li>EPOLLPRI：表示关联的fd有紧急优先事件可以进行读操作</li><li>EPOLLERR：表示关联的fd发生了错误，epoll_wait会一直等待这个事件，一般无需设置该属性</li><li>EPOLLHUP：表示关联的fd挂起，epoll_wait会一直等待这个事件，一般无需设置该属性</li><li>EPOLLET：设置关联的fd为ET的工作方式，epoll默认的工作方式是LT</li><li>EPOLLONESHOT：设置关联的fd为one-shot的工作方式，表示只监听一次事件，如果要再次监听，则需再次把该socket放入epoll队列中</li></ul></li></ul></li></ul><p>当socket接收到数据后，中断程序会给eventpoll的就绪列表“rdlist”添加socket引用，而不是直接唤醒进程</p><ul><li>epoll等待事件函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">epfd：epoll描述符</span></span><br><span class="line"><span class="function">events：分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中（events不可以是空指针，内核只负责把数据复制到这个 events数组中，不会去帮助我们在用户态中分配内存。内核这种做法效率很高）</span></span><br><span class="line"><span class="function">maxevents：本次可以返回的最大事件数目，通常与预分配的events数组的大小是相等的</span></span><br><span class="line"><span class="function">timeout：在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待</span></span><br><span class="line"><span class="function"><span class="keyword">return</span>：成功返回需要处理的事件数目，返回0表示已超时；失败则返回-1，可以根据错误码判断错误类型</span></span><br></pre></td></tr></table></figure><h3 id="epoll的触发模式"><a href="#epoll的触发模式" class="headerlink" title="epoll的触发模式"></a>epoll的触发模式</h3><p>触发模式也就是什么时候通知我们事件到来了，主要有两种触发模式：</p><ul><li>水平触发(LT)</li><li>边缘触发(ET)</li></ul><p>先介绍一下socket的收发信息：</p><ul><li>对于socket中的recv和send 这些函数，都有响应的缓冲区</li><li>比如：recv，外面的数据来了，会先放在内核之中的读缓冲区里面，然后咱们调用recv才能拿到数据</li><li>相应的send的时候，咱们会把数据发送到内核的写缓冲区里面，然后内核会调用网络操作把东西给发出去</li></ul><p>两种触发模式：</p><ul><li>水平触发（LT）<ul><li>对于读（EPOLLIN）事件：当内核之中的读缓冲区存在数据的时候，就会一直触发，就是不停的向用户通知，还有东西可以读。</li><li>对于写（EPOLLOUT）事件：当内核之中的写缓冲区还可以写，也就是说写缓冲区还没满的时候就会不停的触发</li><li>所以对于LT，并不会要求一次必须要把事情处理完，比如读的话，如果这次没读完，下次还可以继续读，因为epoll会一直通知我们读事件</li></ul></li><li>边缘触发（ET）<ul><li>对于读（EPOLLIN）事件：内核之中的读缓冲区状态变化的时候才会触发，比如：有新的数据来了，就会触发一次，但也只会触发这一次，如果这次你读不完数据也没办法，后续也不会触发。</li><li>对于写（EPOLLOUT）事件：内核之中的写缓冲区状态变化的时候才会触发，这个状态变化指的是 不可写-&gt;可写，就是缓冲区满-&gt;缓冲区不满。如果缓冲区满了的话会出现errno事件，事件为EAGAIN。</li><li>对于写（EPOLLOUT）事件：还有另外一种情况，就是第一次绑定EPOLLOUT事件的时候会触发，这个时候写缓冲区肯定是可写的，因此先触发一次，让用户先写。</li></ul></li></ul><p>默认情况下都是三个水平触发：LT，select和poll也只支持水平触发。</p><h3 id="epoll的常用框架"><a href="#epoll的常用框架" class="headerlink" title="epoll的常用框架"></a>epoll的常用框架</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">                ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">                sockfd = md-&gt;fd;</span><br><span class="line">                <span class="built_in">send</span>( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="type">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="chatRoom-项目-1"><a href="#chatRoom-项目-1" class="headerlink" title="chatRoom 项目"></a>chatRoom 项目</h1><p>好了，现在你已经学会了 epoll 开始写项目吧</p><p>epoll了解了，并且了解了socket那么这个项目就显得简单了</p><p>下面是添加了注释的代码，这个看一遍就能看懂，不需要多讲了</p><p>（这里我只在本机上进行测试，其实是可以把server放在服务器上的,然后通过公网访问）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大链接数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_CONN = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存客户端的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;  <span class="comment">//客户端 socket 文件间描述符</span></span><br><span class="line">    string name; <span class="comment">//客户端 name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端 socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定一下</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;addr,<span class="built_in">sizeof</span>(addr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sockfd,MAX_CONN) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="comment">//注意这里哈，本来应该使用epoll_create(size)来创建的 但是 咱们事先也不知道size是多少，这种情况很常见</span></span><br><span class="line">    <span class="comment">//因此epoll推出了epoll_create1的api，不需要再传size了 0 是flag 咱也不知道为啥要有这个 就这样用吧</span></span><br><span class="line">    <span class="type">int</span> epid = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(epid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll create error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sockfd 绑定事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN; <span class="comment">//监听读事件</span></span><br><span class="line">    ev.data.fd = sockfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把节点加入到 epoll 模型之中</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epid,EPOLL_CTL_ADD,sockfd,&amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存客户端信息</span></span><br><span class="line">    map&lt;<span class="type">int</span>,Client&gt; clients;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环监听</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 这个用来获取那些就绪的文件描述符</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evs[MAX_CONN];</span><br><span class="line">        <span class="comment">// epoll_wait 最后一个参数 -1 表示，不需要设置超时时间限制</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epid,evs,MAX_CONN,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理那些有响应的事件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> fd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">//如果是服务器的fd受到消息，那么则表示有客户端进行链接了</span></span><br><span class="line">            <span class="keyword">if</span>(fd == sockfd)&#123;</span><br><span class="line">                <span class="comment">//那就 accept 一下</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">                <span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">                <span class="type">int</span> client_sockfd = <span class="built_in">accept</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;client_addr,&amp;client_addr_len);</span><br><span class="line">                <span class="keyword">if</span>(client_sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将客户端的sockfd加入epoll</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev_client;</span><br><span class="line">                ev_client.events = EPOLLIN; <span class="comment">//监听读事件 客户端有没有消息过来</span></span><br><span class="line">                ev_client.data.fd = client_sockfd;</span><br><span class="line">                <span class="comment">//把节点加入到 epoll 模型之中</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epid,EPOLL_CTL_ADD,client_sockfd,&amp;ev_client) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl client error&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;client_addr.sin_addr.s_addr&lt;&lt;<span class="string">&quot; 正在连接...&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="comment">// 保存客户端信息</span></span><br><span class="line">                Client client;</span><br><span class="line">                client.sockfd = client_sockfd;</span><br><span class="line">                client.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">// 存储进map</span></span><br><span class="line">                clients[client_sockfd] = client;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不是服务器的sockfd 那就是客户端来消息了</span></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">1024</span>];  <span class="comment">//接收信息的缓冲区</span></span><br><span class="line">                <span class="type">int</span> recv_len = <span class="built_in">recv</span>(fd,buffer,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(recv_len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;recv client error&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(recv_len == <span class="number">0</span>)&#123; <span class="comment">//代表要断开连接了</span></span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epid,EPOLL_CTL_DEL,fd,<span class="number">0</span>); <span class="comment">// 把fd移除</span></span><br><span class="line">                    clients.<span class="built_in">erase</span>(fd); <span class="comment">//map里面也移除一下</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//正常的发消息</span></span><br><span class="line">                    string <span class="built_in">msg</span>(buffer,recv_len);<span class="comment">//先转成string</span></span><br><span class="line">                    <span class="comment">//客户端，还没有名字，先把名字设置了</span></span><br><span class="line">                    <span class="keyword">if</span>(clients[fd].name == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                        clients[fd].name = msg;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; <span class="comment">//否则服务端就将信息转发到除发送端之外所有的客户端</span></span><br><span class="line">                        string name = clients[fd].name;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:clients)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(c.first != fd)&#123;</span><br><span class="line">                                <span class="built_in">send</span>(c.first,(<span class="string">&#x27;[&#x27;</span>+name+<span class="string">&#x27;]&#x27;</span>+<span class="string">&quot;: &quot;</span>+msg).<span class="built_in">c_str</span>(),msg.<span class="built_in">size</span>()+name.<span class="built_in">size</span>()<span class="number">+4</span>,<span class="number">0</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="built_in">close</span>(epid);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024        <span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="type">char</span> sendMsgBuff[BUF_SIZE];  <span class="comment">//发送消息缓冲区</span></span><br><span class="line"><span class="type">char</span> recvMsgBuff[BUF_SIZE];  <span class="comment">//接收消息缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;            <span class="comment">//false表示结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendMsg</span><span class="params">(<span class="type">int</span> clientfd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//清空buf</span></span><br><span class="line">    <span class="built_in">memset</span>(sendMsgBuff, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        cin&gt;&gt;sendMsgBuff;  <span class="comment">//注意这里可能不能处理 空格 哈，可以使用其他的函数，但是这不是重点，就是用cin这个简单的了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendMsgBuff, <span class="string">&quot;QUIT&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(sendMsgBuff, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) &#123; <span class="comment">//退出</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">//结束循环的标识</span></span><br><span class="line">            <span class="built_in">shutdown</span>(clientfd, SHUT_WR); <span class="comment">//这里注意哈，client主动与server断开连接，server会返回一个确认结束的信息哈</span></span><br><span class="line">                                         <span class="comment">//如果没有这一句的话recvMsg那边会一直卡在recv那里，程序无法结束 这里可以想一想，是个小坑</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="type">int</span> send_len = <span class="built_in">send</span>(clientfd,sendMsgBuff,<span class="built_in">strlen</span>(sendMsgBuff),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(send_len &lt; <span class="number">0</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">shutdown</span>(clientfd, SHUT_WR);</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空buf</span></span><br><span class="line">    <span class="built_in">memset</span>(sendMsgBuff, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recvMsg</span><span class="params">(<span class="type">int</span> clientfd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//清空buf</span></span><br><span class="line">    <span class="built_in">memset</span>(recvMsgBuff, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> recv_len = <span class="built_in">recv</span>(clientfd,recvMsgBuff,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(recv_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(recv_len==<span class="number">0</span>)&#123; <span class="comment">// 断开连接了</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;服务端断开连接了，清输入quit退出&quot;</span>&lt;&lt;endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            recvMsgBuff[recv_len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//字符串结尾</span></span><br><span class="line">            cout&lt;&lt;recvMsgBuff&lt;&lt;endl;      <span class="comment">//输出到终端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空buf</span></span><br><span class="line">    <span class="built_in">memset</span>(recvMsgBuff, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;  <span class="comment">//总得知道自己要连接的目标吧</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;serverAddr,<span class="built_in">sizeof</span>(serverAddr))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;欢迎来到聊天室，清输入你的聊天室用户名！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要接收消息和发送消息，因此需要设置两个线程</span></span><br><span class="line">    <span class="comment">//循环发消息</span></span><br><span class="line">    <span class="function">thread <span class="title">sendMsgThread</span><span class="params">(sendMsg,sockfd)</span></span>;</span><br><span class="line">    <span class="comment">//循环收消息</span></span><br><span class="line">    <span class="function">thread <span class="title">recvMsgThread</span><span class="params">(recvMsg,sockfd)</span></span>;</span><br><span class="line">    </span><br><span class="line">    sendMsgThread.<span class="built_in">join</span>();</span><br><span class="line">    recvMsgThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：<br>cd build</p><p>cmake ..</p><p>make</p><p>.&#x2F;server</p><p>.&#x2F;client</p><p>.&#x2F;client （多开几个终端，多个客户端连接）</p><p>不使用cmake也行 只要 编译 运行就好</p><p>git:<a href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1Q24y1v7Wa/?spm_id_from=333.337.search-card.all.click&vd_source=28887ecca1f25a715214067a2b3b58ac">https://www.bilibili.com/video/BV1Q24y1v7Wa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac</a></p><p><a href="https://blog.csdn.net/qq_44184756/article/details/130140778">https://blog.csdn.net/qq_44184756/article/details/130140778</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 王道2026学习笔记(还没学习完)</title>
      <link href="/2025/04/13/kinglyWay-dataStructure/"/>
      <url>/2025/04/13/kinglyWay-dataStructure/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-王道2026学习笔记"><a href="#数据结构-王道2026学习笔记" class="headerlink" title="数据结构 王道2026学习笔记"></a>数据结构 王道2026学习笔记</h1><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><h3 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h3><ul><li><p><strong>数据</strong>数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</p></li><li><p><strong>数据元素</strong>数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。</p></li><li><p><strong>数据项</strong>一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。</p></li><li><p><strong>数据对象</strong>数据对象是性质相同的数据元素的集合，是数据的子集。</p></li><li><p><strong>数据类型</strong> 数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p><ul><li>原子类型：其值不可再分的类型，如整型、浮点型、字符型等。</li><li>结构类型：其值可以再分的类型，如整形数组、浮点型数组、结构体、链表、栈、队列等。</li><li>抽象数据类型（Abstract Data Type, ADT）：抽象数据类型是指一个数学模型及定义在该模型上的一组操作。</li></ul></li></ul><h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><p>1.逻辑结构：数据元素之间的逻辑关系。</p><p>2.存储结构：数据元素及其关系在计算机存储器中的表示。</p><p>3.数据运算：针对某种逻辑结构在相应存储结构上的操作。</p><p><strong>逻辑结构</strong></p><p><img src="/../0_images/kinglyWay-dataStructure/1_1_%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-dataStructure/1_2_%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.png" alt="alt text"></p><ul><li>集合：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</li><li>线性结构：线性结构中的数据元素之间存在一对一的关系。</li><li>树形结构：树形结构中的数据元素之间存在一对多的层次关系。</li><li>图状结构或网状结构：图状结构中的数据元<a href="https://xiaolincoding.com/%E7%B4%A0%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82">https://xiaolincoding.com/素之间存在多对多的关系。</a></li></ul><p><strong>存储结构</strong></p><ul><li>顺序存储: 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</li><li>链式存储: 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</li><li>索引存储: 在存储数据元素的同时，还建立附加的索引表，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。</li><li>散列存储: 散列存储是根据元素的关键字直接计算出该元素的存储地址，因此散列存储不需要建立索引表。</li></ul><p><strong>数据运算</strong></p><ul><li>包括运算的定义和运算的实现两个部分。</li><li>数据运算的定义是针对逻辑的，指出运算的功能</li><li>数据运算的实现是针对存储的，指出运算的具体实现方法</li></ul><h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h3><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法具有以下五个特性(了解)：</p><ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出。  </li><li>可行性：算法的每一步操作都是可行的，即每一步都能够通过执行有限次数完成。</li><li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ul><p>算法达到的目标(了解)：</p><ul><li>正确性：算法对于合法的输入，能够产生满足要求的输出，对非法输入能够做出相应处理。</li><li>可读性：算法应具有良好的可读性，以帮助人们理解。</li><li>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</li><li>高效性：算法应尽量简短，算法的执行时间应尽可能短，算法所需的存储空间应尽量小。</li></ul><h3 id="算法效率的度量！！！"><a href="#算法效率的度量！！！" class="headerlink" title="算法效率的度量！！！"></a>算法效率的度量！！！</h3><p>时间复杂度：算法的时间复杂度是指算法执行时间随问题规模n的变化而变化的函数，记作：T(n)&#x3D;O(f(n))。其中f(n)是问题规模n的某个函数，O是数量级符号。</p><p>空间复杂度：算法的空间复杂度是指算法在计算机内执行时所需存储空间的度量，记作：S(n)&#x3D;O(g(n))。其中g(n)是问题规模n的某个函数，O是数量级符号。</p><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是具有相同数据类型的n个数据元素的有限序列，其中n(0≤n≤∞)为线性表的长度，当n&#x3D;0时，线性表是一个空表。a1是表头元素，an是表尾元素。</p><p>线性表的特点：</p><ul><li>表中元素个数有限。</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li><li>表中元素具有相同的数据类型，每个元素占有相同的存储空间。</li><li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素本身的特性。</li></ul><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><ul><li>InitList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间。</li><li>Length(L)：求表长。返回线性表L中数据元素的个数。</li><li>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</li><li>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</li><li>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置插入指定元素e。</li><li>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回其值。</li><li>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。</li><li>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。</li><li>DestroyList(&amp;L)：销毁操作。销毁线性表，释放线性表L所占用的内存空间。</li></ul><h2 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的数据元素，这种存储方式称为顺序存储或顺序表。</p><p><img src="/../0_images/kinglyWay-dataStructure/2_1_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="alt text"></p><h3 id="顺序表上基本操作的实现"><a href="#顺序表上基本操作的实现" class="headerlink" title="顺序表上基本操作的实现"></a>顺序表上基本操作的实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">error_code</span> &#123;success,overflow,underflow&#125;; <span class="comment">//成功，上溢出，下溢出 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">T data[MaxSize];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//初始化构造函数 </span></span><br><span class="line"><span class="built_in">SqList</span>()&#123;</span><br><span class="line">count = <span class="number">0</span>;  <span class="comment">//初始长度为0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数(O(n))</span></span><br><span class="line"><span class="function">error_code <span class="title">listInsert</span><span class="params">(<span class="type">int</span> i,T x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;count)&#123;     <span class="comment">//判断i位置是否合法</span></span><br><span class="line"><span class="keyword">return</span> overflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count==MaxSize)&#123;  <span class="comment">//判断是否上溢出</span></span><br><span class="line"><span class="keyword">return</span> overflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=count; j&gt;i; j--)&#123;</span><br><span class="line">data[j] = data[j<span class="number">-1</span>];  <span class="comment">//将i位置及之后的数据后移一位</span></span><br><span class="line">&#125;</span><br><span class="line">data[i] = x;              <span class="comment">//将x插入到i位置</span></span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除函数(O(n))</span></span><br><span class="line"><span class="function">error_code <span class="title">listDelete</span><span class="params">(<span class="type">int</span> i,T &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=count)&#123;     <span class="comment">//判断i位置是否合法(这里顺便判空了)</span></span><br><span class="line"><span class="keyword">return</span> underflow;</span><br><span class="line">&#125;</span><br><span class="line">x = data[i];           <span class="comment">//将i位置的数据赋值给x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i;j &lt;count<span class="number">-1</span>;j++)&#123;</span><br><span class="line">data[j] = data[j<span class="number">+1</span>];  <span class="comment">//将i位置之后的数据前移一位</span></span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找函数 (O(n))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listSearch</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(data[i]==x)&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//处理未找到的情况</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取长度函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listLength</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">listEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="function">T <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-线性表的链式表示和实现"><a href="#2-3-线性表的链式表示和实现" class="headerlink" title="2.3 线性表的链式表示和实现"></a>2.3 线性表的链式表示和实现</h2><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><p>单链表是一种线性表的链式存储结构。它由一系列结点（链表中的数据元素）组成，每个结点都由数据域和指针域两部分组成。</p><h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">error_code</span> &#123;success,overflow,underflow&#125;; <span class="comment">//成功，上溢出，下溢出 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; * head;</span><br><span class="line">    <span class="type">int</span> listSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>()&#123; <span class="comment">//初始化头指针为空</span></span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;; <span class="comment">// 创建dummy节点</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        listSize = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求表长(O(n) O(1))</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// int len=0;</span></span><br><span class="line">        <span class="comment">// Node&lt;T&gt; * temp = head;</span></span><br><span class="line">        <span class="comment">// while(temp!=nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     len++;</span></span><br><span class="line">        <span class="comment">//     temp = temp-&gt;next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return len;</span></span><br><span class="line">        <span class="keyword">return</span> listSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按序号查找</span></span><br><span class="line">    <span class="comment">// 获取链表中第i个元素</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; * <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果i小于0或者大于等于链表长度，则返回空指针</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;listSize<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值查找</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; * <span class="title">locateElem</span><span class="params">(T e)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;temp-&gt;data!=e)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="function">error_code <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i,T e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;listSize)&#123;</span><br><span class="line">            <span class="keyword">return</span> overflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造新节点</span></span><br><span class="line">        Node&lt;T&gt; * newNode = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        newNode-&gt;data = e;</span><br><span class="line">        <span class="comment">//找到插入位置的前一个节点</span></span><br><span class="line">        Node&lt;T&gt; * temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = newNode;</span><br><span class="line">        listSize++;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function">error_code <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;listSize<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到删除前的元素</span></span><br><span class="line">        Node&lt;T&gt; * temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; * delNode = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = delNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> delNode;</span><br><span class="line">        listSize--;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkList</span>() &#123; <span class="comment">// 添加析构函数防止内存泄漏</span></span><br><span class="line">        Node&lt;T&gt;* temp;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    list.<span class="built_in">printList</span>();  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    list.<span class="built_in">deleteElem</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">printList</span>();  <span class="comment">// 输出：1 2 4 5</span></span><br><span class="line">    cout &lt;&lt; list.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// 输出：4</span></span><br><span class="line">    Node&lt;<span class="type">int</span>&gt;* node = list.<span class="built_in">getElem</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) cout &lt;&lt; node-&gt;data &lt;&lt; endl; <span class="comment">// 输出：4</span></span><br><span class="line">    Node&lt;<span class="type">int</span>&gt;* target = list.<span class="built_in">locateElem</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">nullptr</span>) cout &lt;&lt; target-&gt;data &lt;&lt; endl; <span class="comment">// 不会输出，因为3已被删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表如果要访问某个节点的前驱节点，需要从头节点开始遍历，时间复杂度为O(n)。双链表则可以在O(1)时间内访问到前驱节点。</p><h3 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">error_code</span> &#123;success,overflow,underflow&#125;; <span class="comment">//成功，上溢出，下溢出 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; * next;</span><br><span class="line">    Node&lt;T&gt; * prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; * head;</span><br><span class="line">    <span class="type">int</span> listSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>()&#123; <span class="comment">//初始化头指针为空</span></span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;T&gt;;         </span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        listSize = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求表长(O(n) O(1))</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按序号查找</span></span><br><span class="line">    <span class="comment">// 获取链表中第i个元素</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; * <span class="title">getElem</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果i小于0或者大于等于链表长度，则返回空指针</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;listSize<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值查找</span></span><br><span class="line">    <span class="function">Node&lt;T&gt; * <span class="title">locateElem</span><span class="params">(T e)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>&amp;&amp;temp-&gt;data!=e)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="function">error_code <span class="title">insertElem</span><span class="params">(<span class="type">int</span> i,T e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;listSize)&#123;</span><br><span class="line">            <span class="keyword">return</span> overflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造新节点</span></span><br><span class="line">        Node&lt;T&gt; * newNode = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        newNode-&gt;data = e;</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        newNode-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//找到插入位置的前一个节点</span></span><br><span class="line">        Node&lt;T&gt; * temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newNode-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next-&gt;prev = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;prev = temp;</span><br><span class="line">        temp-&gt;next = newNode;</span><br><span class="line"></span><br><span class="line">        listSize++;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function">error_code <span class="title">deleteElem</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;listSize<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到删除前的元素</span></span><br><span class="line">        Node&lt;T&gt; * temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; * delNode = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = delNode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (delNode-&gt;next != <span class="literal">nullptr</span>) &#123; <span class="comment">// 修复空指针问题</span></span><br><span class="line">            delNode-&gt;next-&gt;prev = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> delNode;</span><br><span class="line">        listSize--;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkList</span>() &#123; <span class="comment">// 添加析构函数防止内存泄漏</span></span><br><span class="line">        Node&lt;T&gt;* temp;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    list.<span class="built_in">insertElem</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    list.<span class="built_in">printList</span>();  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">    list.<span class="built_in">deleteElem</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">printList</span>();  <span class="comment">// 输出：1 2 4 5</span></span><br><span class="line">    cout &lt;&lt; list.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// 输出：4</span></span><br><span class="line">    Node&lt;<span class="type">int</span>&gt;* node = list.<span class="built_in">getElem</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) cout &lt;&lt; node-&gt;data &lt;&lt; endl; <span class="comment">// 输出：4</span></span><br><span class="line">    Node&lt;<span class="type">int</span>&gt;* target = list.<span class="built_in">locateElem</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">nullptr</span>) cout &lt;&lt; target-&gt;data &lt;&lt; endl; <span class="comment">// 不会输出，因为3已被删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的链表，它的最后一个节点的指针指向链表的第一个节点，形成一个环。循环链表可以用来解决一些需要循环遍历的问题，例如约瑟夫环问题。</p><p>循环单链表与循环双链表的实现与单链表和双链表类似，只是在链表的末尾添加了一个指向头节点的指针，使得链表形成一个环。</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表是一种特殊的链表，它的节点存储在数组中，而不是在堆内存中。静态链表的大小在创建时就已经确定，不能动态地增加或减少。</p><p><img src="/../0_images/kinglyWay-dataStructure/2_2_%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.png" alt="alt text"></p><h1 id="第三章-栈、队列和数组"><a href="#第三章-栈、队列和数组" class="headerlink" title="第三章 栈、队列和数组"></a>第三章 栈、队列和数组</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的定义和基本操作"><a href="#栈的定义和基本操作" class="headerlink" title="栈的定义和基本操作"></a>栈的定义和基本操作</h3><p>只允许在一端进行插入或删除的线性表</p><p><img src="/../0_images/kinglyWay-dataStructure/3_1_%E6%A0%88.png" alt="alt text"></p><p>当有n个不同的元素入栈的时候，出栈排列有(1&#x2F;n+1)&#x2F;C^n_{2n}种</p><p><strong>共享栈</strong></p><p>一个数组两个栈用，一个用栈底一个用栈顶（好奇怪）</p><p>栈的实现（数组实现比较简单，这里采用链栈实现）</p><p>链栈的优点在于不存在上溢问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">operation_code</span> &#123;success,overflow,underflow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *top;</span><br><span class="line">    <span class="type">int</span> stackSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;();</span><br><span class="line">        top-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        stackSize = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackSize==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function">operation_code <span class="title">push</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;();</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        newNode-&gt;next = top-&gt;next;</span><br><span class="line">        top-&gt;next = newNode;</span><br><span class="line">        stackSize++;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读栈顶元素</span></span><br><span class="line">    <span class="function">operation_code <span class="title">getTop</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!top-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        x = top-&gt;next-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function">operation_code <span class="title">pop</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!top-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt;* popNode = top-&gt;next;</span><br><span class="line">        x = popNode-&gt;data;</span><br><span class="line">        top-&gt;next = popNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> popNode;</span><br><span class="line">        stackSize--;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">        T temp;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="built_in">pop</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkStack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试空栈弹出</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="built_in">pop</span>(x) == underflow) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 空栈弹出失败测试通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试入栈和栈顶</span></span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    stack.<span class="built_in">getTop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. 当前栈顶元素（应为10）: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续弹出测试</span></span><br><span class="line">    stack.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3. 弹出元素（应为30）: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    stack.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4. 弹出元素（应为20）: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试栈顶更新</span></span><br><span class="line">    stack.<span class="built_in">getTop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5. 当前栈顶元素（应为10）: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空栈测试</span></span><br><span class="line">    stack.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6. 弹出元素（应为10）: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;7. 栈已空测试通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次测试空栈操作</span></span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="built_in">getTop</span>(x) == underflow) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;8. 空栈获取栈顶测试通过&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>先进先出的受限线性表</p><p><img src="/../0_images/kinglyWay-dataStructure/3_2_%E9%98%9F%E5%88%97.png" alt="alt text"></p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>这里有一个假溢出的概念</p><p><img src="/../0_images/kinglyWay-dataStructure/3_3_%E9%98%9F%E5%88%97%E7%9A%84%E5%81%87%E6%BA%A2%E5%87%BA.png" alt="alt text"></p><p>这个时候如果使用rear &#x3D;&#x3D; front 判断栈满，就会出现假溢出现象</p><p>引入循环队列：</p><p><img src="/../0_images/kinglyWay-dataStructure/3_4_%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="alt text"></p><p>还是无法判断队列满不满（rear &#x3D;&#x3D; front 可能是空，也可能是满）</p><ul><li>牺牲一个存储单元<ul><li>(rear+1) % maxSize &#x3D;&#x3D; front 满</li><li>rear &#x3D;&#x3D; front  空</li><li>(rear - front + MaxSize) % MaxSize 队内元素</li></ul></li><li>增加size属性<ul><li>size &#x3D;&#x3D; 0 空</li><li>size &#x3D;&#x3D; maxSize 满</li></ul></li><li>增加tag<ul><li>出队的时候 将 tag &#x3D; 0, 入队的时候 将 tag &#x3D; 1</li><li>tag &#x3D;&#x3D; 0 &amp;&amp; rear &#x3D;&#x3D; front 空</li><li>tag &#x3D;&#x3D; 1 &amp;&amp; rear &#x3D;&#x3D; front 满</li></ul></li></ul><h3 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">operation_code</span> &#123;success,overflow,underflow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[MaxSize];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造初始化</span></span><br><span class="line">    <span class="built_in">Queue</span>()&#123;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判满</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function">operation_code <span class="title">push</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> overflow;</span><br><span class="line">        &#125;</span><br><span class="line">        data[rear]= x;</span><br><span class="line">        rear = (rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function">operation_code <span class="title">pop</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        x = data[front];</span><br><span class="line">        front = (front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填满队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">push</span>(i) != success) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列已满，无法入队元素 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试满队列入队</span></span><br><span class="line">    operation_code result = q.<span class="built_in">push</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;满队列入队结果: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot; (1 表示overflow)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">pop</span>(x) == success) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n队列已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试空队列出队</span></span><br><span class="line">    result = q.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;空队列出队结果: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot; (2 表示underflow)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常入队和出队测试</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    q.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队元素: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 应输出10</span></span><br><span class="line">    q.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;出队元素: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 应输出20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">operation_code</span> &#123;success,overflow,underflow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* front;</span><br><span class="line">    Node&lt;T&gt;* rear;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;</span><br><span class="line">        front = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;();</span><br><span class="line">        front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rear = front;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// return rear == front;</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function">operation_code <span class="title">push</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; * newNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;();</span><br><span class="line">        newNode-&gt;data = x;</span><br><span class="line">        newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        rear-&gt;next = newNode;</span><br><span class="line">        rear = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function">operation_code <span class="title">pop</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; *tmp = front-&gt;next;</span><br><span class="line">        x = tmp-&gt;data;</span><br><span class="line">        front-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (rear == tmp)&#123;</span><br><span class="line">            rear = front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> success;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">        <span class="keyword">while</span> (front != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node&lt;T&gt;* tmp = front;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试空队列出队</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;空队列出队结果: &quot;</span> &lt;&lt; q.<span class="built_in">pop</span>(val) &lt;&lt; <span class="string">&quot; (应返回2 underflow)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队测试</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队测试</span></span><br><span class="line">    q.<span class="built_in">pop</span>(val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次出队元素: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; (应输出10)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">pop</span>(val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二次出队元素: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; (应输出20)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次入队</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line">    q.<span class="built_in">pop</span>(val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三次出队元素: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; (应输出30)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">pop</span>(val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第四次出队元素: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; (应输出40)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试空队列</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;空队列出队结果: &quot;</span> &lt;&lt; q.<span class="built_in">pop</span>(val) &lt;&lt; <span class="string">&quot; (应返回2 underflow)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列（了解）"><a href="#双端队列（了解）" class="headerlink" title="双端队列（了解）"></a>双端队列（了解）</h3><p><img src="/../0_images/kinglyWay-dataStructure/3_5_%E5%8F%8C%E7%AB%AF%E5%8F%A3%E9%98%9F%E5%88%97.png" alt="alt text"></p><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><p>看一看书，队列的遍历非常重要！！！</p><p><img src="/../0_images/kinglyWay-dataStructure/3_6_%E9%98%9F%E5%88%97%E5%9C%A8%E9%81%8D%E5%8E%86%E4%B9%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="alt text"></p><h2 id="数组（了解）"><a href="#数组（了解）" class="headerlink" title="数组（了解）"></a>数组（了解）</h2><h1 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是由n（n≥0）个节点组成的有限集合。当n&#x3D;0时，称为空树；当n&gt;0时，树由一个根节点和若干棵子树组成。树中的每一个节点都只有一个父节点，除了根节点没有父节点。</p><p>任意一个非空树应当满足：</p><ul><li><p>有且仅有一个特定的成为根的节点</p></li><li><p>当 n &gt; 1 时，其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每一个集合 Ti（1 ≤ i ≤ m）本身又是一棵树，并且称为根的子树。</p></li></ul><p>树的这种定义方式称为递归定义。 具有以下特点：</p><ul><li><p>树的根节点没有前驱节点，除根节点外，每个节点有且仅有一个前驱节点</p></li><li><p>树中所有节点都有零个或多个后继节点</p></li></ul><h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p><img src="/../0_images/kinglyWay-dataStructure/5_1_%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png" alt="alt text"></p><ul><li>祖先、子孙、双亲、孩子、兄弟和堂兄弟</li><li>节点的层次、深度和高度</li><li>节点的度和树的度</li><li>分支节点和叶节点</li><li>有序树和无序树</li><li>路径和路径长度</li><li>森林</li></ul><p>树的性质(了解)：</p><ul><li>树的节点数等于所有节点的度数加1</li><li>度为m的树中第i层上至多有m^(i-1)个节点（i≥1）</li><li>高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个节点</li><li>具有n个节点的m叉树的最小高度为logm(n(m-1)+1)</li><li>度为m的树中第i层上至多有m^(i-1)个节点（i≥1）</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种特殊的树，它的每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树可以是有序的，也可以是无序的。在有序二叉树中，左子树上的节点都小于根节点，右子树上的节点都大于根节点。</p><p>二叉树与度为2的树的区别：</p><ul><li>度为2的树至少要含有3个节点，而二叉树可以为空</li><li>度为2的树种孩子的左右次序是相对的(若是只有一个子树，则左右次序无所谓)，而二叉树中孩子的左右次序是绝对的(若是只有一个子树，则也要分左子树或者是右子树)</li></ul><p>几种特殊的二叉树：</p><ul><li><p>满二叉树：一棵高度为h，且含有2^h-1个节点的二叉树</p><ul><li>对满二叉树的节点进行编号，若从根节点开始，自上而下，自左至右的顺序进行，则对于编号为i的节点，其左孩子编号为2i，右孩子编号为2i+1</li></ul></li><li><p>完全二叉树：一棵高度为h，且含有n个节点的二叉树，当且仅当其每一个节点都与高度为h的满二叉树中编号为1~n的节点一一对应</p></li><li><p>二叉排序树：又称二叉搜索树，左子树上所有节点的值均小于它的根节点的值，右子树上所有节点的值均大于它的根节点的值</p></li><li><p>平衡二叉树：又称AVL树，任何节点的两个子树的高度差不超过1</p></li></ul><p>二叉树的性质：：</p><ul><li><p>非空二叉树的叶节点数等于其双分支节点(度为2的节点)的个数加1</p></li><li><p>非空二叉树中第i层上至多有2^(i-1)个节点</p></li><li><p>高度为h的二叉树至多有2^h-1个节点(满二叉树)</p></li><li><p>具有n个节点的完全二叉树的高度为log2(n+1)向上取整</p></li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p><strong>顺序存储结构</strong></p><p>二叉树的顺序存储结构使用数组来存储二叉树的节点，数组的下标表示节点的编号，数组的值表示节点的值。</p><p>对于完全二叉树，可以使用顺序存储结构来存储，对于非完全二叉树，可以使用顺序存储结构来存储，但是需要浪费一些空间。</p><p><strong>链式存储结构</strong></p><p>二叉树的链式存储结构使用链表来存储二叉树的节点，每个节点包含一个数据域和两个指针域，分别指向左子节点和右子节点。</p><p><img src="/../0_images/kinglyWay-dataStructure/5_2_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="alt text"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指按照某种顺序访问二叉树中的所有节点，使得每个节点被访问一次且仅被访问一次。</p><p>二叉树的遍历有四种方式：前序遍历、中序遍历、后序遍历和层序遍历。</p><p>(二叉树的遍历算法，后面会有代码实现)</p><ul><li><p>前序遍历：先访问根节点，然后递归地访问左子树和右子树</p></li><li><p>中序遍历：先递归地访问左子树，然后访问根节点，最后递归地访问右子树</p></li><li><p>后序遍历：先递归地访问左子树和右子树，然后访问根节点</p></li><li><p>层序遍历：从根节点开始，逐层访问二叉树的每一层，每一层的节点按照从左到右的顺序访问</p></li></ul><h3 id="由遍历构造的二叉树"><a href="#由遍历构造的二叉树" class="headerlink" title="由遍历构造的二叉树"></a>由遍历构造的二叉树</h3><p>四种遍历，任意给一种都不能确定，但是只要若已知 中序遍历 和 其他三种遍历的任意一种就可以确定唯一一棵二叉树</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">treeNode * left;</span><br><span class="line">treeNode * right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">treeNode</span>(<span class="type">char</span> newData)&#123;</span><br><span class="line">data = newData;</span><br><span class="line">left = <span class="literal">nullptr</span>;</span><br><span class="line">right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">treeNode* root;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode * <span class="title">createTree</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> val;</span><br><span class="line">cin&gt;&gt;val;</span><br><span class="line"><span class="keyword">if</span>(val==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">treeNode * current = <span class="keyword">new</span> <span class="built_in">treeNode</span>(val);</span><br><span class="line">current-&gt;left = <span class="built_in">createTree</span>();</span><br><span class="line">current-&gt;right = <span class="built_in">createTree</span>();</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">preOrder_private</span>(T-&gt;left);</span><br><span class="line"><span class="built_in">preOrder_private</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">inOrder_private</span>(T-&gt;left);</span><br><span class="line">cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">inOrder_private</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">postOrder_private</span>(T-&gt;left);</span><br><span class="line">cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">postOrder_private</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;treeNode*&gt; orderQueue;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">while</span>(!orderQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">treeNode* temp = orderQueue.<span class="built_in">front</span>();</span><br><span class="line">orderQueue.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeightRecursion_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> leftTreeHeight = <span class="built_in">getHeightRecursion_private</span>(T-&gt;left);</span><br><span class="line"><span class="type">int</span> rightTreeHeight = <span class="built_in">getHeightRecursion_private</span>(T-&gt;right);</span><br><span class="line"><span class="type">int</span> resultLength = leftTreeHeight&gt;rightTreeHeight?leftTreeHeight<span class="number">+1</span>:rightTreeHeight<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">return</span> resultLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeightLevel_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> resultHeight = <span class="number">0</span>; </span><br><span class="line">queue&lt;treeNode*&gt; orderQueue;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(T);</span><br><span class="line"><span class="keyword">while</span>(!orderQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">resultHeight++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;orderQueue.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">treeNode* temp = orderQueue.<span class="built_in">front</span>();</span><br><span class="line">orderQueue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">orderQueue.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resultHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize_private</span><span class="params">(treeNode* T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> leftSize = <span class="built_in">getSize_private</span>(T-&gt;left);</span><br><span class="line"><span class="type">int</span> rightSize = <span class="built_in">getSize_private</span>(T-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftSize + rightSize + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BinaryTree</span>()&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">root = <span class="built_in">createTree</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">preOrder_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">inOrder_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">postOrder_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">levelOrder_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeightRecursion</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getHeightRecursion_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeightLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getHeightLevel_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getSize_private</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入二叉树的前序序列（空节点用#表示，例如ABD##E##C#F##）:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree bt;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历结果: &quot;</span>;</span><br><span class="line">    bt.<span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历结果: &quot;</span>;</span><br><span class="line">    bt.<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历结果: &quot;</span>;</span><br><span class="line">    bt.<span class="built_in">postOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;层序遍历结果: &quot;</span>;</span><br><span class="line">    bt.<span class="built_in">levelOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;递归计算的高度: &quot;</span> &lt;&lt; bt.<span class="built_in">getHeightRecursion</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;层序计算的高度: &quot;</span> &lt;&lt; bt.<span class="built_in">getHeightLevel</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点总数: &quot;</span> &lt;&lt; bt.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// ABD##E##C#F##</span></span><br><span class="line"><span class="comment">// 前序遍历结果: A-&gt;B-&gt;D-&gt;E-&gt;C-&gt;F-&gt;END</span></span><br><span class="line"><span class="comment">// 中序遍历结果: D-&gt;B-&gt;E-&gt;A-&gt;F-&gt;C-&gt;END</span></span><br><span class="line"><span class="comment">// 后序遍历结果: D-&gt;E-&gt;B-&gt;F-&gt;C-&gt;A-&gt;END</span></span><br><span class="line"><span class="comment">// 层序遍历结果: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;END</span></span><br><span class="line"><span class="comment">// 递归计算的高度: 3</span></span><br><span class="line"><span class="comment">// 层序计算的高度: 3</span></span><br><span class="line"><span class="comment">// 节点总数: 6</span></span><br></pre></td></tr></table></figure><h3 id="线索二叉树-看书"><a href="#线索二叉树-看书" class="headerlink" title="线索二叉树(看书)"></a>线索二叉树(看书)</h3><h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul><li><p>双亲表示法：使用一个一维数组来存储树的节点，每个节点包含一个数据域和一个指向其父节点的指针域。</p></li><li><p>孩子表示法：使用一个一维数组来存储树的节点，每个节点包含一个数据域和一个指向其孩子节点的指针域。</p></li><li><p>孩子兄弟表示法：使用一个一维数组来存储树的节点，每个节点包含一个数据域、一个指向其父节点的指针域和一个指向其第一个孩子节点的指针域，以及一个指向其右兄弟节点的指针域。</p></li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_3_%E5%8F%8C%E4%BA%B2%E6%8C%87%E9%92%88.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-dataStructure/5_4_%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%92%8C%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="alt text"></p><h3 id="树和二叉树的相互转化"><a href="#树和二叉树的相互转化" class="headerlink" title="树和二叉树的相互转化"></a>树和二叉树的相互转化</h3><ul><li><p>树转化为二叉树：将树中的每个节点都添加一个指向其第一个孩子节点的指针域和一个指向其右兄弟节点的指针域，这样就可以将树转化为二叉树。</p></li><li><p>二叉树转化为树：将二叉树中的每个节点都删除其指向其右兄弟节点的指针域，这样就可以将二叉树转化为树。</p></li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_4_%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="alt text"></p><p>扩展：</p><ul><li><p>森林转化为二叉树：将森林中的每棵树转化为二叉树，然后将这些二叉树的根节点连接起来，形成一个二叉树。</p></li><li><p>二叉树转化为森林：将二叉树中的每个节点都删除其指向其右兄弟节点的指针域，这样就可以将二叉树转化为森林。</p></li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_5_%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="alt text"></p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul><li>先根遍历：先访问根节点，然后依次访问根节点的孩子节点，再依次访问每个孩子节点的子树。</li><li>后根遍历：先依次访问根节点的孩子节点，再访问根节点，最后依次访问每个孩子节点的子树。</li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_7_%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="alt text"></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ul><li>先根遍历：先访问森林中每棵树的根节点，然后依次访问每棵树的根节点的孩子节点，再依次访问每个孩子节点的子树。</li><li>中序遍历：先依次访问森林中每棵树的根节点的孩子节点，再访问每棵树的根节点，最后依次访问每个孩子节点的子树。</li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_8_%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-dataStructure/5_6_%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="alt text"></p><h2 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>一些概念</p><ul><li>路径：从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径。</li><li>权重：在树的节点上赋予的有某种意义的数值。</li><li>路径长度：路径上的分支数目称为路径长度。</li><li>树的带权路径长度：树的路径长度乘上该路径上的权值。</li><li>权重最小的路径：带权路径长度最小的路径。</li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_9_%E6%9D%83.png" alt="alt text"></p><p>哈夫曼树的构造：</p><ul><li>从给定的节点集合中选出两个权值最小的节点，将它们合并成一个新的节点，新的节点的权值为两个节点的权值之和。</li><li>将新的节点重新插入到节点集合中，重复上述步骤，直到节点集合中只剩下一个节点，这个节点就是哈夫曼树的根节点。</li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_10_%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0.png" alt="alt text"></p><p>哈夫曼编码：</p><ul><li>哈夫曼编码是一种无损压缩编码，它根据字符出现的频率来构造编码，使得出现频率高的字符用较短的编码表示，出现频率低的字符用较长的编码表示。</li><li>哈夫曼编码的构造过程与哈夫曼树的构造过程类似，只是将节点的权值替换为字符出现的频率。</li><li>哈夫曼编码的解码过程与哈夫曼树的遍历过程类似，只是将遍历过程中遇到的叶子节点替换为对应的字符。</li></ul><p><img src="/../0_images/kinglyWay-dataStructure/5_11_%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png" alt="alt text"></p><h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>图的定义：图是由顶点的有穷非空集合和顶点之间边的集合组成的数据结构，记作G&#x3D;(V,E)，其中V是顶点的集合，E是边的集合。</p><p>术语(GPT生成的，看书吧)：</p><ul><li>有向图:有向图是由顶点的有穷非空集合和顶点之间的有向边组成的图。</li><li>无向图:无向图是由顶点的有穷非空集合和顶点之间的无向边组成的图。</li><li>带权图:带权图是由顶点的有穷非空集合和顶点之间的带权边组成的图。</li><li>简单图:简单图是指没有重复边和重复顶点的图。</li><li>多重图:多重图是指有重复边的图。</li><li>完全图:完全图是指任意两个顶点之间都有一条边的图。</li><li>子图:子图是指由原图的顶点集合和边集合的子集组成的图。</li><li>连通图:连通图是指任意两个顶点之间都有一条路径的图。</li><li>连通分量:连通分量是指原图的最大连通子图。</li><li>入度:入度是指以某个顶点为终点的边的数目。</li><li>出度:出度是指以某个顶点为起点的边的数目。</li><li>度:度是指某个顶点的入度与出度之和。</li><li>路径:路径是指图中顶点序列，其中相邻两个顶点之间有边相连。</li><li>环:环是指路径中第一个顶点和最后一个顶点相同，且路径中不重复出现的顶点。</li><li>简单路径:简单路径是指路径中不重复出现的顶点。</li><li>简单环:简单环是指路径中不重复出现的顶点，且路径中第一个顶点和最后一个顶点相同。</li><li>距离:距离是指两个顶点之间的路径长度。</li><li>有向无环图:有向无环图是指没有环的有向图。</li><li>连通分量:连通分量是指原图的最大连通子图。</li><li>强连通图:强连通图是指任意两个顶点之间都有一条有向路径的图。</li><li>强连通分量:强连通分量是指原图的最大强连通子图。</li><li>生成图:生成图是指由原图的顶点集合和边集合的子集组成的图。</li><li>生成树:生成树是指原图的最大连通子图。</li><li>最小生成树:最小生成树是指带权图的最小生成树。</li><li>最短路径:最短路径是指两个顶点之间的路径长度最小的路径。</li></ul><h2 id="图的存储以及基本操作"><a href="#图的存储以及基本操作" class="headerlink" title="图的存储以及基本操作"></a>图的存储以及基本操作</h2><p>存储结构主要是邻接矩阵和邻接表，除此之外还有十字链表和邻接多重表。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是一种使用二维数组来表示图的存储结构，其中每个元素表示两个顶点之间是否存在一条边。</p><p><img src="/../0_images/kinglyWay-dataStructure/6_1_%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="alt text"></p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表是一种使用链表来表示图的存储结构，其中每个顶点都有一个链表，链表中的每个元素表示与该顶点相邻的顶点。</p><p><img src="/../0_images/kinglyWay-dataStructure/6_2_%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nodeNum;j++)&#123;</span><br><span class="line">                data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 0 -&gt; 1</span></span><br><span class="line">        data[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;   <span class="comment">// 0 -&gt; 3</span></span><br><span class="line">        data[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;   <span class="comment">// 1 -&gt; 4</span></span><br><span class="line">        data[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;   <span class="comment">// 2 -&gt; 4</span></span><br><span class="line">        data[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 3 -&gt; 1</span></span><br><span class="line">        data[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;   <span class="comment">// 4 -&gt; 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = y<span class="number">+1</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphTable</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphTable</span>()&#123;</span><br><span class="line">        data[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// 0 -&gt; 1</span></span><br><span class="line">        data[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);   <span class="comment">// 0 -&gt; 3</span></span><br><span class="line">        data[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);   <span class="comment">// 1 -&gt; 4</span></span><br><span class="line">        data[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);   <span class="comment">// 2 -&gt; 4</span></span><br><span class="line">        data[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// 3 -&gt; 1</span></span><br><span class="line">        data[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);   <span class="comment">// 4 -&gt; 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= nodeNum || data[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= nodeNum || y &lt; <span class="number">0</span> || y &gt;= nodeNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[x][i] == y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; data[x].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> data[x][i + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试 GraphMatrix</span></span><br><span class="line">    GraphMatrix gm;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Testing GraphMatrix:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; neighbors: &quot;</span>;</span><br><span class="line">        <span class="type">int</span> current = gm.<span class="built_in">firstNeighbor</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; current;</span><br><span class="line">        <span class="keyword">while</span> ((current = gm.<span class="built_in">nextNeighbor</span>(x, current)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; current;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 GraphTable</span></span><br><span class="line">    GraphTable gt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nTesting GraphTable:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; neighbors: &quot;</span>;</span><br><span class="line">        <span class="type">int</span> current = gt.<span class="built_in">firstNeighbor</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; current;</span><br><span class="line">        <span class="keyword">while</span> ((current = gt.<span class="built_in">nextNeighbor</span>(x, current)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; current;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子有点取巧了，对于临接表法的处理，因为是存储的node是int型的，而且连续的，所以直接使用下标作为顶点表了</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>广度优先遍历(BFS)和深度优先遍历(DFS)是两种常见的图遍历算法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">bool</span> visited[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nodeNum;j++)&#123;</span><br><span class="line">                data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 0 -&gt; 1</span></span><br><span class="line">        data[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;   <span class="comment">// 0 -&gt; 3</span></span><br><span class="line">        data[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;   <span class="comment">// 1 -&gt; 4</span></span><br><span class="line">        data[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;   <span class="comment">// 2 -&gt; 4</span></span><br><span class="line">        data[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 3 -&gt; 1</span></span><br><span class="line">        data[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;   <span class="comment">// 4 -&gt; 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = y<span class="number">+1</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//广度优先遍历BFS Traverse</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化 visited</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//遍历 为了防止这个图是非连通图，所以必须这么写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">BFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; bfsQueue;</span><br><span class="line">        bfsQueue.<span class="built_in">push</span>(node);</span><br><span class="line">        cout&lt;&lt;node&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfsQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> temp = bfsQueue.<span class="built_in">front</span>();</span><br><span class="line">            bfsQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">firstNeighbor</span>(temp); i != <span class="number">-1</span>; i = <span class="built_in">nextNeighbor</span>(temp,i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                    bfsQueue.<span class="built_in">push</span>(i);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深度优先搜索DFS Traverse</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化 visited</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//遍历 为了防止这个图是非连通图，所以必须这么写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">DFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;node&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        visited[node]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">firstNeighbor</span>(node); i != <span class="number">-1</span>; i = <span class="built_in">nextNeighbor</span>(node,i))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                <span class="built_in">DFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphTable</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data[<span class="number">5</span>];</span><br><span class="line">    <span class="type">bool</span> visited[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphTable</span>()&#123;</span><br><span class="line">        data[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// 0 -&gt; 1</span></span><br><span class="line">        data[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);   <span class="comment">// 0 -&gt; 3</span></span><br><span class="line">        data[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);   <span class="comment">// 1 -&gt; 4</span></span><br><span class="line">        data[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);   <span class="comment">// 2 -&gt; 4</span></span><br><span class="line">        data[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// 3 -&gt; 1</span></span><br><span class="line">        data[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);   <span class="comment">// 4 -&gt; 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= nodeNum || data[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= nodeNum || y &lt; <span class="number">0</span> || y &gt;= nodeNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[x][i] == y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; data[x].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> data[x][i + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先遍历BFS Traverse</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化 visited</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//遍历 为了防止这个图是非连通图，所以必须这么写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">BFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; bfsQueue;</span><br><span class="line">        bfsQueue.<span class="built_in">push</span>(node);</span><br><span class="line">        cout&lt;&lt;node&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfsQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> temp = bfsQueue.<span class="built_in">front</span>();</span><br><span class="line">            bfsQueue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">firstNeighbor</span>(temp); i != <span class="number">-1</span>; i = <span class="built_in">nextNeighbor</span>(temp,i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                    bfsQueue.<span class="built_in">push</span>(i);</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深度优先搜索DFS Traverse</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化 visited</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//遍历 为了防止这个图是非连通图，所以必须这么写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">DFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;node&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        visited[node]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">firstNeighbor</span>(node); i != <span class="number">-1</span>; i = <span class="built_in">nextNeighbor</span>(node,i))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                <span class="built_in">DFS</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 测试 GraphMatrix</span></span><br><span class="line">     GraphMatrix gm;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Testing GraphMatrix:&quot;</span> &lt;&lt; endl;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; neighbors: &quot;</span>;</span><br><span class="line">         <span class="type">int</span> current = gm.<span class="built_in">firstNeighbor</span>(x);</span><br><span class="line">         <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         cout &lt;&lt; current;</span><br><span class="line">         <span class="keyword">while</span> ((current = gm.<span class="built_in">nextNeighbor</span>(x, current)) != <span class="number">-1</span>) &#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; current;</span><br><span class="line">         &#125;</span><br><span class="line">         cout &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 测试 GraphMatrix 的 BFS 和 DFS</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;\nTesting GraphMatrix BFS and DFS:&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;BFS starting from 0: &quot;</span>;</span><br><span class="line">     gm.<span class="built_in">BFSTraverse</span>();</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;DFS starting from 0: &quot;</span>;</span><br><span class="line">     gm.<span class="built_in">DFSTraverse</span>();</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 测试 GraphTable</span></span><br><span class="line">     GraphTable gt;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;\nTesting GraphTable:&quot;</span> &lt;&lt; endl;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; neighbors: &quot;</span>;</span><br><span class="line">         <span class="type">int</span> current = gt.<span class="built_in">firstNeighbor</span>(x);</span><br><span class="line">         <span class="keyword">if</span> (current == <span class="number">-1</span>) &#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         cout &lt;&lt; current;</span><br><span class="line">         <span class="keyword">while</span> ((current = gt.<span class="built_in">nextNeighbor</span>(x, current)) != <span class="number">-1</span>) &#123;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; current;</span><br><span class="line">         &#125;</span><br><span class="line">         cout &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 测试 GraphTable 的 BFS 和 DFS</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;\nTesting GraphTable BFS and DFS:&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;BFS starting from 0: &quot;</span>;</span><br><span class="line">     gt.<span class="built_in">BFSTraverse</span>();</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;DFS starting from 0: &quot;</span>;</span><br><span class="line">     gt.<span class="built_in">DFSTraverse</span>();</span><br><span class="line">     cout&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本思路是这样的，这里要注意，不管是邻接表还是邻接矩阵，只要实现了基础的firstNeighbor与nextNeighbor函数，其流程基本上是差不多的，这个可以多看看，注意理解！！！</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>prim算法与Kruskal算法</p><p>prim算法：从任意一个顶点开始，逐步加入新的顶点，每次都选择权重最小的边，直到所有顶点都被加入为止。</p><p><img src="/../0_images/kinglyWay-dataStructure/6_3_Prim%E7%AE%97%E6%B3%95.png" alt="alt text"></p><p>Kruskal算法：将所有边按照权重从小到大排序，然后依次选择权重最小的边，如果这条边连接的两个顶点不在同一个连通分量中，则将其加入生成树中，直到所有顶点都在同一个连通分量中为止。</p><p><img src="/../0_images/kinglyWay-dataStructure/6_4_kruskal.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nodeNum;j++)&#123;</span><br><span class="line">                data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">6</span>;data[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;data[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        data[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">6</span>;data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;data[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">        data[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">5</span>;data[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">6</span>;data[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">4</span>;data[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">        data[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">5</span>;data[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>;data[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">        data[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">3</span>;data[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">6</span>;data[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">        data[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">6</span>;data[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">4</span>;data[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = y<span class="number">+1</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(GraphMatrix &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> parent[n];   <span class="comment">// 存储MST中节点的父节点</span></span><br><span class="line">    <span class="type">int</span> key[n];      <span class="comment">// 存储各节点到MST的最小权重</span></span><br><span class="line">    <span class="type">bool</span> mstSet[n];  <span class="comment">// 记录节点是否在MST中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        key[i] = <span class="number">9999</span>;</span><br><span class="line">        mstSet[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;      <span class="comment">// 选择节点0作为起始点</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;  <span class="comment">// 起始点没有父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建MST需要n-1次迭代 有n个点就得有n-1个边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> count=<span class="number">0</span>; count &lt; n<span class="number">-1</span>; count++) &#123;</span><br><span class="line">        <span class="comment">// 找出当前未加入MST且key最小的节点</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> minKey = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mstSet[i] &amp;&amp; key[i] &lt; minKey) &#123;</span><br><span class="line">                minKey = key[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;  <span class="comment">// 图不连通，无法形成MST</span></span><br><span class="line"></span><br><span class="line">        mstSet[u] = <span class="literal">true</span>;  <span class="comment">// 将节点u加入MST</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新u的邻接节点的key值和父节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v = graph.<span class="built_in">firstNeighbor</span>(u);v!=<span class="number">-1</span>;v = graph.<span class="built_in">nextNeighbor</span>(u, v))&#123;</span><br><span class="line">            <span class="type">int</span> weight = graph.<span class="built_in">getWeight</span>(u, v);</span><br><span class="line">            <span class="keyword">if</span>(!mstSet[v] &amp;&amp; weight &lt; key[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                key[v] = weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出MST</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Prim&#x27;s MST:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> w = graph.<span class="built_in">getWeight</span>(parent[i], i);</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; \tWeight: &quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">        totalWeight += w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法所需的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) : <span class="built_in">u</span>(u), <span class="built_in">v</span>(v), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x)</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(rootX != rootY)</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">(GraphMatrix &amp;graph)</span> </span>&#123;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    <span class="comment">// 收集所有无向边（只保存u &lt; v的情况避免重复）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>; u&lt;<span class="number">6</span>; u++) &#123;</span><br><span class="line">        <span class="type">int</span> v = graph.<span class="built_in">firstNeighbor</span>(u);</span><br><span class="line">        <span class="keyword">while</span>(v != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(u &lt; v) &#123;  <span class="comment">// 避免重复添加边</span></span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(u, v, graph.<span class="built_in">getWeight</span>(u, v));</span><br><span class="line">            &#125;</span><br><span class="line">            v = graph.<span class="built_in">nextNeighbor</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    vector&lt;Edge&gt; mst;</span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有边构建MST</span></span><br><span class="line">    <span class="keyword">for</span>(Edge &amp;e : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span>(uf.<span class="built_in">find</span>(e.u) != uf.<span class="built_in">find</span>(e.v)) &#123;</span><br><span class="line">            uf.<span class="built_in">unite</span>(e.u, e.v);</span><br><span class="line">            mst.<span class="built_in">push_back</span>(e);</span><br><span class="line">            totalWeight += e.weight;</span><br><span class="line">            <span class="keyword">if</span>(mst.<span class="built_in">size</span>() == <span class="number">5</span>) <span class="keyword">break</span>;  <span class="comment">// MST有n-1条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kruskal&#x27;s MST:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(Edge &amp;e : mst) &#123;</span><br><span class="line">        cout &lt;&lt; e.u &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; e.v &lt;&lt; <span class="string">&quot; \tWeight: &quot;</span> &lt;&lt; e.weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GraphMatrix graph;</span><br><span class="line">    <span class="built_in">prim</span>(graph);</span><br><span class="line">    <span class="built_in">kruskal</span>(graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>dijkstra算法和floyd算法</p><p><img src="/../0_images/kinglyWay-dataStructure/6_5_Dijkstra.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-dataStructure/6_6_Floyd.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nodeNum;j++)&#123;</span><br><span class="line">                data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">10</span>;data[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">        data[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">2</span>;data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        data[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">        data[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">6</span>;data[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">        data[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">3</span>;data[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">9</span>;data[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = y<span class="number">+1</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(GraphMatrix &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">999999</span>;</span><br><span class="line">    <span class="type">int</span> dist[nodeNum];</span><br><span class="line">    <span class="type">bool</span> visited[nodeNum] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">        dist[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; nodeNum; count++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>, minDist = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i] &amp;&amp; dist[i] &lt; minDist) &#123;</span><br><span class="line">                minDist = dist[i];</span><br><span class="line">                u = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v = graph.<span class="built_in">firstNeighbor</span>(u);v!=<span class="number">-1</span>;v = graph.<span class="built_in">nextNeighbor</span>(u, v))&#123;</span><br><span class="line">            <span class="type">int</span> weight = graph.<span class="built_in">getWeight</span>(u, v);</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dist[u] != INF &amp;&amp; dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dijkstra算法（起点0）的最短路径：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] != INF)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的最短距离: &quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 不可达&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(GraphMatrix &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">999999</span>;</span><br><span class="line">    <span class="type">int</span> dist[nodeNum][nodeNum];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一下，有边则距离设置为边的权重，反之，设置为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nodeNum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> w = graph.<span class="built_in">getWeight</span>(i, j);</span><br><span class="line">                dist[i][j] = (w != <span class="number">0</span>) ? w : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nodeNum; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nodeNum; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k]!=INF&amp;&amp;dist[k][j]!=INF&amp;&amp;dist[i][j]&gt;dist[i][k]+dist[k][j]) &#123;</span><br><span class="line">                    dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nFloyd算法的所有顶点对最短路径：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nodeNum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == INF) cout &lt;&lt; <span class="string">&quot;INF\t&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GraphMatrix graph;</span><br><span class="line">    <span class="built_in">dijkstra</span>(graph);</span><br><span class="line">    <span class="built_in">floyd</span>(graph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="/../0_images/kinglyWay-dataStructure/6_7_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> nodeNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GraphMatrix</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nodeNum;j++)&#123;</span><br><span class="line">                data[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;data[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        data[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        data[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        data[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;data[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstNeighbor</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = <span class="number">0</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nextNeighbor</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  i = y<span class="number">+1</span>; i &lt; nodeNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[x][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>||y&gt;nodeNum<span class="number">-1</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">indegree</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;nodeNum<span class="number">-1</span>||x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i][x] != <span class="number">0</span>) &#123; <span class="comment">// 计算入度</span></span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topologicalSort</span><span class="params">(GraphMatrix &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nodeNum = <span class="number">5</span>; <span class="comment">// 节点数固定为5</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(nodeNum)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; ++i) &#123;</span><br><span class="line">        inDegree[i] = graph.<span class="built_in">indegree</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nodeNum; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v = graph.<span class="built_in">firstNeighbor</span>(u);v!=<span class="number">-1</span>;v = graph.<span class="built_in">nextNeighbor</span>(u, v))&#123;</span><br><span class="line">            <span class="keyword">if</span> (--inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() != nodeNum) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 存在环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GraphMatrix graph;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sorted = <span class="built_in">topologicalSort</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sorted.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中存在环，无法进行拓扑排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拓扑排序结果：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : sorted) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键路径-看书吧哥，这个好复杂"><a href="#关键路径-看书吧哥，这个好复杂" class="headerlink" title="关键路径(看书吧哥，这个好复杂)"></a>关键路径(看书吧哥，这个好复杂)</h2><h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>1.一般顺序查找</p><p>很简单，直接遍历</p><p>2.有序线性表的顺序查找</p><p>也是遍历，但是如果之前的都是小于findKey,突然值大于了findKey,那么就不必再查找了，就直接停止遍历(因为是有序的)</p><ul><li>1 3 5 7 9 11 13 15 17 19 21 23 25</li><li>findKey &#x3D; 11 遍历的时候查找到11 成功返回index</li><li>findKey &#x3D; 12 遍历的时候查找到11之前一直小于12,但是到下一个点13就突然大于12,那么就直接返回-1(错误处理的结果)就好，查找不到</li></ul><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>这个就不过多介绍了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="type">int</span> findKey = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=<span class="number">9</span>,mid;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;=high)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==findKey)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;找到了! 位置为：&quot;</span>&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]&gt;findKey)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]&lt;findKey)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;没找到&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分块查找：</p><p>索引表折半，表内顺序</p><p><img src="/../0_images/kinglyWay-dataStructure/7_1_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.png" alt="alt text"></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    <span class="comment">//递归插入节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertNode</span><span class="params">(TreeNode* node,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insertNode</span>(node-&gt;left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insertNode</span>(node-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//忽略重复的值</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//辅助函数：找到子树的最小节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">findMin</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node-&gt;left) node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* node,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">deleteNode</span>(node-&gt;left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">deleteNode</span>(node-&gt;right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 情况1：无左子结点</span></span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left)&#123;</span><br><span class="line">                TreeNode* right = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2: 无右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!node-&gt;right)&#123; </span><br><span class="line">                TreeNode* left = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3: 有两个子节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到右边的最小的节点</span></span><br><span class="line">                TreeNode* minRight = <span class="built_in">findMin</span>(node-&gt;right);</span><br><span class="line">                <span class="comment">//替换值并删除原始节点</span></span><br><span class="line">                node-&gt;val = minRight-&gt;val;</span><br><span class="line">                node-&gt;right = <span class="built_in">deleteNode</span>(node-&gt;right,minRight-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;left);</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归释放节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroyTree</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">destroyTree</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">destroyTree</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BST</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">insertNode</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (curr-&gt;val &lt; val)&#123;</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印中序遍历的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;END&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BST</span>() &#123;</span><br><span class="line">        <span class="built_in">destroyTree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    BST bst;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入示例</span></span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    bst.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;初始中序遍历: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">printInorder</span>(); <span class="comment">// 2 3 4 5 6 7 8 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找示例</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找 4: &quot;</span> &lt;&lt; (bst.<span class="built_in">search</span>(<span class="number">4</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 存在</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找 9: &quot;</span> &lt;&lt; (bst.<span class="built_in">search</span>(<span class="number">9</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除示例</span></span><br><span class="line">    bst.<span class="built_in">remove</span>(<span class="number">3</span>); <span class="comment">// 删除有两个子节点的节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除3后的中序遍历: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">printInorder</span>(); <span class="comment">// 2 4 5 6 7 8 </span></span><br><span class="line"></span><br><span class="line">    bst.<span class="built_in">remove</span>(<span class="number">7</span>); <span class="comment">// 删除有两个子节点的节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除7后的中序遍历: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">printInorder</span>(); <span class="comment">// 2 4 5 6 8 </span></span><br><span class="line"></span><br><span class="line">    bst.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">// 删除叶子节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除2后的中序遍历: &quot;</span>;</span><br><span class="line">    bst.<span class="built_in">printInorder</span>(); <span class="comment">// 4 5 6 8 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode* left;</span><br><span class="line">    AVLNode* right;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">height</span>(<span class="number">1</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>&#123;</span><br><span class="line">    AVLNode* root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(AVLNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点的高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(AVLNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            node-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">getHeight</span>(node-&gt;left),<span class="built_in">getHeight</span>(node-&gt;right));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算平衡因子</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalanceFactor</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋操作</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">rightRotate</span><span class="params">(AVLNode* y)</span></span>&#123;</span><br><span class="line">        AVLNode* x = y-&gt;left;</span><br><span class="line">        AVLNode* T3 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">        x-&gt;right = y;</span><br><span class="line">        y-&gt;left = T3;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(y);</span><br><span class="line">        <span class="built_in">updateHeight</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋操作</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">leftRotate</span><span class="params">(AVLNode* x)</span></span>&#123;</span><br><span class="line">        AVLNode* y = x-&gt;right;</span><br><span class="line">        AVLNode* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">        y-&gt;left = x;</span><br><span class="line">        x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(x);</span><br><span class="line">        <span class="built_in">updateHeight</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">insertNode</span><span class="params">(AVLNode* node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AVLNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &lt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insertNode</span>(node-&gt;left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insertNode</span>(node-&gt;right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">//不允许重复的值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">updateHeight</span>(node);</span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalanceFactor</span>(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左左情况 右单旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右右情况 左单旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右情况 左边先左旋 然后整体再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点（递归）</span></span><br><span class="line">    <span class="function">AVLNode* <span class="title">deleteNode</span><span class="params">(AVLNode* node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">deleteNode</span>(node-&gt;left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val)&#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">deleteNode</span>(node-&gt;right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//找到待删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left||!node-&gt;right)&#123; <span class="comment">//子树有空的</span></span><br><span class="line">                AVLNode* temp = node-&gt;left ? node-&gt;left : node-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(!temp)&#123; <span class="comment">// 都为空 直接删除node</span></span><br><span class="line">                    temp = node;</span><br><span class="line">                    node = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    *node = *temp; <span class="comment">// 直接替换内容</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 子树都不为空</span></span><br><span class="line">                <span class="comment">//和BST一样找到右边最小的节点</span></span><br><span class="line">                AVLNode* minRight = node-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(minRight-&gt;left)&#123;</span><br><span class="line">                    minRight = minRight-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;val = minRight-&gt;val;</span><br><span class="line">                node-&gt;right = <span class="built_in">deleteNode</span>(node-&gt;right,minRight-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度并平衡</span></span><br><span class="line">        <span class="built_in">updateHeight</span>(node);</span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalanceFactor</span>(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右左情况 右边先右旋 然后整体再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左左情况 右单旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(node-&gt;left) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右情况 左边先左旋 然后整体再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(node-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右右情况 左单旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(node-&gt;right) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右左情况 右边先右旋 然后整体再右旋</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalanceFactor</span>(node-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(AVLNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;left);</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AVLTree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">insertNode</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        AVLNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curr-&gt;val) curr = curr-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印中序遍历结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AVLTree avl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line">    avl.<span class="built_in">insert</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入后的中序遍历: &quot;</span>;</span><br><span class="line">    avl.<span class="built_in">printInorder</span>(); <span class="comment">// 10 20 25 30 40 50 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找25: &quot;</span> &lt;&lt; (avl.<span class="built_in">search</span>(<span class="number">25</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 存在</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找100: &quot;</span> &lt;&lt; (avl.<span class="built_in">search</span>(<span class="number">100</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    avl.<span class="built_in">remove</span>(<span class="number">30</span>); <span class="comment">// 删除根节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除30后的中序遍历: &quot;</span>;</span><br><span class="line">    avl.<span class="built_in">printInorder</span>(); <span class="comment">// 10 20 25 40 50 </span></span><br><span class="line"></span><br><span class="line">    avl.<span class="built_in">remove</span>(<span class="number">25</span>); <span class="comment">// 删除叶子节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除25后的中序遍历: &quot;</span>;</span><br><span class="line">    avl.<span class="built_in">printInorder</span>(); <span class="comment">// 10 20 40 50 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, BLACK &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Color color;</span><br><span class="line">    RBNode *left, *right, *parent;</span><br><span class="line">    <span class="built_in">RBNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">color</span>(RED), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBlackTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBNode* root;</span><br><span class="line">    RBNode* nil; <span class="comment">// 哨兵节点（表示空叶子节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(RBNode* x)</span> </span>&#123;</span><br><span class="line">        RBNode* y = x-&gt;right;</span><br><span class="line">        x-&gt;right = y-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;left != nil) &#123;</span><br><span class="line">            y-&gt;left-&gt;parent = x;</span><br><span class="line">        &#125;</span><br><span class="line">        y-&gt;parent = x-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == nil) &#123;</span><br><span class="line">            root = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">            x-&gt;parent-&gt;left = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x-&gt;parent-&gt;right = y;</span><br><span class="line">        &#125;</span><br><span class="line">        y-&gt;left = x;</span><br><span class="line">        x-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(RBNode* x)</span> </span>&#123;</span><br><span class="line">        RBNode* y = x-&gt;left;</span><br><span class="line">        x-&gt;left = y-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;right != nil) &#123;</span><br><span class="line">            y-&gt;right-&gt;parent = x;</span><br><span class="line">        &#125;</span><br><span class="line">        y-&gt;parent = x-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == nil) &#123;</span><br><span class="line">            root = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right) &#123;</span><br><span class="line">            x-&gt;parent-&gt;right = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x-&gt;parent-&gt;left = y;</span><br><span class="line">        &#125;</span><br><span class="line">        y-&gt;right = x;</span><br><span class="line">        x-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入修复（处理颜色冲突）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertFixup</span><span class="params">(RBNode* z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">                RBNode* y = z-&gt;parent-&gt;parent-&gt;right; <span class="comment">// 叔叔节点</span></span><br><span class="line">                <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                    <span class="comment">// Case 1: 叔叔是红色</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    y-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;</span><br><span class="line">                        <span class="comment">// Case 2: 叔叔是黑色且z是右孩子</span></span><br><span class="line">                        z = z-&gt;parent;</span><br><span class="line">                        <span class="built_in">leftRotate</span>(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Case 3: 叔叔是黑色且z是左孩子</span></span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对称操作（父节点是右孩子）</span></span><br><span class="line">                RBNode* y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">                <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    y-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                        z = z-&gt;parent;</span><br><span class="line">                        <span class="built_in">rightRotate</span>(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(z-&gt;parent-&gt;parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;color = BLACK; <span class="comment">// 根节点始终黑色</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除修复（处理颜色失衡）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteFixup</span><span class="params">(RBNode* x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; x-&gt;color == BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">                RBNode* w = x-&gt;parent-&gt;right; <span class="comment">// 兄弟节点</span></span><br><span class="line">                <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                    <span class="comment">// Case 1: 兄弟是红色</span></span><br><span class="line">                    w-&gt;color = BLACK;</span><br><span class="line">                    x-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">                    w = x-&gt;parent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// Case 2: 兄弟的子节点都是黑色</span></span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (w-&gt;right-&gt;color == BLACK) &#123;</span><br><span class="line">                        <span class="comment">// Case 3: 兄弟的右孩子是黑色</span></span><br><span class="line">                        w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                        w-&gt;color = RED;</span><br><span class="line">                        <span class="built_in">rightRotate</span>(w);</span><br><span class="line">                        w = x-&gt;parent-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Case 4: 兄弟的右孩子是红色</span></span><br><span class="line">                    w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                    x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(x-&gt;parent);</span><br><span class="line">                    x = root; <span class="comment">// 终止循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 对称操作（x是右孩子）</span></span><br><span class="line">                RBNode* w = x-&gt;parent-&gt;left;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                    w-&gt;color = BLACK;</span><br><span class="line">                    x-&gt;parent-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">                    w = x-&gt;parent-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (w-&gt;right-&gt;color == BLACK &amp;&amp; w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (w-&gt;left-&gt;color == BLACK) &#123;</span><br><span class="line">                        w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                        w-&gt;color = RED;</span><br><span class="line">                        <span class="built_in">leftRotate</span>(w);</span><br><span class="line">                        w = x-&gt;parent-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    w-&gt;color = x-&gt;parent-&gt;color;</span><br><span class="line">                    x-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(x-&gt;parent);</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最小节点</span></span><br><span class="line">    <span class="function">RBNode* <span class="title">minimum</span><span class="params">(RBNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != nil) node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(RBNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == nil) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;left);</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; (node-&gt;color == RED ? <span class="string">&quot;(R) &quot;</span> : <span class="string">&quot;(B) &quot;</span>);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedBlackTree</span>() &#123;</span><br><span class="line">        nil = <span class="keyword">new</span> <span class="built_in">RBNode</span>(<span class="number">-1</span>);</span><br><span class="line">        nil-&gt;color = BLACK;</span><br><span class="line">        root = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        RBNode* z = <span class="keyword">new</span> <span class="built_in">RBNode</span>(val);</span><br><span class="line">        RBNode* y = nil;</span><br><span class="line">        RBNode* x = root;</span><br><span class="line">        <span class="keyword">while</span> (x != nil) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            <span class="keyword">if</span> (z-&gt;val &lt; x-&gt;val) &#123;</span><br><span class="line">                x = x-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x = x-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        z-&gt;parent = y;</span><br><span class="line">        <span class="keyword">if</span> (y == nil) &#123;</span><br><span class="line">            root = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;val &lt; y-&gt;val) &#123;</span><br><span class="line">            y-&gt;left = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y-&gt;right = z;</span><br><span class="line">        &#125;</span><br><span class="line">        z-&gt;left = nil;</span><br><span class="line">        z-&gt;right = nil;</span><br><span class="line">        <span class="built_in">insertFixup</span>(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        RBNode* z = root;</span><br><span class="line">        <span class="keyword">while</span> (z != nil) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z-&gt;val == val) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; z-&gt;val) z = z-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> z = z-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z == nil) <span class="keyword">return</span>; <span class="comment">// 未找到</span></span><br><span class="line"></span><br><span class="line">        RBNode* y = z;</span><br><span class="line">        Color yOriginalColor = y-&gt;color;</span><br><span class="line">        RBNode* x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;left == nil) &#123;</span><br><span class="line">            x = z-&gt;right;</span><br><span class="line">            <span class="built_in">transplant</span>(z, z-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;right == nil) &#123;</span><br><span class="line">            x = z-&gt;left;</span><br><span class="line">            <span class="built_in">transplant</span>(z, z-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y = <span class="built_in">minimum</span>(z-&gt;right);</span><br><span class="line">            yOriginalColor = y-&gt;color;</span><br><span class="line">            x = y-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;parent == z) &#123;</span><br><span class="line">                x-&gt;parent = y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">transplant</span>(y, y-&gt;right);</span><br><span class="line">                y-&gt;right = z-&gt;right;</span><br><span class="line">                y-&gt;right-&gt;parent = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">transplant</span>(z, y);</span><br><span class="line">            y-&gt;left = z-&gt;left;</span><br><span class="line">            y-&gt;left-&gt;parent = y;</span><br><span class="line">            y-&gt;color = z-&gt;color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> z;</span><br><span class="line">        <span class="keyword">if</span> (yOriginalColor == BLACK) &#123;</span><br><span class="line">            <span class="built_in">deleteFixup</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换节点辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transplant</span><span class="params">(RBNode* u, RBNode* v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;parent == nil) &#123;</span><br><span class="line">            root = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;</span><br><span class="line">            u-&gt;parent-&gt;left = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            u-&gt;parent-&gt;right = v;</span><br><span class="line">        &#125;</span><br><span class="line">        v-&gt;parent = u-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        RBNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr != nil) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curr-&gt;val) curr = curr-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印中序遍历结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedBlackTree rbt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入测试</span></span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line">    rbt.<span class="built_in">insert</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入后的中序遍历: &quot;</span>;</span><br><span class="line">    rbt.<span class="built_in">printInorder</span>(); <span class="comment">// 输出示例：10(B) 20(R) 25(R) 30(B) 40(R) 50(R)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找25: &quot;</span> &lt;&lt; (rbt.<span class="built_in">search</span>(<span class="number">25</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 存在</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找100: &quot;</span> &lt;&lt; (rbt.<span class="built_in">search</span>(<span class="number">100</span>) ? <span class="string">&quot;存在&quot;</span> : <span class="string">&quot;不存在&quot;</span>) &lt;&lt; endl; <span class="comment">// 不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除测试</span></span><br><span class="line">    rbt.<span class="built_in">remove</span>(<span class="number">30</span>); <span class="comment">// 删除根节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除30后的中序遍历: &quot;</span>;</span><br><span class="line">    rbt.<span class="built_in">printInorder</span>(); <span class="comment">// 示例输出：10(B) 20(R) 25(B) 40(R) 50(R)</span></span><br><span class="line"></span><br><span class="line">    rbt.<span class="built_in">remove</span>(<span class="number">25</span>); <span class="comment">// 删除叶子节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除25后的中序遍历: &quot;</span>;</span><br><span class="line">    rbt.<span class="built_in">printInorder</span>(); <span class="comment">// 示例输出：10(B) 20(B) 40(R) 50(R)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hush表"><a href="#hush表" class="headerlink" title="hush表"></a>hush表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TABLE_SIZE = <span class="number">10</span>; <span class="comment">// 固定大小的哈希表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span>&#123;</span><br><span class="line">    string key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    HashNode* next;</span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">const</span> string&amp; k,<span class="type">int</span> v):<span class="built_in">key</span>(k),<span class="built_in">value</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;HashNode*&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数（简单示例）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunction</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:key)&#123;</span><br><span class="line">            hash += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HashTable</span>() : <span class="built_in">buckets</span>(TABLE_SIZE, <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">HashTable</span>()&#123;</span><br><span class="line">        <span class="comment">// 析构时释放所有节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; ++i)&#123;</span><br><span class="line">            HashNode* entry = buckets[i];</span><br><span class="line">            <span class="keyword">while</span>(entry)&#123;</span><br><span class="line">                HashNode* prev = entry;</span><br><span class="line">                entry = entry-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        HashNode* entry = buckets[bucketIndex];</span><br><span class="line">        <span class="keyword">while</span> (entry)&#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;key == key) &#123;</span><br><span class="line">                entry-&gt;value = value; <span class="comment">// 更新现有值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建新节点并插入链表头部</span></span><br><span class="line">        HashNode* newNode = <span class="keyword">new</span> <span class="built_in">HashNode</span>(key, value);</span><br><span class="line">        newNode-&gt;next = buckets[bucketIndex]; <span class="comment">//头插法</span></span><br><span class="line">        buckets[bucketIndex] = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        HashNode* entry = buckets[bucketIndex];</span><br><span class="line">        <span class="keyword">while</span>(entry)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry-&gt;key == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> entry-&gt;value;</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 未找到返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = <span class="built_in">hashFunction</span>(key);</span><br><span class="line">        HashNode* entry = buckets[bucketIndex];</span><br><span class="line">        HashNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(entry)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry-&gt;key == key)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prev)&#123;</span><br><span class="line">                    prev-&gt;next = entry-&gt;next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    buckets[bucketIndex] = entry-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = entry;</span><br><span class="line">            entry = entry-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashTable myHashTable;</span><br><span class="line"></span><br><span class="line">    myHashTable.<span class="built_in">insert</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    myHashTable.<span class="built_in">insert</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    myHashTable.<span class="built_in">insert</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Alice&#x27;s age: &quot;</span> &lt;&lt; myHashTable.<span class="built_in">get</span>(<span class="string">&quot;Alice&quot;</span>) &lt;&lt; endl; <span class="comment">// 30</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Unknown key: &quot;</span> &lt;&lt; myHashTable.<span class="built_in">get</span>(<span class="string">&quot;Dave&quot;</span>) &lt;&lt; endl;   <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    myHashTable.<span class="built_in">remove</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After removal - Bob: &quot;</span> &lt;&lt; myHashTable.<span class="built_in">get</span>(<span class="string">&quot;Bob&quot;</span>) &lt;&lt; endl; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-查找"><a href="#第八章-查找" class="headerlink" title="第八章 查找"></a>第八章 查找</h1><h2 id="8-2-插入排序"><a href="#8-2-插入排序" class="headerlink" title="8.2 插入排序"></a>8.2 插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_1[<span class="number">11</span>] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data_1[j]&lt;data_1[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp = data_1[j<span class="number">-1</span>];</span><br><span class="line">                data_1[j<span class="number">-1</span>] = data_1[j];</span><br><span class="line">                data_1[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data_1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_2[<span class="number">11</span>] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = data_2[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>&amp;&amp; key &gt; data_2[j<span class="number">-1</span>])&#123;</span><br><span class="line">            data_2[j] = data_2[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data_2[j] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data_2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data[<span class="number">11</span>] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> key = data[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>,high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//通过折半查找找到插入位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &gt; data[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;high<span class="number">+1</span>;j--)&#123;</span><br><span class="line">            data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[high + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希儿排序"><a href="#希儿排序" class="headerlink" title="希儿排序"></a>希儿排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="comment">// 初始间隔为n/2，每次减半直到1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//每一组内部还是使用插入排序（这里直接使用的是直接插入排序，折半的话要处理下标，很麻烦）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = gap;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = data[i];</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;j&gt;=gap&amp;&amp;data[j-gap]&gt;tmp)&#123;</span><br><span class="line">                data[j] = data[j-gap];</span><br><span class="line">                j = j - gap; </span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-交换排序"><a href="#8-3-交换排序" class="headerlink" title="8.3 交换排序"></a>8.3 交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//确定第i个位置的数据</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//标志是否发生交换，如果没有发生交换就代表着已经有序了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123; <span class="comment">//从最后面，一直往前面冒泡</span></span><br><span class="line">            <span class="keyword">if</span>(data[j]&lt;data[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp = data[j<span class="number">-1</span>];</span><br><span class="line">                data[j<span class="number">-1</span>] = data[j];</span><br><span class="line">                data[j] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = data[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="comment">//注意这里一定要先操作high 因为 low位置是空的插槽</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;data[high]&gt;=pivot)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        data[low] = data[high]; <span class="comment">//high位置空出来了插槽</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;data[low]&lt;=pivot)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        data[high] = data[low]; <span class="comment">//low位置空出来了插槽</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时low=high了，就是要分割的位置</span></span><br><span class="line">    data[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">partition</span>(data,low,high);</span><br><span class="line">        <span class="built_in">quickSort</span>(data,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(data,pivotpos<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(data,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-选择排序"><a href="#8-4-选择排序" class="headerlink" title="8.4 选择排序"></a>8.4 选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[minIndex]&gt;data[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">            <span class="type">int</span> temp = data[i];</span><br><span class="line">            data[i] = data[minIndex];</span><br><span class="line">            data[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = data[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="comment">//注意这里一定要先操作high 因为 low位置是空的插槽</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;data[high]&gt;=pivot)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        data[low] = data[high]; <span class="comment">//high位置空出来了插槽</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;data[low]&lt;=pivot)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        data[high] = data[low]; <span class="comment">//low位置空出来了插槽</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时low=high了，就是要分割的位置</span></span><br><span class="line">    data[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">partition</span>(data,low,high);</span><br><span class="line">        <span class="built_in">quickSort</span>(data,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(data,pivotpos<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(data,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-归并与基数"><a href="#8-5-归并与基数" class="headerlink" title="8.5 归并与基数"></a>8.5 归并与基数</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;  <span class="comment">//将中间元素归于左边了</span></span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftArr[n1] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> rightArr[n2] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">        leftArr[i] = data[i+left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2;j++)&#123;</span><br><span class="line">        rightArr[j] = data[j+mid<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>,k=left;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n1&amp;&amp;j&lt;n2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftArr[i]&lt;=rightArr[j])&#123;</span><br><span class="line">            data[k] = leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            data[k] = rightArr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把较长的那个未检测完的那个复制一下</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n1)&#123;</span><br><span class="line">        data[k++] = leftArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n2)&#123;</span><br><span class="line">        data[k++] = rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortRecursive</span><span class="params">(<span class="type">int</span> data[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSortRecursive</span>(data,left,mid);</span><br><span class="line">        <span class="built_in">mergeSortRecursive</span>(data,mid<span class="number">+1</span>,right);</span><br><span class="line">        <span class="built_in">merge</span>(data,left,right,mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现 //自下而上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortIterative</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size = <span class="number">1</span>; size &lt; n; size *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//注意这里为啥要left+ 2 * size，因为一次要合并俩数组，左边一个size，右边一个size</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;n;left+=<span class="number">2</span>*size)&#123;    </span><br><span class="line">            <span class="type">int</span> mid = <span class="built_in">min</span>(left+size<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">min</span>(left<span class="number">+2</span>*size<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;right)&#123;</span><br><span class="line">                <span class="built_in">merge</span>(data,left,right,mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> data_1[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSortRecursive</span>(data_1, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;递归结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data_1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_2[n] = &#123;<span class="number">36</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">70</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">mergeSortIterative</span>(data_2, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;递归结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;data_2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王道 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统 王道2026学习笔记</title>
      <link href="/2025/04/13/kinglyWay-operatingSystem/"/>
      <url>/2025/04/13/kinglyWay-operatingSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="擦作系统-王道2026学习笔记"><a href="#擦作系统-王道2026学习笔记" class="headerlink" title="擦作系统 王道2026学习笔记"></a>擦作系统 王道2026学习笔记</h1><h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="1-1-操作系统的基本概念"><a href="#1-1-操作系统的基本概念" class="headerlink" title="1.1 操作系统的基本概念"></a>1.1 操作系统的基本概念</h2><h3 id="操作系统的定义："><a href="#操作系统的定义：" class="headerlink" title="操作系统的定义："></a>操作系统的定义：</h3><p>控制和管理整个计算机系统的硬件与软件资源，合理地资助、调度计算机的工作和资源的分配，基进而为用户和其他软件提供方便的接口与环境的程序集合。操作系统是计算机中族基本的软件系统。</p><h3 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h3><p><strong>1.系统资源的管理者</strong></p><ul><li>处理器管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul><p><strong>2.作为用户和计算机系统之间的接口</strong></p><ul><li>命令接口<ul><li>联机命令接口：强调交互性，用户输入命令，操作系统来完成指令</li><li>脱机命令接口：批处理命令接口，用户提前编辑命令列表，操作系统来完成</li></ul></li><li>程序接口<ul><li>由一系列的系统调用组成，用户通过请求这些命令来使得操作系统完成指令（GUI界面的等）</li></ul></li></ul><p><strong>3.实现了对计算机资源的扩充</strong></p><ul><li>工人 操作 机器，机器就有更大的作用，于是，工人 便成为了 机器 的 扩充机器</li></ul><h3 id="操作系统特性"><a href="#操作系统特性" class="headerlink" title="操作系统特性"></a>操作系统特性</h3><p><strong>1.并发</strong>（注意和并行的区别）</p><p>概念：两个或者多个事件在同一时间间隔内发生</p><p>注意和<strong>并行</strong>的区别</p><p>并性的概念：两个或者多个事件在<strong>同一时刻</strong>内发生</p><p>引入进程的目的就是使程序能够并发执行</p><p><strong>2.共享</strong></p><p>资源共享：系统中的资源可以提供给内存之中多个并发执行的进程使用</p><ul><li>互斥共享方式<ul><li>某些资源虽然可以提供给多个进程使用，但是在同一时刻只允许一个进程访问该资源</li><li>打印机、磁带机</li></ul></li><li>同时共享方式<ul><li>允许一段时间内由多个进程’’同时’’访问</li><li>磁盘设备</li></ul></li></ul><p><strong>3.虚拟</strong></p><p>一个物理的实体变为若干逻辑上的对应物品</p><ul><li>时分复用技术: 虚拟处理器。批处理的时候，多个进程并发执行，使得用户感觉，就是多个处理器在运行</li><li>空分复用技术：虚拟存储器</li></ul><p><strong>4.异步</strong></p><p>并发执行的程序，由于资源限制，不是一贯到底的执行，而是走走停停，他以不可预知的速度向前推进</p><h2 id="1-2-操作系统的发展历史"><a href="#1-2-操作系统的发展历史" class="headerlink" title="1.2 操作系统的发展历史"></a>1.2 操作系统的发展历史</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p>计算机上所有的工作都需要人工干预（程序的装入，运行，输出等）</p><p>用户独占机器，CPU等待人工操作，人机上的速度的冲突</p><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3><p>主要是为了解决人机矛盾以及CPU与I&#x2F;O设备之间的速度不匹配等问题</p><ul><li><p>单道批处理系统：将一批作业以脱机方式输入磁带，在监督程序的控制下，一个接一个的顺序的执行</p><ul><li>自动性（不需要人工干涉） </li><li>顺序性（磁带上的各个作业依次进入内存并执行）</li><li>单道性（内存之中只存在一个程序）</li></ul></li><li><p>多道批处理系统：作业在外存排成队列，然后按调度算法调入内存，一次可以调多个，相互穿插着执行</p><ul><li>多道</li><li>宏观上并行（调入内存的程序都在运行，但还没有执行完毕）</li><li>微观上串行（内存之中的多道程序，不可以同时占有CPU，还是交替占有执行）</li></ul></li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>分时技术：将处理器的运行时间分成很短的时间片，按时间片轮流将处理器分配给各个作业使用；计算机速度很快，时间片轮转速度也很快，使得用户感觉自己在独占机器。</p><p>特点：</p><ul><li>同时性：多个终端用户可以同时使用一台计算机</li><li>交互性：用户通过终端采用人机对话的方式直接控制程序，与程序进行交互</li><li>独立性：多个用户独立的操作计算机，不会存在相互干扰。就好像自己在独占这台机器一样</li><li>及时性：用户的请求能够在很短时间内获得响应</li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>必须在某一个时间限制内完成某些紧急的任务。</p><ul><li>硬实时系统：必须，绝对在规定的时间内完成任务（飞行器的控制系统）</li><li>软实时系统：偶尔不再一定时间内完成也不会造成太大的影响（飞机购票，银行管理等）</li></ul><h3 id="网络操作系统和分布式计算机系统（略）"><a href="#网络操作系统和分布式计算机系统（略）" class="headerlink" title="网络操作系统和分布式计算机系统（略）"></a>网络操作系统和分布式计算机系统（略）</h3><h3 id="个人计算机操作系统（略）"><a href="#个人计算机操作系统（略）" class="headerlink" title="个人计算机操作系统（略）"></a>个人计算机操作系统（略）</h3><p><img src="/../0_images/kinglyWay-operatingSystem/1_1_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="alt text"></p><h2 id="1-3-操作系统运行环境"><a href="#1-3-操作系统运行环境" class="headerlink" title="1.3 操作系统运行环境"></a>1.3 操作系统运行环境</h2><h3 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h3><p><strong>特权指令和非特权指令</strong></p><ul><li><p>特权指令：操作系统内核的指令，只能由操作系统使用，普通用户程序不能使用, 如 I&#x2F;O指令，中断指令等</p></li><li><p>非特权指令：操作系统内核以外的指令，普通用户程序可以使用</p></li></ul><p><strong>内核态和用户态</strong></p><ul><li><p>内核态：操作系统内核的运行状态，特权指令的运行状态</p><ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构和处理<ul><li>进程控制块，作业控制块，设备控制等</li><li>进程管理，存储器管理，设备管理等</li></ul></li></ul></li><li><p>用户态：应用程序的运行状态，非特权指令的运行状态</p></li></ul><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><ul><li><p>中断：（外中断）由于内部事件（如I&#x2F;O操作完成）或者外部事件（如用户按键）的发生，使得CPU暂时中止当前程序的执行，转而去处理中断事件，处理完毕后返回被中断的程序继续执行</p></li><li><p>异常：（内中断）由于执行指令的异常而引起的中断，如除0，地址越界等</p></li></ul><p><strong>中断和异常的处理过程：</strong></p><ul><li>保存被中断进程的CPU环境</li><li>根据中断类型转入相应的中断处理程序</li><li>中断处理程序处理中断</li><li>恢复被中断进程的CPU环境，返回被中断的进程继续执行</li></ul><p>中断和异常的区别：中断是由外部事件引起的，异常是由执行指令引起的</p><p><img src="/../0_images/kinglyWay-operatingSystem/1_2_%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8.png" alt="alt text"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>**系统调用：**操作系统提供给应用程序使用的接口，应用程序通过系统调用请求操作系统提供服务</p><p><strong>系统调用的功能</strong></p><ul><li>进程管理。 完成进程的创建，撤销，阻塞，唤醒等操作。</li><li>进程通信。 完成进程之间的消息传递，信号传递等。</li><li>设备管理。 完成设备的请求和释放，以及设备的启动等。</li><li>内存管理。 完成存储分配与回收，地址映射等。</li><li>文件管理。 完成文件的读、写、创建、删除等操作。</li></ul><p><strong>系统调用与库函数的区别：</strong></p><ul><li>系统调用是操作系统提供给应用程序使用的接口，库函数是应用程序提供给应用程序使用的接口</li><li>系统调用是操作系统内核的接口，库函数是应用程序的接口</li><li>系统调用是操作系统内核的指令，库函数是应用程序的指令</li><li>系统调用是操作系统内核的指令，库函数是应用程序的指令</li></ul><h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><p><strong>1.分层法</strong></p><p>分层法是将操作系统分成若干层， 底层（层0）为硬件，顶层（层N）为用户接口，每一层只能调用紧邻它的底层的功能和服务（单向依赖）</p><p><img src="/../0_images/kinglyWay-operatingSystem/1_3_%E5%88%86%E5%B1%82%E6%B3%95.png" alt="alt text"></p><p><strong>2.模块化</strong><br>模块化是将操作系统分成若干个模块，每个模块负责完成一个功能，模块之间通过接口进行通信</p><p><img src="/../0_images/kinglyWay-operatingSystem/1_4_%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="alt text"></p><p><strong>高内聚，低耦合</strong></p><ul><li><p>模块划分的大 增加了模块内部的复杂性</p></li><li><p>模块划分的小 会使得模块之间的依赖关系复杂</p></li></ul><p><strong>3.宏内核</strong></p><p>将系统的主要的功能模块都作为一个紧密联系的整体，运行在核心态，内核态的模块之间可以直接相互调用</p><p><strong>4.微内核</strong></p><p>内核之中最基本的功能保留在内核之中(进程管理，中断处理，内存管理)，其他功能都放在用户态的模块之中，内核与用户态的模块之间通过消息传递的方式进行通信</p><h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><p><strong>进程</strong>：进程是程序的一次执行过程，是系统进行资源分配和调度的独立单位</p><p><strong>为什么要引入进程：</strong> 为了使多个程序能够并发执行，提高资源利用率和系统效率</p><p><strong>进程控制块(PCB)</strong> ：用于描述进程的基本信息和运行状态，系统通过它来控制和管理进程</p><p><strong>进程实体：</strong> 程序段 + 相关数据段 + 进程控制块(PCB)</p><p><strong>进程的特征：</strong></p><ul><li>动态性：进程是程序的一次执行过程，是动态产生，动态消亡的</li><li>并发性：多个进程可以在单个处理器上并发执行</li><li>独立性：进程是系统独立运行的基本单位，拥有自己独立的资源</li><li>异步性：进程的执行是走走停停的，进程以不可预知的速度向前推进</li></ul><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>1.进程控制块（PCB）</p><p>进程创建的时候先创建进程控制块，进程控制块是进程存在的唯一标志</p><p>PCB包含的信息：</p><p><img src="/../0_images/kinglyWay-operatingSystem/2_1_PCB%E4%B8%AD%E6%89%80%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%A1%E6%81%AF.png" alt="alt text"></p><p>2.程序段</p><p>进程被调度到CPU之后所执行的代码</p><p>3.数据段</p><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是进程在运行过程中产生的数据</p><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p><strong>进程的5种状态</strong></p><ul><li>运行态：进程占有处理器(CPU)正在运行</li><li>就绪态：进程获得了除处理器(CPU)以外的所有资源，等待系统分配处理器(CPU)资源</li><li>阻塞态：进程在等待某个事件完成（如I&#x2F;O操作完成），暂时无法执行</li><li>创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</li><li>终止态：进程正在被撤销，操作系统回收进程所拥有的资源，撤销PCB</li></ul><p>注意区分就绪态和阻塞态的：就绪态是进程已经获得了除处理器(CPU)以外的所有资源，等待系统分配处理器(CPU)资源；阻塞态是进程在等待某个事件完成（如I&#x2F;O操作完成），暂时无法执行</p><p><img src="/../0_images/kinglyWay-operatingSystem/2_2_%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="alt text"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程控制：</strong> 进程控制的主要功能是进程的创建，撤销，阻塞，唤醒等操作</p><p>1.进程的创建</p><ul><li>申请一个空白的PCB(PCB是有限的)，若PCB申请失败则进程创建失败</li><li>为进程分配必要的资源，如CPU，内存，I&#x2F;O，CPU时间等</li><li>初始化PCB，如设置进程的优先级，进程的状态，进程的ID等</li><li>将PCB插入就绪队列(进程的队列能够接纳新的进程)，等待进程调度</li></ul><p>2.进程的终止</p><p><strong>引起终止的事件：</strong></p><ul><li>正常结束：进程自己正常结束，如执行完任务</li><li>异常结束：由于进程出错而结束，如除0操作</li><li>外部干预：其他进程通过系统调用kill来结束某个进程</li></ul><p><strong>终止进程时候的操作：</strong></p><ul><li>检索出进程的PCB，检查其状态</li><li>若进程处于运行态，则立即终止进程的执行，将CPU资源分配给其他进程</li><li>若进程还有子孙进程，则通常会将所有的子孙进程都终止(有些操作系统不会)</li><li>将进程持有的资源归还给父进程或者操作系统</li><li>将进程的PCB从相应的队列中移除，如就绪队列，阻塞队列等</li></ul><p>3.进程的阻塞与唤醒</p><p><strong>阻塞：</strong>  进程在等待某个事件完成的时候，暂时无法执行，此时进程的状态由运行态变为阻塞态，并将PCB插入相应的阻塞队列中</p><ul><li>找到将要被阻塞的进程的标识号(PID),所对应的PCB</li><li>若进程处于运行态，则保护其现场，将其状态设置为阻塞态，停止运行</li><li>将PCB插入相应事件的等待队列中，将CPU资源分配给其他进程</li></ul><p><strong>唤醒：</strong> 进程所等待的事件已经完成，进程的状态由阻塞态变为就绪态，等待系统调度</p><ul><li>在该事件的等待队列之中找到相应的PCB</li><li>将PCB从等待队列中移除，修改其状态为就绪态</li><li>将PCB插入就绪队列中，等待系统调度</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><strong>进程通信：</strong> 进程通信是指进程之间的信息交换</p><p><strong>进程通信的方式：</strong></p><ul><li><strong>共享存储</strong>: 在通信的进程之间存在一块共享的存储区域，进程可以直接读写这块存储区域中的数据，实现进程间的通信</li><li><strong>消息传递</strong>: 进程间的数据交换以格式化的消息(Message)为单位，进程通过发送消息来传递数据，通过接收消息来获取数据<ul><li>直接通信：发送进程直接将消息发送给接收进程，接收进程从消息队列中获取消息</li><li>间接通信：发送进程将消息发送给消息队列，接收进程从消息队列中获取消息</li></ul></li><li><strong>管道通信</strong>: 管道是一种特殊的文件，它允许一个进程将数据直接写入到另一个进程中，实现进程间的通信, 管道通过先进先出的队列实现</li><li><strong>信号通信</strong>: 信号是一种通知进程发生了某种事件的机制，不同的系统事件对应不同的信号类型，每个信号对应一个序号。进程通过信号来传递信息，实现进程间的通信</li></ul><h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a>线程的概念与特点</h3><p><strong>线程：</strong> 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他线程共享进程所拥有的全部资源</p><p><strong>为什么要引入线程：</strong> 为了进一步提高系统并发执行的程度，减少进程切换的开销，提高系统资源利用率</p><p><strong>线程和进程的比较：</strong></p><ul><li>调度：在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li><li>并发性：进程的引入使得作业可以并发，线程的引入使得进程可以并发</li><li>资源：进程拥有独立的资源，是系统中拥有资源的基本单位，线程共享进程的资源(本身不拥有资源，只拥有一些能维持运行的必要资源)</li><li>独立性：每个进程都拥有独立的地址空间和资源。除却共享变量之外，进程之间不可以访问对方的资源。线程之间共享进程的资源，线程之间可以相互访问对方的资源。</li><li>系统开销：创建和撤销进程的系统开销比创建和撤销线程的系统开销大得多，因为创建和撤销进程需要系统资源，而创建和撤销线程只需要系统资源的一小部分</li><li>支持多处理器系统：单线程进程，不管由多少个CPU，线程只能在单个CPU上运行。多线程进程，可以充分利用多处理器的优势，将线程分配到多个CPU上运行。</li></ul><p><strong>线程的状态和转换</strong></p><ul><li>执行态：线程占有处理器(CPU)正在运行</li><li>就绪态：线程获得了除处理器(CPU)以外的所有资源，等待系统分配处理器(CPU)资源  </li><li>阻塞态：线程在等待某个事件完成（如I&#x2F;O操作完成），暂时无法执行</li></ul><p><strong>线程控制块</strong></p><ul><li>线程ID(线程标识符)</li><li>一组寄存器</li><li>线程的运行状态</li><li>线程的优先级</li><li>线程专有的存储区</li><li>堆栈指针</li></ul><p><strong>线程的实现方式：</strong></p><ul><li>用户级线程：线程的创建，撤销，切换等操作都由应用程序来完成，操作系统内核不知道线程的存在，线程的调度由应用程序自己完成</li><li>内核级线程：线程的创建，撤销，切换等操作都由操作系统内核来完成，线程的调度由操作系统内核完成</li><li>组合方式：线程的实现方式是用户级线程和内核级线程的组合</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/2_3_%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="alt text"></p><p>注意：用户级线程切换的时候不会进入内核态，内核级线程切换的时候会进入内核态，并且会存在　保护现场和恢复现场的操作</p><p><strong>多线程模型</strong></p><ul><li>多对一模型：一个用户级线程对应一个内核级线程，线程的创建，撤销，切换等操作都由应用程序来完成，线程的调度由操作系统内核完成</li><li>一对一模型：一个用户级线程对应一个内核级线程，线程的创建，撤销，切换等操作都由操作系统内核来完成，线程的调度由操作系统内核完成</li><li>多对多模型：n个用户级线程对应m个内核级线程，线程的创建，撤销，切换等操作都由应用程序来完成，线程的调度由操作系统内核完成</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/2_4_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="alt text"></p><h2 id="2-2-CPU调度"><a href="#2-2-CPU调度" class="headerlink" title="2.2 CPU调度"></a>2.2 CPU调度</h2><h3 id="CPU调度的概念"><a href="#CPU调度的概念" class="headerlink" title="CPU调度的概念"></a>CPU调度的概念</h3><p><strong>CPU调度：</strong> CPU调度是指操作系统为多个进程分配CPU资源，决定哪个进程应该使用CPU，以及分配多少CPU时间给进程</p><p><strong>调度的层次</strong></p><ul><li>高级调度：也称为作业调度，主要功能是根据某种算法，从外存的后备队列中选取某些作业，将它们调入内存，并为它们创建进程，以准备运行</li><li>中级调度：也称为内存调度，主要功能是将处于等待状态的进程调出内存，或将暂时不能运行的进程调出内存，以便为其他进程让出足够的内存空间，或者将已经完成部分任务的进程调出内存，以便回收其占用的内存空间</li><li>低级调度：也称为进程调度，主要功能是按照某种算法，从就绪队列中选取一个进程，将CPU资源分配给它，使其执行</li></ul><p>三级调度之间的联系：<br>作业调度将作业从外存调入内存，并为它们创建进程，以准备运行；进程调度从就绪队列之中选择一个进程，将CPU资源分配给它，使其执行；内存调度是为了提高内存利用率，系统将那些暂时不能运行的进程调出内存。</p><p><img src="/../0_images/kinglyWay-operatingSystem/2_5_%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="alt text"></p><p><strong>调度的实现</strong></p><p>用于调度和分配CPU的组件成为调度程序，三部分组成</p><p>-　排队器：将系统中所有的就绪进程按照一定的算法，将它们排成一个或多个队列，当某个进程就绪时，排队器将其插入到相应的就绪队列之中<br>-　分派器：根据调度程序所选择的进程，将CPU资源分配给它，使其执行<br>-　上下文切换器：将被移出的进程保存上下文。为将要执行的进程恢复上下文</p><p><img src="/../0_images/kinglyWay-operatingSystem/2_6_%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="alt text"></p><h3 id="进程调度的目标"><a href="#进程调度的目标" class="headerlink" title="进程调度的目标"></a>进程调度的目标</h3><ul><li>CPU利用率：CPU利用率是指CPU在单位时间内执行了多少进程，CPU利用率越高，说明CPU资源利用率越高<ul><li>CPU利用率 &#x3D; CPU有效工作时间 &#x2F; (CPU有效工作时间 + CPU空闲时间)</li></ul></li><li>系统吞吐量：系统吞吐量是指单位时间内完成的进程数量，系统吞吐量越高，说明系统的效率越高</li><li>周转时间：周转时间是指进程从提交到完成所经历的时间，周转时间越短，说明进程的响应时间越短<ul><li>作业周转时间 &#x3D; 作业完成时间 - 作业提交时间</li><li>平均周转时间 &#x3D; (所有作业的周转时间之和) &#x2F; (作业数量)</li><li>带权周转时间 &#x3D; 作业周转时间　&#x2F;　作业实际运行时间</li><li>平均带权周转时间 &#x3D; (所有作业的带权周转时间之和) &#x2F; (作业数量)</li></ul></li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li>挂起一个进程，将CPU上下文保存到进程的PCB中，包括程序计数器，寄存器，内存指针等</li><li>将该进程的PCB移入相应的队列，如就绪队列，阻塞队列等</li><li>选择另外一个进程执行，并更新其PCB</li><li>恢复新进程的PCB中存储的CPU上下文信息</li><li>转跳到新进程PCB中程序计数器所指向的位置，开始执行</li></ul><h3 id="进程调度的算法"><a href="#进程调度的算法" class="headerlink" title="进程调度的算法"></a>进程调度的算法</h3><p><strong>先来先服务(FCFS)调度算法：</strong> 按照进程到达的顺序进行调度，即先到达的进程先得到CPU资源，后到达的进程后得到CPU资源</p><p><strong>短作业优先(SJF)调度算法：</strong> 按照进程的执行时间进行调度，即执行时间短的进程先得到CPU资源，执行时间长的进程后得到CPU资源</p><ul><li>抢占式与非抢占式</li><li>容易造成长作业的饥饿现象</li></ul><p><strong>高相应比优先调度算法</strong>：按照进程的响应比进行调度，即响应比高的进程先得到CPU资源，响应比低的进程后得到CPU资源</p><ul><li>相应比 &#x3D; (进程等待时间 + 进程要求服务时间) &#x2F; 进程要求服务时间</li><li>当等待时间相同时，短作业优先</li><li>当某一个进程的等待时间过长的时候，其响应比会变得很大，从而得到优先执行</li></ul><p><strong>优先级调度算法</strong>：按照进程的优先级进行调度，即优先级高的进程先得到CPU资源，优先级低的进程后得到CPU资源</p><ul><li>抢占式与非抢占式</li><li>静态优先级以及动态优先级</li><li>一般情况下：<ul><li>系统进程 &gt; 用户进程</li><li>交互型进程(前台进程) &gt; 非交互性进程(后台进程)</li><li>I&#x2F;O型进程 &gt; 计算型进程<ul><li>I&#x2F;O型进程：频繁进行I&#x2F;O操作，CPU等待I&#x2F;O操作的时间较长</li><li>计算型进程：CPU密集型进程，CPU等待I&#x2F;O操作的时间较短 </li><li>让I&#x2F;O型进程优先执行，可以减少CPU的空闲时间，提高CPU的利用率</li></ul></li></ul></li></ul><p><strong>时间片轮转调度算法</strong>：按照进程的到达顺序进行调度，每个进程分配一个时间片，时间片用完后，进程被挂起，下一个进程开始执行，直到所有进程都执行完毕</p><p><strong>多级反馈队列调度算法</strong>：将就绪队列分成多个队列，每个队列的优先级不同，优先级高的队列的进程先得到CPU资源，优先级低的队列的进程后得到CPU资源，每个队列的时间片长度不同，优先级高的队列的时间片长度短，优先级低的队列的时间片长度长</p><h2 id="2-3-同步与互斥"><a href="#2-3-同步与互斥" class="headerlink" title="2.3 同步与互斥"></a>2.3 同步与互斥</h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h3><p><strong>临界资源：</strong> 临界资源是指多个进程需要共享的资源，这些资源在同一时间只能被一个进程使用，其他进程需要等待该进程使用完毕后才能使用</p><ul><li>临界区：临界区是指访问临界资源的代码段，临界区是进程中的关键部分，需要保护起来，防止多个进程同时访问临界区，导致数据不一致</li><li>进入区，临界区，退出区，剩余区</li></ul><p><strong>同步：</strong> 同步是指多个进程之间需要按照一定的顺序执行，即一个进程需要等待另一个进程执行完毕后才能继续执行</p><p><strong>互斥：</strong> 互斥是指多个进程之间需要共享某些资源，这些资源在同一时间只能被一个进程使用，其他进程需要等待该进程使用完毕后才能使用</p><p>临界区互斥的四个必要条件：</p><ul><li>空闲让进：当临界区资源空闲时，允许请求访问的进程进入临界区</li><li>忙则等待：当临界区资源被占用时，不允许其他进程进入临界区</li><li>有限等待：进程在请求访问临界区资源时，必须在有限的时间内得到响应</li><li>让权等待：当进程请求访问临界区资源时，如果无法立即获得资源，则应立即释放CPU</li></ul><h3 id="实现临界区互斥的方法："><a href="#实现临界区互斥的方法：" class="headerlink" title="实现临界区互斥的方法："></a>实现临界区互斥的方法：</h3><p><strong>1.软件实现方法</strong></p><p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><p><strong>算法一：单标志法（我想进！）</strong></p><p>变量turn表示选择权在谁手上，turn&#x3D;0表示P0可进入，turn&#x3D;1表示P1可进入，进入后将turn设置为另一方值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">while(turn != 0); //进入区</span><br><span class="line">临界区资源; //临界区</span><br><span class="line">turn = 1; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">while(turn != 1); //进入区</span><br><span class="line">临界区资源; //临界区</span><br><span class="line">turn = 0; //退出区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：违反空闲让进、让权等待</p><p><strong>算法二：双标志法先检查法（你想进不？我想进！）</strong></p><p>布尔型数组 flag[2]用来标记各个进程是否想进临界区，flag[i]&#x3D;true表示Pi想要进入临界区(i&#x3D;0或1)。Pi进入临界区前，先检查对方是否想进入临界区，若想，则等待；否则，将flag[i]置为true后，再进入临界区；当Pi退出临界区时，将flag[i]置为false。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">while(flag[1]);  //进入区 你想进不？</span><br><span class="line">flag[0] = true; //进入区 我想进！</span><br><span class="line">临界区资源；//临界区</span><br><span class="line">flag[0] = flase; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">while(flag[0]);  //进入区</span><br><span class="line">flag[1] = true; //进入区</span><br><span class="line">临界区资源；//临界区</span><br><span class="line">flag[0] = flase; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缺点：违反忙则等待、让权等待</p><p><strong>算法三：双标志法后检查法（我想进！你想进不？）</strong></p><p>先检查法先检查对方的标志，再设置自己的标志，但这两个操作又无法一气呵成，于是使得两个进程同时进入临界区的问题。因此，想到先设置后检查法，以避免上述问题。后检查法先设置自己的标志，再检查对方的标志，若对方的标志为true，则等待；否则，进入临界区。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">flag[0] = true; //进入区 我想进！</span><br><span class="line">while(flag[1]);  //进入区 你想进不？</span><br><span class="line">临界区资源；//临界区</span><br><span class="line">flag[0] = flase; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">flag[1] = true; //进入区</span><br><span class="line">while(flag[0]);  //进入区</span><br><span class="line">临界区资源；//临界区</span><br><span class="line">flag[0] = flase; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>算法四：皮特森算法（我想进！你先进吧~）</strong></p><p>Peterson 算法结合了算法一和算法三的思想，利用flag[]解决互斥访问问题，而利用 turn解决“饥饿”问题。若双方都争着进入临界区，则可让进程将进入临界区的机会谦让给对方。也就是说，在每个进程进入临界区之前，先设置自己的flag标志，再设置允许进入turn标志；之后，再同时检测对方的flag和turn标志，以保证双方同时要求进入临界区时，只允许一个进程进入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">flag[0] = true; //进入区 我想进</span><br><span class="line">turn = 1； //进入区 你先进吧</span><br><span class="line">while(turn == 1 &amp;&amp; flag[1] == true); //进入区 你先进吧</span><br><span class="line">临界区资源； //临界区</span><br><span class="line">flag[0] = false; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">flag[1] = true; //进入区 我想进</span><br><span class="line">turn = 0； //进入区 你先进吧</span><br><span class="line">while(turn == 0 &amp;&amp; flag[0] == true); //进入区 你先进吧</span><br><span class="line">临界区资源； //临界区</span><br><span class="line">flag[1] = false; //退出区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.硬件实现的方法</strong></p><p><strong>算法一：中断屏蔽方法</strong></p><p>当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简单方法是关中断。因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关中断；</span><br><span class="line">临界区；</span><br><span class="line">开中断；</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>限制了 CPU交替执行程序的能力。</li><li>将关中断的权限交给用户不安全。</li><li>不适用于多处理器系统，</li></ul><p><strong>算法二：硬件指令方法——TestAndSet 指令</strong></p><p>TestAndSet 指令(简称 TS 指令)可以读出指定标志后将该标志设置为真，是原子操作。指令的功能描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean TestAndSet (boolean *lock)&#123;</span><br><span class="line">boolean old;</span><br><span class="line">old=*lock;//old 用来存放 lock 的旧值</span><br><span class="line">*lock=true;//无论之前是否已加锁，都将lock 置为true</span><br><span class="line">return old;//返回 lock 的旧值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock有两种状态：true已加锁，false未加锁。进程在进入临界区之前，先用TS指令检查lock值：①若为 false，则表示没有进程在临界区，可以进入，并将 lock 置为 true，这意味着关闭了临界资源(加锁)，使任何进程都不能进入临界区；②若为 true，则表示有进程在临界区中，进入循环等待，直到当前访问临界区的进程退出时解锁(将lock置为 false)。</p><p>利用 TS指令实现互斥的过程描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while TestAndSet(&amp;lock); //加锁并检查</span><br><span class="line">临界区代码段；</span><br><span class="line">lock=false; //解锁 </span><br></pre></td></tr></table></figure><p><strong>算法三：交换指令方法——Swap 指令</strong></p><p>用Swap指令管理临界区时，为每个临界资源设置一个共享布尔变量lock，初值为 false;在每个进程中再设置一个局部布尔变量key，初值为true，用于与 lock交换信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swap(boolean *lock,boolean *key)&#123;</span><br><span class="line">boolean temp;</span><br><span class="line">temp=*lock;</span><br><span class="line">*lock=*key;</span><br><span class="line">*key=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从逻辑上看，Swap指令和TS指令实现互斥的方法并无太大区别，都先记录此时临界区是否已加锁(记录在变量 key中)，再将锁标志lock置为true，最后检查key，若 key为false，则说明之前没有其他进程对临界区加锁，于是跳出循环，进入临界区。其处理过程描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean key=true;</span><br><span class="line">while(key!=false)</span><br><span class="line">Swap(&amp;lock,&amp;key);</span><br><span class="line">临界区代码段；</span><br><span class="line">lock=false;</span><br></pre></td></tr></table></figure><p><strong>互斥锁(mutex)</strong></p><p>一个进程进入临界区时，先对互斥锁加锁(调用acquire()函数)，若互斥锁已被其他进程加锁，则该进程等待，直到互斥锁被解锁；当进程退出临界区时，解锁互斥锁(调用release()函数)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">while(mutex == true); //进入区</span><br><span class="line">mutex = true; //进入区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release()&#123;</span><br><span class="line">mutex = false; //退出区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量</strong></p><p><strong>1.整型信号量</strong><br>整型信号量是一种最简单的信号量，只有三种操作：初始化、wait(P)操作和signal(V)操作。P、V操作是原语操作，不可中断，具有原子性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait(s)&#123; //P操作</span><br><span class="line">while(s &lt;= 0); //进入区</span><br><span class="line">s--; //进入区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(s)&#123; //V操作</span><br><span class="line">s++; //退出区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在wait之中s &lt;&#x3D; 0时，会一直循环，未遵循让权等待原则，因此需要改进。</p><p><strong>2.记录型信号量</strong><br>记录型信号量是一种更复杂的信号量，除了整型信号量的三个操作外，还增加了一个进程链表，用于记录所有等待该信号量的进程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct semaphore&#123;</span><br><span class="line">int value; //信号量值</span><br><span class="line">struct process *L; //等待进程链表</span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure><p>wait 和 signal 操作如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait(semaphore s)&#123; //P操作</span><br><span class="line">s.value--; //进入区</span><br><span class="line">if(s.value &lt; 0)&#123;</span><br><span class="line">//将当前进程插入到s.L中，并挂起该进程； //进入区</span><br><span class="line">    block(s.L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(semaphore s)&#123; //V操作</span><br><span class="line">s.value++; //退出区</span><br><span class="line">if(s.value &lt;= 0)&#123;</span><br><span class="line">//从s.L中移出一个进程P，并将P置于就绪队列； //退出区</span><br><span class="line">    wakeup(P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用信号量实现互斥和同步：</p><ul><li>互斥：将临界区代码段放在 wait(s) 和 signal(s) 之间。</li><li>同步：将两个进程的并发执行顺序用 wait(s) 和 signal(s) 来描述。</li></ul><p>互斥：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">wait(s);</span><br><span class="line">//临界区代码段</span><br><span class="line">signal(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">wait(s);</span><br><span class="line">//临界区代码段</span><br><span class="line">signal(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P0&#123;</span><br><span class="line">x;</span><br><span class="line">signal(s);</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1&#123;</span><br><span class="line">  ···</span><br><span class="line">wait(s);</span><br><span class="line">  y;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p>这里就不写了，一定要偶尔看看，非常经典</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程也是用来解决进程同步互斥的一种工具，它的操作比信号量更加简单，管程封装了同步操作，对进程隐藏了同步细节。管程之所以被说是一个类，是因为管程采用了封装的思想，把复杂的细节隐藏了，我们只需要调用管程提供的特定“入口”就能实现进程同步&#x2F;互斥了。</p><ul><li>背景：管程是在程序设计语宣中被引入的，是一种高级的同步机制；</li><li>特点：管程把对共享资源的操作封装起来；每次仅允许一个进程进入管程</li></ul><p><strong>管程的定义</strong></p><ul><li>管程的名称</li><li>局部于管程的共享数据</li><li>对共享数据操作的一组过程(函数)</li><li>设置初始值的语句</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer&#123;</span><br><span class="line">int count = 0;</span><br><span class="line">condition empty, full;</span><br><span class="line">procedure producer()&#123;</span><br><span class="line">while(count == N)&#123;</span><br><span class="line">wait(empty);</span><br><span class="line">&#125;</span><br><span class="line">//生产一个产品</span><br><span class="line">count++;</span><br><span class="line">signal(full);</span><br><span class="line">&#125;</span><br><span class="line">procedure consumer()&#123;</span><br><span class="line">while(count == 0)&#123;</span><br><span class="line">wait(full);</span><br><span class="line">&#125;</span><br><span class="line">//消费一个产品</span><br><span class="line">count--;</span><br><span class="line">signal(empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>条件变量：</strong><br>条件变量是管程中的一种特殊变量，用于线程的挂起和唤醒。条件变量和互斥锁配合使用，能够实现线程的同步。条件变量和互斥锁的区别在于，互斥锁用于保护共享数据，确保同一时刻只有一个线程访问共享数据；而条件变量用于线程的挂起和唤醒，当条件不满足时，线程挂起等待，当条件满足时，线程被唤醒继续执行。</p><ul><li>x.wait：x条件不满足时，将自己插入x条件的等待队列，并释放管程，允许其他进程使用该管程（让其他人先用）</li><li>x.signal：x条件满足时，唤醒一个因x条件而阻塞的进程</li></ul><h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时，称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p><strong>死锁与饥饿的区别</strong></p><ul><li>发生饥饿的进程可以只有一个，但是发生死锁的进程至少有两个。</li><li>发生饥饿的进程可能处于就绪态，但是发生死锁的进程一定处于阻塞态。</li><li>饥饿的进程在一段时间内得不到资源，但是饥饿的进程最终可以执行，而死锁的进程将永远无法执行(无干涉情况下)。</li></ul><p><strong>死锁产生的原因</strong></p><ul><li>竞争资源：系统资源不足，进程争抢资源而造成死锁。</li><li>进程推进顺序不当：进程在运行过程中，请求和释放资源的顺序不当，导致进程陷入死锁。</li></ul><p><strong>死锁产生的必要条件：</strong></p><ul><li><strong>互斥条件</strong>：进程对所分配的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li><strong>请求和保持条件</strong>：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>不可剥夺条件</strong>：系统不能从占有资源的进程中抢占资源，只能由占有资源的进程自行释放（只能是主动释放）。</li><li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。</li></ul><p><strong>死锁的处理</strong></p><ul><li>死锁预防：预防死锁就是阻止系统进入不安全状态，从而避免死锁的发生。预防死锁需要确保死锁的四个必要条件中至少有一个不成立。</li><li>死锁避免：死锁避免是指系统在分配资源时，对资源请求进行动态检查，以确保资源分配不会导致系统进入不安全状态，从而避免死锁的发生。</li><li>死锁检测与解除：死锁检测是指系统定期检查系统中的资源分配情况，以确定是否存在死锁。一旦检测到死锁，就需要采取相应的措施来解除死锁，如资源剥夺、进程回退等。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/2_7_%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5.png" alt="alt text"></p><h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p><strong>预防死锁</strong>：预防死锁就是阻止系统进入不安全状态，从而避免死锁的发生。预防死锁需要确保死锁的四个必要条件中至少有一个不成立。</p><p>(GPT生成的，看看就行)</p><p><strong>1. 破坏互斥条件</strong><br>互斥条件是进程对所分配的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。因此，破坏互斥条件就是允许资源同时被多个进程共享，这样每个进程都可以得到自己所需要的资源。</p><p><strong>2. 破坏请求和保持条件</strong><br>请求和保持条件是指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。因此，破坏请求和保持条件就是要求进程在开始运行之前，必须一次性地申请它所需要的所有资源，并且只有当进程所申请的所有资源都得到满足后，进程才能开始运行。这样，进程在运行过程中就不会再提出新的资源请求，从而避免了请求和保持条件。</p><p><strong>3. 破坏不可剥夺条件</strong><br>不可剥夺条件是指系统不能从占有资源的进程中抢占资源，只能由占有资源的进程自行释放（只能是主动释放）。因此，破坏不可剥夺条件就是允许进程在运行过程中主动释放它所占有的资源，这样，当进程在运行过程中需要新的资源时，如果该资源已被其他进程占用，进程可以主动释放自己所占有的资源，从而获得所需的资源。</p><p><strong>4. 破坏循环等待条件</strong><br>循环等待条件是指存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。因此，破坏循环等待条件就是要求进程在申请资源时，按照一定的顺序进行，即每个进程只能申请它所需要的下一个资源，而不能申请它所需要的其他资源。这样，就不会存在进程资源的循环等待链，从而避免了循环等待条件。</p><h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><p><strong>死锁避免</strong>：死锁避免是指系统在分配资源时，对资源请求进行动态检查，以确保资源分配不会导致系统进入不安全状态，从而避免死锁的发生。</p><p><strong>安全状态</strong>：系统按照某种进程的推进顺序，可以依次为每个进程分配它所需要的资源，直到所有进程都得到它们所需要的资源，此时系统处于安全状态。如果系统无法找到一个这样的进程推进顺序，则系统处于不安全状态。</p><p><strong>银行家算法和安全性算法要重点看一看，这里写的比较简单，重点过一下书中的例子，要理解</strong></p><p><strong>银行家算法</strong>：银行家算法是一种死锁避免算法，用于防止系统进入不安全状态。银行家算法的基本思想是，当进程请求资源时，系统首先检查该进程是否可以得到它所需要的所有资源，如果可以，则分配资源给该进程，否则，该进程进入等待状态。如果系统无法找到一个这样的进程推进顺序，则系统处于不安全状态，此时系统会拒绝分配资源给任何进程，直到系统进入安全状态为止。</p><p><strong>安全性算法</strong>：安全性算法是一种死锁避免算法，用于检查系统是否处于安全状态。安全性算法的基本思想是，从某个进程开始，依次检查该进程是否可以得到它所需要的所有资源，如果可以，则将该进程加入到安全序列中，并继续检查下一个进程。如果所有进程都可以得到它们所需要的所有资源，则系统处于安全状态，否则，系统处于不安全状态。</p><h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p><strong>死锁检测</strong>：死锁检测是指系统定期检查系统中的资源分配情况，以确定是否存在死锁。一旦检测到死锁，就需要采取相应的措施来解除死锁，如资源剥夺、进程回退等。</p><p>根据资源分配图来检测死锁</p><p><img src="/../0_images/kinglyWay-operatingSystem/2_8_%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="alt text"></p><p><strong>检测到死锁之后的处理：</strong></p><ul><li>资源剥夺法：剥夺某些进程的资源，使其释放出资源，从而打破死锁。</li><li>撤销进程法：强制撤销部分甚至是全部的死锁进程，并剥夺这些进程的资源，从而打破死锁。</li><li>进程回退法：让进程回退到之前的一个安全状态，从而打破死锁。</li></ul><h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><h2 id="3-1-内存管理的概念"><a href="#3-1-内存管理的概念" class="headerlink" title="3.1 内存管理的概念"></a>3.1 内存管理的概念</h2><h3 id="内存管理的基本概念"><a href="#内存管理的基本概念" class="headerlink" title="内存管理的基本概念"></a>内存管理的基本概念</h3><p>内存：计算机的主存储器，用于存储程序和数据。</p><p>内存管理的主要任务：</p><ul><li>内存空间的分配与回收：为进程分配内存空间，并在进程结束时回收内存空间。</li><li>地址转换：将逻辑地址转换为物理地址。</li><li>内存空间的扩充：通过虚拟内存技术，扩充进程的可用内存空间。</li><li>内存共享：允许多个进程共享内存空间，提高内存利用率。</li><li>内存保护：防止进程访问非法内存地址，保护系统安全。</li></ul><p>1.逻辑地址与物理地址</p><ul><li>逻辑地址：程序编译之后，每个目标模块都从0号开始编址，这种地址称为逻辑地址，或者是相对地址</li><li>物理地址：内存中每个存储单元都有一个唯一的物理地址，用于标识该存储单元在内存中的位置。</li></ul><p>2.程序的链接与装入</p><p><img src="/../0_images/kinglyWay-operatingSystem/3_1_%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5.png" alt="alt text"></p><p>用户程序转化为内存之中可以运行的程序：</p><ul><li>编译：将高级语言编写的源程序翻译成目标程序</li><li>链接：将目标程序链接成可执行程序，链接的时候还会带着库函数一起链接</li><li>装入：将可执行程序装入内存中运行</li></ul><p>装入的方式：</p><p>1.绝对装入：</p><ul><li>编译的时候就知道要将程序放在那个位置，程序的逻辑地址与实际的物理地址相同(地址可以是编译或者汇编的时候给出，也可以是程序员指定)</li><li>适用于单道程序系统</li></ul><p>2.静态重定位：</p><ul><li>编译的时候不知道程序放在那个位置，链接的时候不知道程序放在那个位置，装入的时候才知道程序放在那个位置，编译的时候使用的是逻辑地址(从0开始)，装入的时候会将逻辑地址转换为物理地址</li><li>一个作业分配之后必须全部装入内存，否则不能运行</li></ul><p>3.动态重定位：</p><ul><li>装入后的地址还是逻辑地址，运行的时候才会将逻辑地址转换为物理地址</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_2_%E9%87%8D%E5%AE%9A%E4%BD%8D.png" alt="alt text"></p><p>链接的方式：</p><ul><li>静态链接：在编译和链接阶段完成链接，生成一个完整的可执行文件</li><li>装入时动态链接：在装入时完成链接，生成一个可执行文件</li><li>运行时动态链接：在运行时完成链接，生成一个可执行文件</li></ul><p>3.进程的内存映像</p><p>进程的内存映像：进程在内存中的映像，包括代码段、数据段、堆、栈、进程控制块等。</p><p><img src="/../0_images/kinglyWay-operatingSystem/3_3_%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F.png" alt="alt text"></p><p>4.内存保护</p><p>内存保护：防止进程访问非法内存地址，保护系统安全。</p><p>内存保护机制：</p><ul><li>地址越界检查：检查程序访问的内存地址是否在合法范围内。</li><li>内存访问权限检查：检查程序对内存的访问权限，如只读、可写、可执行等。</li><li>内存访问控制：通过设置内存访问控制位，控制程序对内存的访问权限。</li></ul><p>5.内存共享</p><p>只有那些只读的区域才可以进程之间共享</p><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p><strong>单一连续分配</strong></p><ul><li>分为两个区：系统区(操作系统用)和用户区</li><li>整个内存空间只划分一个连续的区域，用于存放一个进程。这种分配方式简单，但只能用于单道程序系统，无法实现内存的动态分配和回收。</li></ul><p><strong>固定分区分配</strong></p><ul><li>将内存空间划分为若干个固定大小的分区，每个分区只能容纳一个进程。</li><li>两种不同的方式：<ul><li>分区大小相等：每个分区的大小相同，适用于进程大小相近的情况。</li><li>分区大小不等：每个分区的大小不同，适用于进程大小差异较大的情况。</li></ul></li><li>分区使用表：记录每个分区的起始地址、大小、状态等信息。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_4_%E5%88%86%E5%8C%BA%E4%BD%BF%E7%94%A8%E8%A1%A8.png" alt="alt text"></p><p><strong>动态分区分配</strong></p><p><img src="/../0_images/kinglyWay-operatingSystem/3_5_%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" alt="alt text"></p><ul><li>分区大小可变：每个分区的大小可以根据进程的大小动态调整。</li><li>空闲分区表：记录每个空闲分区的起始地址、大小、状态等信息。<ul><li>注意回收时候的合并操作</li></ul></li><li>分配算法<ul><li>顺序：<ul><li>首次适应：从空闲分区表中找到第一个满足要求的空闲分区，将其分配给进程。</li><li>邻近适应：和首次适应差不多，只不过不再从最开始找，维护一个指针，继续循环找</li><li>最佳适应：从空闲分区表中找到大小最合适的空闲分区，将其分配给进程。</li><li>最差适应：从空闲分区表中找到大小最大的空闲分区，将其分配给进程。</li></ul></li><li>索引：<ul><li>伙伴系统：</li><li>快速适应：</li><li>哈希算法</li></ul></li></ul></li></ul><p>注意：上面都是连续分配的，别搞混了</p><h3 id="基本分页存储管理！！！"><a href="#基本分页存储管理！！！" class="headerlink" title="基本分页存储管理！！！"></a>基本分页存储管理！！！</h3><p>小概念：</p><ul><li>页面和页面大小：将内存空间划分为若干个大小相等的区域，每个区域称为一个页面，页面大小一般为2的整数次幂，如4KB、8KB等。</li><li>地址结构：<ul><li>页号+页内偏移量：将逻辑地址分为页号和页内偏移量两部分，页号用于标识页面，页内偏移量用于标识页面内的具体位置。</li></ul></li><li>页表：记录每个页面在内存中的存放位置</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_6_%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E9%A1%B5%E8%A1%A8.png" alt="alt text"></p><p><strong>基本的地址变换！！！</strong><br>这个比较重要，书中很详细！！</p><p><img src="/../0_images/kinglyWay-operatingSystem/3_7_%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="alt text"></p><p><strong>快表的地址变换</strong></p><ul><li>快表：用于提高地址变换的速度，将常用的页面号存储在快表中，当进行地址变换时，首先在快表中查找页面号，如果找到则直接得到物理地址，否则再在页表中查找。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_8_%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="alt text"></p><p><strong>两级页表</strong></p><ul><li>当进程的页表太大时，可以将页表分为多个子页表，每个子页表称为一个页目录，页目录中记录了每个子页表的起始地址和长度。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_9_%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" alt="alt text"></p><h3 id="基本分段存储管理！！！"><a href="#基本分段存储管理！！！" class="headerlink" title="基本分段存储管理！！！"></a>基本分段存储管理！！！</h3><p>小概念：</p><ul><li><p>段：将内存空间划分为若干个大小不等的段，每个段用于存放特定类型的数据，如代码段、数据段、堆、栈等。段内连续，段间不一定连续。</p></li><li><p>段表</p></li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_10_%E6%AE%B5%E8%A1%A8.png" alt="alt text"></p><ul><li>地址变换</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_10_%E5%88%86%E6%AE%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="alt text"></p><h3 id="段页式存储管理！！！"><a href="#段页式存储管理！！！" class="headerlink" title="段页式存储管理！！！"></a>段页式存储管理！！！</h3><p>小概念：</p><ul><li>段页式存储管理：结合了分段和分页两种存储管理方式，将内存空间划分为若干个大小不等的段，每个段再划分为若干个大小相等的页面。(段内分页)</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/3_11_%E6%AE%B5%E9%A1%B5%E5%BC%8F.png" alt="alt text"></p><p>地址映射：</p><p><img src="/../0_images/kinglyWay-operatingSystem/3_12_%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="alt text"></p><h2 id="3-2-虚拟内存"><a href="#3-2-虚拟内存" class="headerlink" title="3.2 虚拟内存"></a>3.2 虚拟内存</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><p>传统的内存管理方式：</p><ul><li>一次性: 进程一次性将所有数据装入内存，如果进程所需内存空间超过物理内存大小，则无法运行。</li><li>驻留性：进程在运行期间一直驻留在内存中，即使暂时不使用的部分也不释放。</li></ul><p>局部性原理！！！</p><ul><li>时间局部性：如果程序中的某条指令被执行，那么在不久的将来，这条指令很可能会再次被执行。（循环）</li><li>空间局部性：如果程序中的某条指令被执行，那么在不久的将来，与此指令相邻的指令也很有可能被执行。（顺序）</li></ul><p>虚拟内存的三个重要特性：</p><ul><li>多次性：进程可以分多次将数据装入内存，而不是一次性将所有数据装入内存。</li><li>对换性：进程在运行期间，如果内存空间不足，可以将暂时不使用的部分数据换出到外存，腾出空间给其他进程使用，当需要使用这些数据时，再将其换入内存。</li><li>虚拟性：进程可以访问比实际物理内存更大的地址空间，即虚拟内存。</li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p>1.页表机制</p><p>页表内容:页号+物理块号+状态位+访问字段+修改位+外存地址</p><ul><li>状态位：表示该页是否在内存中，1表示在内存中，0表示不在内存中。</li><li>访问字段：记录该页是否被访问过。</li><li>修改位：记录该页是否被修改过。</li><li>外存地址：记录该页在外存中的位置。</li></ul><p>2.缺页中断与地址变换！！！！！背会</p><p><img src="/../0_images/kinglyWay-operatingSystem/3_13_%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="alt text"></p><h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><p>驻留集的概念：驻留集是指在内存中实际存在的页面集合，即进程在内存中实际占用的页面数。</p><p>分配策略：</p><ul><li>固定分配：进程启动时，系统为其分配固定数量的页框，进程运行期间，页框数不变。</li><li>可变分配：进程启动时，系统为其分配一定数量的页框，进程运行期间，根据需要动态调整页框数。</li></ul><p>置换策略：</p><ul><li>全局置换：系统根据全局信息选择一个页面进行置换。</li><li>局部置换：系统根据局部信息选择一个页面进行置换。</li></ul><p>组合一下：</p><ul><li>固定分配+全局置换：不存在</li><li>固定分配+局部置换：为每个进程分配固定数量的页框，进程运行期间，从这些固定的页框中选择一个页面进行置换。</li><li>可变分配+全局置换：为每个进程分配一定数量的页框，进程运行期间，根据需要动态调整页框数，系统根据全局信息选择一个页面进行置换。</li><li>可变分配+局部置换：为每个进程分配一定数量的页框，进程运行期间，根据需要动态调整页框数，系统根据分配的页框选择一个页面进行置换。</li></ul><p><strong>后面一些小概念：</strong></p><p>调入页表的时机：</p><ul><li>预调入策略：在进程运行期间，如果预见到将要访问的页面不在内存中，则提前将其调入内存。(根据局部性原理，但是目前预测成功率不是很高)</li><li>请求调页策略：在进程运行期间，如果访问的页面不在内存中，则产生缺页中断，系统将页面调入内存。</li></ul><p>从何处调入：</p><ul><li>系统拥有足够的对换区：从系统拥有的兑换区中调入页面。需要先将和进程有关的信息复制一份到对换区</li><li>系统拥有有限的对换区：不被修改的页面从文件区直接调入，当换出的时候，不必经过对换区，直接丢弃就行。被修改的页面，当换出的时候，需要将页面复制到对换区，当换入的时候，需要将页面复制到内存中，后续需要修改文件区之中的内容</li><li>UNIX：第一次被调入的时候，直接从文件区中调入，后续调出的时候存在对换区，再次调入的时候，直接从对换区中调入，不需要再次从文件区中调入。(对于一些共享的资源非常友好)</li></ul><h3 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h3><p>1.最佳置换算法(不可实现，主要用来评估其他算法)</p><ul><li>选择淘汰的页面是后面再也用不到的页面<br><img src="/../0_images/kinglyWay-operatingSystem/3_14_OPT.png" alt="alt text"></li></ul><p>2.先进先出置换算法(FIFO)</p><ul><li>选择最早调入的页面进行置换<br><img src="/../0_images/kinglyWay-operatingSystem/3_15_FIFO.png" alt="alt text"></li></ul><p>3.最近最久未使用置换算法(LRU)</p><ul><li>选择最近最久未使用的页面进行置换<br><img src="/../0_images/kinglyWay-operatingSystem/3_16_LRU.png" alt="alt text"></li></ul><p>4.时钟置换算法(Clock)</p><ul><li>访问位为0的页面进行置换</li><li>访问位为1的页面，将其访问位清零，然后继续查找下一个页面，直到找到一个访问位为0的页面进行置换<br><img src="/../0_images/kinglyWay-operatingSystem/3_17_CLOCK.png" alt="alt text"></li></ul><p>5.改进的时钟置换算法(改进的Clock)</p><ul><li>访问位(A),修改位(M)</li><li>四类<ul><li>1类：A&#x3D;0,M&#x3D;0:最近没有访问过，也没有修改过，最佳淘汰页</li><li>2类：A&#x3D;0,M&#x3D;1:最近没有访问过，但是修改过，次佳淘汰页</li><li>3类：A&#x3D;1,M&#x3D;0:最近访问过，但是没有修改过</li><li>4类：A&#x3D;1,M&#x3D;1:最近访问过，也修改过</li></ul></li><li>访问位为1的页面，将其访问位清零，然后继续查找下一个页面，直到找到一个访问位与修改位同时为0的页面进行置换(最后都会转化为1类或者2类)</li></ul><h3 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h3><ul><li><p>抖动：频繁的页面置换，导致系统性能下降。</p><ul><li>主要与驻留集大小有关，提出工作集的概念</li></ul></li><li><p>工作集：一段时间内，进程可能频繁访问的页面集合。<br><img src="/../0_images/kinglyWay-operatingSystem/3_18_%E5%B7%A5%E4%BD%9C%E9%9B%86.png" alt="alt text"></p></li><li><p>驻留集的大小不得小于工作集的大小，否则会导致频繁的页面置换，降低系统性能。</p></li></ul><h1 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h1><h2 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h2><h3 id="基本小概念"><a href="#基本小概念" class="headerlink" title="基本小概念"></a>基本小概念</h3><p>系统运行时，计算机以进程为基本单位，用户进行输入输出时，则以文件为基本单位</p><p>文件的定义：</p><ul><li>数据项：是文件中最小的数据单位。<ul><li>基本数据项：是构成记录的基本单位，如姓名、年龄等。</li><li>组合数据项：由基本数据项组合而成</li></ul></li><li>记录：是文件中一组相关数据的集合。</li><li>文件：是具有符号名的相关信息的集合。<br>(仿照数据库，文件是数据库，记录是表，数据项是字段)</li></ul><p>文件的属性</p><ul><li>名称：文件的标识符，文件名唯一</li><li>类型：文件的类型，如文本文件、二进制文件等</li><li>创建者：文件的创建者ID</li><li>所有者：文件的拥有者ID</li><li>位置：指向设备和设备上下文的指针</li><li>大小：文件的大小</li><li>保护：文件的访问权限，如只读、读写等</li><li>时间戳：文件的创建时间、修改时间等</li></ul><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>文件控制块（FCB）：是文件属性及其相关信息的集合，用于描述和控制文件。</p><ul><li>FCB是文件存在的标志，每个文件都有一个唯一的FCB。</li><li>FCB的集合构成文件目录。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/4_1_FCB.png" alt="alt text"></p><p>索引节点</p><ul><li>当文件很多的时候，检索文件目录会非常耗时，但是其实检索的时候只需要使用FCB之中的文件名这一属性，不需要使用完整的FCB，所以引入索引节点</li><li>索引节点是文件目录的简化版，只包含文件名和索引节点号</li><li>索引节点号指向FCB，FCB中包含文件的其他属性</li></ul><h3 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h3><ul><li>创建文件：分配外存空间，在目录之中创建一个目录项</li><li>删除文件：查找目录项，释放空间，删除目录项</li><li>读文件：查找目录项，找到外存地址，在目录项之中有一个用于文件读操作的指针</li><li>写文件：查找目录项，找到外存地址，在目录项之中有一个用于文件写操作的指针，更新写指针</li></ul><p><strong>文件的打开与关闭</strong></p><ul><li>打开文件，维护两个表<ul><li>整个系统的打开文件表：包含与进程无关的信息<ul><li>文件在磁盘的位置</li><li>文件的大小</li><li>访问日期等</li></ul></li><li>进程的打开文件表：包含与进程相关的信息<ul><li>当前的读&#x2F;写指针</li><li>文件访问权限</li><li>指向系统表之中适当条目的指针</li></ul></li></ul></li></ul><p>注意：</p><ul><li>系统的打开文件表之中会维护一个打开计数器，当进程打开文件时，计数器加1，当进程关闭文件时，计数器减1，当计数器为0时，系统会删除该文件</li><li>文件名不是打开文件表之中的必要部分，当用文件名检索到FCB的磁盘定位(索引节点)，之后，就不在需要文件名了</li><li>例子：C++ open文件之后会生成一个文件描述符，后续的read，write等操作都是基于文件描述符进行的，不需要文件名</li></ul><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p>无结构文件：</p><ul><li>文件中的数据没有明显的结构，数据项之间没有关系。所以也成为流文件，其长度以字节为单位。比如系统中运行的大量的程序文件，它们都是无结构的文件。</li></ul><p>有结构文件</p><ul><li>也成为记录式文件：文件中的数据由若干个记录组成，每个记录由若干个数据项组成。记录式文件又分为定长记录和变长记录两种。<ul><li>定长记录：每个记录的长度相同，如学生信息管理系统中的学生记录，每个记录包含姓名、年龄、性别等字段，每个记录的长度相同。</li><li>变长记录：每个记录的长度不同，如电子邮件，每个邮件的长度不同。</li></ul></li><li>按照记录的组织方式，记录式文件又分为顺序文件、索引文件和索引顺序文件三种。<ul><li>顺序文件：文件之中的记录按照一定的顺序排列。；两种结构串结构(记录之间的顺序与关键字无关，通常是按照存入的顺序排列的)和顺序结构(按照关键字的顺序排列，适合查找)</li><li>索引文件：文件之中包含一个索引表，索引表中的每个索引项包含一个关键字和指向该记录的指针。<ul><li>定长记录的文件：直接A &#x3D; n*len + 1便可以得到相应的文件的下标注</li><li>变长记录的文件：得依靠索引表<br> <img src="/../0_images/kinglyWay-operatingSystem/4_2_%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png" alt="alt text"></li></ul></li><li>索引顺序文件：顺序与索引的结合(看一下书中例子，很好理解，就像微信朋友上面的ABCD…)<br><img src="/../0_images/kinglyWay-operatingSystem/4_3_%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png" alt="alt text"></li></ul></li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><p>小概念：</p><ul><li>磁盘块：类似于内存的分页，磁盘也分成若干个块，每个块的大小相等</li><li>注意文件的分配以及空闲块的管理</li><li>文件分配的三种方式<ul><li>连续分配：将文件分配给连续的磁盘块，文件在磁盘上的位置是连续的。</li><li>链接分配：将文件分配给不连续的磁盘块，每个磁盘块包含一个指针，指向下一个磁盘块。</li><li>索引分配：将文件分配给不连续的磁盘块，每个文件包含一个索引表，索引表中的每个索引项包含一个磁盘块号和指向该磁盘块的指针。</li></ul></li></ul><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>将文件分配给连续的磁盘块，文件在磁盘上的位置是连续的。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_4_%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" alt="alt text"></p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>1.隐式链接</p><p>将文件分配给不连续的磁盘块，每个磁盘块包含一个指针，指向下一个磁盘块。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_5_%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5.png" alt="alt text"></p><p>2.显式链接</p><p>维护一个FAT(文件分配表)</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_6_%E6%98%BE%E7%A4%BA%E9%93%BE%E6%8E%A5.png" alt="alt text"></p><p>-1表示文件的最后一块 -2表示空闲，因此FAT还能做空闲块管理</p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>打开某个文件的时候，不需要把全部的FAT调入内存，只需要调入相应文件的FAT即可，因此将伟哥文件的盘块号放在一起</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_7_%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png" alt="alt text"></p><p><strong>多级索引分配</strong></p><ul><li>文件太大，一个索引表放不下，因此引入多级索引分配</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/4_8_%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png" alt="alt text"></p><p><strong>混合索引分配</strong></p><p>单级索引放不下大文件，多级索引需要多次访问磁盘，因此引入混合索引分配</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_9_%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png" alt="alt text"></p><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p>文件保护：防止文件被非法访问和修改。</p><p>访问类型：</p><ul><li>读：读取文件内容</li><li>写：修改文件内容</li><li>执行：运行文件</li><li>添加：向文件中添加内容</li><li>删除：删除文件</li><li>列表清单：列出文件名和文件属性</li></ul><p>访问控制：</p><p>三种用户类型：</p><ul><li>所有者：文件的创建者</li><li>群组：文件的创建者所在的群组</li><li>其他：其他用户</li></ul><p>访问控制表:</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_10_%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="alt text"></p><p>其他的访问控制方式：</p><ul><li>口令和密码</li></ul><h2 id="4-2-目录"><a href="#4-2-目录" class="headerlink" title="4.2 目录"></a>4.2 目录</h2><h3 id="目录的基本概念"><a href="#目录的基本概念" class="headerlink" title="目录的基本概念"></a>目录的基本概念</h3><p>目录：是文件控制块（FCB）的有序集合，用于描述和控制文件。</p><h3 id="目录的操作："><a href="#目录的操作：" class="headerlink" title="目录的操作："></a>目录的操作：</h3><ul><li>搜索</li><li>创建文件</li><li>删除文件</li><li>创建目录</li><li>删除目录</li><li>移动目录</li><li>显示目录</li><li>修改目录</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>1.单级目录结构</p><p>整个文件系统只有一个目录，所有文件的FCB都放在这个目录下。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_11_%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p>缺点: 不同的用户可能拥有相同的文件名，无法对文件进行分类管理。</p><p>2.两级目录结构</p><p>将文件系统按照用户进行分类，每个用户都有一个自己的目录，目录下存放该用户的文件。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_12_%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p>3.树型目录结构</p><p>将文件系统按照层次进行分类，每个目录下可以包含子目录和文件。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_13_%E6%A0%91%E5%9E%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p>4.无环图目录结构(了解)</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_14_%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="alt text"></p><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p>1.顺序列表<br>2.哈希表</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>1.硬链接</p><p>基于索引点的方式，创建一个指向索引点的指针，相当于复制了一个指针，而不是复制了文件本身。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_15_%E7%A1%AC%E9%93%BE%E6%8E%A5.png" alt="alt text"></p><p>删除的时候，需要count等于0的时候，才会删除文件，即使是文件拥有者删除文件，也需要count等于0的时候，才可以删除文件。</p><p>2.符号链接</p><p>符号链接类似于快捷方式，指向的文件</p><p>当文件删除之后，再想通过符号链接访问文件，会访问失败，这个时候，需要删除符号链接</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_16_%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB.png" alt="alt text"></p><h2 id="4-3-文件系统实例"><a href="#4-3-文件系统实例" class="headerlink" title="4.3 文件系统实例"></a>4.3 文件系统实例</h2><p>文件系统结构</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_17_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="alt text"></p><p>看一看书吧！</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_18_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="alt text"></p><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p>主要是空闲空间管理</p><p>1.空闲表法</p><p>空闲表法：将所有空闲块用一个在外存上用一个空闲表来记录</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_19_%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png" alt="alt text"></p><p>盘块的分配：</p><ul><li>首次适应，最佳适应</li></ul><p>盘块的回收：</p><ul><li>内存的回收，涉及到空闲块的合并</li></ul><p>2.空闲链表法</p><p>空闲盘块链：将所有空闲块用一个链</p><p>空闲盘区链：将磁盘之中的空闲盘区拉成一个链</p><p>3.位士图<br><img src="/../0_images/kinglyWay-operatingSystem/4_20_%E4%BD%8D%E5%A3%AB%E5%9B%BE.png" alt="alt text"></p><p>4.成组链接法</p><p>成组链接法：将磁盘分为若干个盘组，每个盘组包含若干个盘块，每个盘组包含一个索引表，索引表中的每个索引项包含一个盘块号和指向该盘块的指针。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_21_%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt="alt text"></p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>虚拟文件系统：将多个文件系统整合成一个统一的文件系统，用户无需关心文件系统的具体实现，只需要使用统一的接口进行操作。</p><p><img src="/../0_images/kinglyWay-operatingSystem/4_22_%E8%99%9A%E6%8B%9F%E9%97%AE%E4%BB%B7%E7%B3%BB%E7%BB%9F.png" alt="alt text"></p><h1 id="第五章-输入输出管理"><a href="#第五章-输入输出管理" class="headerlink" title="第五章  输入输出管理"></a>第五章  输入输出管理</h1><p>这里就不说太详细了</p><h2 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a>5.1 I&#x2F;O管理概述</h2><p>小概念:</p><ul><li>I&#x2F;O设备分类</li><li>I&#x2F;O接口</li><li>I&#x2F;O接口类型</li><li>I&#x2F;O端口<ul><li>独立编址</li><li>统一编址</li></ul></li></ul><p>I&#x2F;O控制方式</p><ul><li>程序控制：CPU对I&#x2F;O设备进行直接控制，CPU不断查询I&#x2F;O设备的状态，当I&#x2F;O设备准备好数据后，CPU将数据从I&#x2F;O设备读入内存。</li><li>中断驱动：CPU对I&#x2F;O设备进行间接控制，当I&#x2F;O设备准备好数据后，向CPU发送中断信号，CPU响应中断，将数据从I&#x2F;O设备读入内存。</li><li>DMA：直接存储器访问，CPU将I&#x2F;O设备的数据直接读入内存，无需CPU干预。</li><li>通道：CPU将I&#x2F;O设备的数据直接读入内存，无需CPU干预。</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/5_1_IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-operatingSystem/5_2_IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B.png" alt="alt text"></p><p>I&#x2F;O软件层次结构</p><p><img src="/../0_images/kinglyWay-operatingSystem/5_3_IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="alt text"></p><h2 id="5-2-设备独立性软件"><a href="#5-2-设备独立性软件" class="headerlink" title="5.2 设备独立性软件"></a>5.2 设备独立性软件</h2><h3 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h3><p>注意：逻辑上告诉缓存属于磁盘，但是物理上属于内存</p><p>缓存技术：</p><ul><li>单缓存：只有一个缓存</li><li>双缓存：有两个缓存。</li><li>循环缓存：有多个缓存，按照顺序循环使用</li><li>缓存池：有多个缓存，按照一定的策略选择使用</li></ul><p><img src="/../0_images/kinglyWay-operatingSystem/5_4_%E5%8D%95%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8F%8C%E7%BC%93%E5%AD%98.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-operatingSystem/5_5_%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E9%A2%84%E8%AE%A1%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="alt text"></p><h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><p><img src="/../0_images/kinglyWay-operatingSystem/5_6_SPOOLing%E6%8A%80%E6%9C%AF.png" alt="alt text"></p><p>1.提高了I&#x2F;O的速度<br>2.将独占设备转换为共享设备<br>3.实现了虚拟设备(每个进程都觉得自己独占这个设备)</p><h2 id="磁盘和固态硬盘"><a href="#磁盘和固态硬盘" class="headerlink" title="磁盘和固态硬盘"></a>磁盘和固态硬盘</h2><p>一些概念性的直接看书吧</p><p>有一些比较重要：</p><p>1.磁盘调度算法：</p><ul><li>先来先服务(FCFS)</li><li>最短寻道时间优先(SSTF)<br><img src="/../0_images/kinglyWay-operatingSystem/5_7_FCFS_SSTF.png" alt="alt text"></li><li>扫描算法(SCAN)</li><li>循环扫描算法(C-SCAN)</li><li>LOOK算法</li><li>CLOOK算法<br><img src="/../0_images/kinglyWay-operatingSystem/5_8_%E5%90%8E%E5%9B%9B%E4%B8%AA.png" alt="alt text"></li></ul><p>2.减少延迟</p><p>磁盘读入数据的之后需要一定时间的处理，才能读下一个盘块！</p><p><img src="/../0_images/kinglyWay-operatingSystem/5_9_%E4%BA%A4%E9%94%99%E7%BC%96%E5%8F%B7%E4%B8%8E%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 408学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王道 </tag>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 王道2026学习笔记</title>
      <link href="/2025/04/13/kinglyWay-network/"/>
      <url>/2025/04/13/kinglyWay-network/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-王道2026学习笔记"><a href="#计算机网络-王道2026学习笔记" class="headerlink" title="计算机网络 王道2026学习笔记"></a>计算机网络 王道2026学习笔记</h1><h1 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h1><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><h3 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h3><p>计算机网络是一个将分散的、独立的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p><p>由若干节点（计算机，集线器，交换机或路由器等）和连接这些节点的链路组成。</p><p>网络之间通过 路由器 互联</p><h3 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h3><p>分角度</p><ul><li><strong>组成部分</strong>：硬件(主机、路由器、交换机、集线器、调制解调器等)、软件(网络协议、网络操作系统、网络应用软件等),协议</li><li><strong>工作方式</strong>：边缘部分（用户直接使用）和核心部分（数据交换）</li><li><strong>功能组成</strong>：通信子网（实现数据传输）和资源子网（实现资源共享）</li></ul><h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><ul><li><strong>数据通信</strong>：数据传输、信号传输</li><li><strong>资源共享</strong>：硬件、软件、数据</li><li><strong>分布式处理</strong>：多台计算机协同完成一项任务</li><li><strong>提高系统可靠性</strong>：一台计算机故障，其他计算机可以顶替</li><li><strong>负载均衡</strong>：多台计算机共同承担工作任务</li></ul><h3 id="电路交换、报文交换、分组交换"><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h3><p><strong>电路交换</strong></p><ul><li>通信之前需要建立连接，连接建立后才能通信，通信结束后释放连接(建立连接-&gt;传输数据-&gt;释放连接)</li><li>优点：通信时延小，有序传输，没有冲突，实时性强</li><li>缺点：建立连接时间长，信道利用率低，灵活性差，难以实现差错控制</li><li>样例：传统的电话网</li></ul><p><img src="/../0_images/kinglyWay-network/1_1_%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png" alt="alt text"></p><p><strong>报文交换</strong></p><ul><li>将整个报文发送到下一个节点，再由下一个节点转发，直到到达目的节点(存储转发技术)</li><li>优点：无建立连接时延，灵活分配线路，线路利用率高，易于实现差错控制</li><li>缺点：转发时延大，缓存开销大，有序性难以保证，实时性差</li></ul><p><strong>分组交换</strong></p><ul><li>将报文划分为若干个分组，每个分组独立传输，到达目的节点后重新组装(存储转发技术)</li><li>分组：<ul><li>分组头：分组序号、分组长度、目的地址、源地址等</li><li>分组数据：报文数据</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/1_2_%E5%88%86%E7%BB%84%E6%8A%A5%E6%96%87.png" alt="alt text"></p><ul><li>优点：由报文交换的优点，此外还有 方便存储和管理，传输效率高，减少了出错的概率和重传的代价</li><li>缺点：存在存储转发的时延，需要传输额外的分组头信息，可能会出现失序、重复以及丢失分组的情况</li></ul><p><img src="/../0_images/kinglyWay-network/1_3_%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="alt text"></p><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p><strong>按交换技术分类</strong></p><ul><li>电路交换网</li><li>报文交换网</li><li>分组交换网</li></ul><p><strong>按网络范围分类</strong></p><ul><li>广域网(WAN)</li><li>城域网(MAN)</li><li>局域网(LAN)</li><li>个人区域网(PAN)</li></ul><p><strong>按传播技术</strong></p><ul><li>广播式网络：所有节点共享一个通信信道</li><li>点对点网络：每条物理线路连接两个节点</li></ul><p><strong>按拓扑结构分类</strong></p><ul><li>总线型网络</li><li>星型网络</li><li>环型网络</li><li>网状型网络</li></ul><h3 id="计算机网络的性能指标-了解"><a href="#计算机网络的性能指标-了解" class="headerlink" title="计算机网络的性能指标(了解)"></a>计算机网络的性能指标(了解)</h3><p><strong>速率</strong></p><ul><li><p>数据传输速率，即数据率，表示单位时间内传输的数据量，单位是比特&#x2F;秒(bps)</p></li><li><p>带宽，即数据传输速率，单位是比特&#x2F;秒(bps)</p></li><li><p>吞吐量，即单位时间内通过某个网络(信道或接口)的数据量，单位是比特&#x2F;秒(bps)</p></li><li><p>时延，即数据从网络的一端传送到另一端所需的时间，单位是秒(s)</p><ul><li>发送时延：主机或路由器发送数据帧所需要的时间</li><li>传播时延：电磁波在信道中传播一定距离所需要的时间</li><li>处理时延：主机或路由器对收到的数据帧进行处理所需要的时间</li><li>排队时延：数据帧在路由器输入队列和输出队列中排队等待处理所需要的时间</li><li>总时延：发送时延 + 传播时延 + 处理时延 + 排队时延</li></ul></li><li><p>时延带宽积：时延带宽积 &#x3D; 传播时延 * 带宽，表示信道中可以容纳的数据量，单位是比特</p></li><li><p>往返时延RTT：从发送端发送数据开始，到发送端收到接收端的确认，所需要的时间，单位是秒(s)</p></li><li><p>利用率：网络中处于活跃状态的链路或节点所占用的比例，单位是百分比</p></li></ul><h2 id="1-2-计算机网络体系结构与参考模型"><a href="#1-2-计算机网络体系结构与参考模型" class="headerlink" title="1.2 计算机网络体系结构与参考模型"></a>1.2 计算机网络体系结构与参考模型</h2><h3 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h3><p><strong>分层的原则：</strong></p><ul><li>每一层都实现一种相对独立的功能，降低大系统的复杂性</li><li>每层之间的接口自然清晰，易于理解，相互交流尽可能的少</li><li>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现</li><li>保持下层对上层的独立性，上层单向依赖下层，下层单向服务上层</li><li>整个分层结构应能促进标准化工作</li></ul><p>一些概念：</p><ul><li>对等层：同一网络(不同机器上)中相同层次上的实体</li><li>对等实体：同一网络(不同机器上)中相同层次上的实体</li><li>协议数据单元(PDU)：对等层之间交换的信息单元</li><li>服务数据单元(SDU)：同一层内部传递的数据单元</li><li>协议控制信息(PCI)：控制协议操作的信息</li><li>n-SDU + n-PCI &#x3D; n-PDU &#x3D; (n-1)-SDU !!!!</li></ul><p><img src="/../0_images/kinglyWay-network/1_4_%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="alt text"></p><h3 id="计算机网络协议，接口，服务的概念"><a href="#计算机网络协议，接口，服务的概念" class="headerlink" title="计算机网络协议，接口，服务的概念"></a>计算机网络协议，接口，服务的概念</h3><p><strong>协议：</strong></p><p>为了在网络中进行数据交换而建立的规则、标准或约定成为<strong>网络协议</strong></p><p>网络协议时控制对等实体之间进行通信的规则，是水平的。</p><p>协议由三部分组成：</p><ul><li>语法：定义了数据与控制信息的格式</li><li>语义：需要发出何种控制信息，以及完成的动作以及如何响应对方的动作</li><li>同步：执行各个操作的条件以及时序关系</li></ul><p><strong>接口：</strong></p><p>同一节点内相邻两层之间交换信息的逻辑接口，服务访问点(SAP). 每层只能在紧邻的层之间定义接口，不可以跨层定义</p><p><strong>服务：</strong></p><p>下层为紧邻的上层所提供的一组操作，是垂直的</p><p><img src="/../0_images/kinglyWay-network/1_5_%E5%8D%8F%E8%AE%AE%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="alt text"></p><p>计算机网络提供的服务可分为以下三种类型：</p><ol><li>面向连接和无连接的服务</li></ol><ul><li>面向连接的服务：在数据传输之前需要先建立连接，数据传输结束后需要释放连接</li><li>无连接的服务：在数据传输之前不需要建立连接，数据传输结束后不需要释放连接</li></ul><ol start="2"><li>可靠服务和不可靠服务</li></ol><ul><li>可靠服务：保证数据传输的可靠性，包括数据传输的顺序、数据传输的完整性等</li><li>不可靠服务：不保证数据传输的可靠性，只负责将数据传输到目的节点，不保证数据传输的顺序、数据传输的完整性等</li></ul><ol start="3"><li>有应答服务和无应答服务</li></ol><ul><li>有应答服务：在数据传输过程中需要接收方的应答，以确保数据传输的可靠性</li><li>无应答服务：在数据传输过程中不需要接收方的应答，只负责将数据传输到目的节点，不保证数据传输的可靠性</li></ul><h3 id="计算机网络体系结构参考模型"><a href="#计算机网络体系结构参考模型" class="headerlink" title="计算机网络体系结构参考模型"></a>计算机网络体系结构参考模型</h3><p><strong>OSI参考模型</strong></p><ul><li>OSI参考模型是一个理论模型，用于描述计算机网络的结构和功能</li><li>OSI参考模型将计算机网络分为七个层次，从低到高分别为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</li><li>每一层都有特定的功能和协议，用于实现网络通信的不同方面</li><li>OSI参考模型是一种理论模型，实际的网络协议和实现可能不完全符合该模型，但可以作为理解和设计网络协议的参考</li></ul><p><img src="/../0_images/kinglyWay-network/1_6_OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="alt text"></p><p>先有一个概念，后面重要的层会详细讲解</p><p><strong>1.物理层</strong></p><ul><li>物理层是OSI参考模型的最底层，负责实现物理连接，即实现数据传输的物理介质和传输速率</li><li>物理层的主要功能包括：定义物理连接的电气特性、机械特性、功能特性和规程特性等</li><li>物理层的主要设备包括：网卡、调制解调器、中继器、集线器等</li><li>传输的数据单位是比特(bit)</li></ul><p><strong>2.数据链路层</strong></p><ul><li>数据链路层是OSI参考模型的第二层，负责在物理连接上进行<strong>可靠的数据传输</strong></li><li>数据链路层的主要功能包括：帧的封装与拆封、帧的校验与确认(差错控制)、流量控制等</li><li>数据链路层的主要设备包括：交换机、路由器等</li><li>传输的数据单位是帧(frame)</li></ul><p><strong>3.网络层</strong></p><ul><li>网络层是OSI参考模型的第三层，负责实现数据在网络中的传输</li><li>网络层的主要功能包括：路由选择、拥塞控制、网络互联等</li><li>网络层的主要设备包括：路由器、交换机等</li><li>传输的数据单位是数据报(packet)</li></ul><p><strong>4.传输层</strong></p><ul><li>传输层是OSI参考模型的第四层，负责实现端到端(端口到端口)的可靠数据传输</li><li>传输层的主要功能包括：可靠传输、流量控制、拥塞控制等</li><li>传输层的主要设备包括：防火墙、代理服务器等</li><li>传输的数据单位是报文段(segment)</li></ul><p><strong>5.会话层</strong></p><ul><li>会话层是OSI参考模型的第五层，负责在两个进程之间建立、管理和终止会话</li><li>会话层的主要功能包括：会话的建立、管理和终止、同步等</li><li>会话层的主要设备包括：会话服务器等</li><li>传输的数据单位是会话数据单元(session data unit)</li></ul><p><strong>6.表示层</strong></p><ul><li>表示层是OSI参考模型的第六层，负责数据的表示、加密、压缩等</li><li>表示层的主要功能包括：数据格式的转换、数据加密、数据压缩等</li><li>表示层的主要设备包括：加密设备、解密设备等</li><li>传输的数据单位是表示数据单元(representation data unit)</li></ul><p><strong>7.应用层</strong></p><ul><li>应用层是OSI参考模型的第七层，负责提供网络应用服务</li><li>应用层的主要功能包括：文件传输、电子邮件、远程登录、Web浏览等</li><li>应用层的主要设备包括：服务器、客户端等</li><li>传输的数据单位是应用数据单元(application data unit)</li></ul><p><strong>TCP&#x2F;IP参考模型</strong></p><ul><li>TCP&#x2F;IP参考模型是一个实际使用的网络协议栈，用于实现网络通信</li><li>TCP&#x2F;IP参考模型将计算机网络分为四个层次，从低到高分别为：网络接口层、互联网层(网络层，网际层)、传输层和应用层</li><li>每一层都有特定的功能和协议，用于实现网络通信的不同方面</li><li>TCP&#x2F;IP参考模型是一种实际使用的网络协议栈，实际的网络协议和实现可能不完全符合该模型，但可以作为理解和设计网络协议的参考</li></ul><p><img src="/../0_images/kinglyWay-network/1_7_TCPIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="alt text"></p><p><strong>TCP&#x2F;IP参考模型与OSI参考模型的区别</strong></p><ul><li>OSI参考模型是一个理论模型，用于描述计算机网络的结构和功能，而TCP&#x2F;IP参考模型是一个实际使用的网络协议栈，用于实现网络通信</li><li>OSI参考模型将计算机网络分为七个层次，而TCP&#x2F;IP参考模型将计算机网络分为四个层次</li><li>OSI参考模型中的数据链路层和物理层在TCP&#x2F;IP参考模型中合并为网络接口层</li><li>OSI参考模型中的会话层、表示层和应用层在TCP&#x2F;IP参考模型中合并为应用层</li></ul><p><img src="/../0_images/kinglyWay-network/1_8_TCPIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="alt text"></p><p><strong>应用层DNS报文逐层封装的关系</strong><br>就是之前说的SDU PCI 与 PDU的关系</p><p><img src="/../0_images/kinglyWay-network/1_9_DNS%E6%8A%A5%E6%96%87%E9%80%90%E5%B1%82%E5%B0%81%E8%A3%85.png" alt="alt text"></p><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.数据，信号和码元</p><ul><li>数据：数据是信息的载体，是各种文字、图像、声音、视频等信息的集合</li><li>信号：信号是数据在传输过程中的表现形式，包括模拟信号(连续的)和数字信号(离散的)</li><li>码元：码元是信号的基本单位，是数字信号的基本单位</li></ul><p>2.信源，信宿，信道</p><ul><li>信源：信源是信息的发送者，将信息转换为信号发送出去</li><li>信宿：信宿是信息的接收者，将信号转换为信息接收进来</li><li>信道：信道是信号传输的通道，包括有线信道和无线信道</li></ul><p>三种基本通信方式：</p><ul><li>单工通信：单工通信是指信号只能单向传输，即只有发送方和接收方，没有双向通信</li><li>半双工通信：半双工通信是指信号可以双向传输，但同一时刻只能有一方发送信号，另一方接收信号</li><li>全双工通信：全双工通信是指信号可以双向传输，即发送方和接收方可以同时发送和接收信号</li></ul><p>3.速率，波特与带宽</p><ul><li>速率：速率是指单位时间内传输的数据量，单位是比特&#x2F;秒(bps)</li><li>波特：波特是指单位时间内传输的信号数，单位是波特(bps)</li><li>带宽：带宽是指信号传输的频率范围，单位是赫兹(Hz)</li></ul><h3 id="信道的极限容量："><a href="#信道的极限容量：" class="headerlink" title="信道的极限容量："></a>信道的极限容量：</h3><ul><li>奈奎斯特定理(无噪)：奈奎斯特定理是描述信道极限容量的定理，它指出，在理想条件下，信道的极限容量为2Wlog2V bps，其中W为信道的带宽，V为信道内可分辨的最小信号电压幅值</li><li>香农定理(考虑到噪声)：香农定理是描述信道极限容量的定理，它指出，在噪声存在的条件下，信道的极限容量为Wlog2(1+S&#x2F;N) bps，其中W为信道的带宽，S为信号功率，N为噪声功率</li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><ul><li>编码：编码是将数据转换为信号的过程，包括数字编码和模拟编码</li><li>调制：调制是将信号转换为适合传输的过程，包括模拟调制和数字调制</li></ul><p>1.数字数据编码为数字信号</p><ul><li>归零编码：归零编码是一种数字编码方式，将数字信号转换为归零信号，即信号在0电平上归零</li><li>不归零编码：不归零编码是一种数字编码方式，将数字信号转换为不归零信号，即信号在0电平上不归零</li><li>反向不归零编码：反向不归零编码是一种数字编码方式，将数字信号转换为反向不归零信号，即信号在0电平上不归零，但在1电平上归零</li><li>曼彻斯特编码：曼彻斯特编码是一种数字编码方式，将数字信号转换为曼彻斯特信号，即信号在0电平上从高电平跳变到低电平，在1电平上从低电平跳变到高电平</li><li>差分曼彻斯特编码：看每个码元的开始是否有跳变，有跳变就是0，没有跳变就是1(中间的跳变无意义，只代表时钟)</li></ul><p><img src="/../0_images/kinglyWay-network/2_1_%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81.png" alt="alt text"></p><p>2.模拟数据编码为数字信号<br>采样，量化，编码</p><p>3.数字信号调制为模拟信号</p><ul><li>调幅：调幅是将数字信号转换为模拟信号的过程，通过改变信号的幅度来表示数字信号</li><li>调频：调频是将数字信号转换为模拟信号的过程，通过改变信号的频率来表示数字信号</li><li>调相：调相是将数字信号转换为模拟信号的过程，通过改变信号的相位来表示数字信号</li><li>正交调幅：正交调幅是将数字信号转换为模拟信号的过程，通过改变信号的幅度和相位来表示数字信号</li></ul><p><img src="/../0_images/kinglyWay-network/2_2_%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6.png" alt="alt text"></p><h2 id="2-2-传输介质-看书"><a href="#2-2-传输介质-看书" class="headerlink" title="2.2 传输介质(看书)"></a>2.2 传输介质(看书)</h2><p>(双绞线，同轴电缆，光纤，无线等)</p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h2><p>封装成帧，差错控制，流量控制，透明传输等</p><h2 id="3-2-组帧"><a href="#3-2-组帧" class="headerlink" title="3.2 组帧"></a>3.2 组帧</h2><h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><ul><li>字符计数法是一种简单的组帧方法，它通过在帧的头部添加一个计数字段来表示帧的长度</li></ul><p><img src="/../0_images/kinglyWay-network/3_1_%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="alt text"></p><p>若某一段计数字段出错了(或者丢失了) ，那么接收方无法判断帧的长度</p><h3 id="字节填充法"><a href="#字节填充法" class="headerlink" title="字节填充法"></a>字节填充法</h3><ul><li>字节填充法是一种常用的组帧方法，它通过在帧的头部和尾部添加特殊的控制字符来表示帧的开始和结束(比如：在头部添加SOH表示开始，在尾部添加 EOT表示结束)，为了防止这些控制字符与数据中的字符冲突，所以使用转义字符ESC来表示</li></ul><p><img src="/../0_images/kinglyWay-network/3_2_%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="alt text"></p><h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><ul><li>使用一个特殊的字符序列01111110来表示帧的开始和结束，如果数据中出现了这个字符序列，检测到5个连续的1，就插入一个0，这样就可以避免数据中的字符与帧的开始和结束字符冲突</li></ul><p><img src="/../0_images/kinglyWay-network/3_3_%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="alt text"></p><h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><ul><li>举个例子，曼彻斯特编码，1 为 ‘高-低’ 0 为 ‘低-高’ 那么，‘高-高’ 或者 ‘低-低’就是违规编码，可以用这些表示帧的开始和结束</li></ul><h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><p>比特差错：比特差错是指数据传输过程中，由于信道干扰等原因，导致数据中的<strong>比特位</strong>发生错误(除了比特差错之外，还有帧丢失，帧重复，帧失序等差错，这一节只讨论比特差错)</p><p>两种：</p><ul><li>自动重传请求ARQ：简单来说就是遇到差错让对方重新传</li><li>前向纠错FEC：简单来说就是自己纠正错误(检错和纠错)</li></ul><h3 id="奇偶校验码-检错码"><a href="#奇偶校验码-检错码" class="headerlink" title="奇偶校验码(检错码)"></a>奇偶校验码(检错码)</h3><p>奇偶校验码是一种简单的检错码，它通过在数据中添加一个校验位来表示数据的奇偶性</p><ul><li>奇校验码：奇校验码是指在数据中添加一个校验位，使得数据中的1的个数加上校验位的1的个数是奇数(比如：数据为1010，校验位为1，则数据为10101，1的个数为3 为奇数)</li><li>偶校验码：偶校验码是指在数据中添加一个校验位，使得数据中的1的个数加上校验位的1的个数是偶数(比如：数据为1010，校验位为0，则数据为10100，1的个数为2，校验位的1的个数为0，总共为2，为偶数)</li><li>注意：这里不仅要考虑数据中的1的个数，还要考虑校验位的1的个数</li><li>再举个例子：1001101，奇校验码，校验位为1(10011011)，偶校验码，校验位为0(10011010)</li></ul><h3 id="循环冗余校验码CRC-检错码"><a href="#循环冗余校验码CRC-检错码" class="headerlink" title="循环冗余校验码CRC(检错码)"></a>循环冗余校验码CRC(检错码)</h3><p>基本思想:</p><ul><li>收发双方约定一个生成多项式G(x)，最低位为1，比如x^3+x^2+1 为 1101</li><li>发送方基于待发送的数据计算出冗余码，然后将冗余码添加到数据的末尾，形成发送帧</li><li>接收方收到数据和冗余码之后，基于生成多项式G(x)进行校验，如果校验结果为0，则说明数据没有错误，否则说明数据有错误</li></ul><p>计算方法(看懂这个例子)：<br><img src="/../0_images/kinglyWay-network/3_4_CRC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="alt text"></p><h3 id="海明码-纠错码"><a href="#海明码-纠错码" class="headerlink" title="海明码(纠错码)"></a>海明码(纠错码)</h3><p>这个太复杂了，可以看书了解以下，感觉一般面试的话不会问这个细节，但是要知道这个海明码可以检错和纠错</p><h2 id="3-4-流量控制和可靠传输"><a href="#3-4-流量控制和可靠传输" class="headerlink" title="3.4 流量控制和可靠传输"></a>3.4 流量控制和可靠传输</h2><p>流量控制：流量控制是指发送方和接收方之间的协调，以防止发送方发送的数据过多，导致接收方无法处理</p><p>可靠传输：可靠传输是指发送方和接收方之间的数据传输是可靠的，即发送的数据能够正确地到达接收方，并且接收方能够正确地接收数据</p><h3 id="流量控制与滑动窗口"><a href="#流量控制与滑动窗口" class="headerlink" title="流量控制与滑动窗口"></a>流量控制与滑动窗口</h3><p>1.停止-等待流量控制的思想</p><ul><li>发送方每次只允许发送一帧，接收方收到数据后，发送一个确认帧，发送方收到确认帧后，才能发送下一帧</li></ul><p>2.滑动窗口流量控制的思想</p><ul><li>发送方维护一组连续的，允许发送的帧的序号，称为发送窗口，这个意思是，还未收到对方的确认信息的情况下，发送方最多还能发送多少帧，和相应的帧的序号</li><li>接收方维护一组连续的，允许接收的帧的序号，称为接收窗口，控制可以接收那些帧和不可以接受那些帧</li></ul><p><img src="/../0_images/kinglyWay-network/3_5_%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png" alt="alt text"></p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><ul><li><p>停止-等待协议 S-W：停止-等待ARQ是一种简单的可靠传输协议，它通过停止-等待机制来实现可靠传输，即发送方每次只允许发送一帧，接收方收到数据后，发送一个确认帧，发送方收到确认帧后，才能发送下一帧(相当于发送窗口大小为1，接收窗口大小为1)</p></li><li><p>后退N帧协议 GBN：发送窗口内的多个数据可以同时发送，后退N协议的思想是，如果接收方收到一个错误的帧，那么接收方会发送一个NAK帧，发送方收到NAK帧后，会重传从该帧开始的所有帧(相当于发送窗口大小大于1，接收窗口大小为1)</p><ul><li>这里有个捎带确认的概念：ACKn表示对第n帧已经确认收到了，并且其前面的帧也没问题。</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/3_6_%E5%90%8E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE.png" alt="alt text"></p><ul><li>选择重传协议 SR: 发送窗口一次可以传输多个数据，接收窗口可以接收多个数据，如果接收方收到一个错误的帧，那么接收方会发送一个NAK帧，发送方收到NAK帧后，会重传该帧(相当于发送窗口大小大于1，接收窗口大小大于1)<ul><li>这里不会再有累计确认的概念了，每一个帧都要发送一个确认帧来保证其已经收到，如果没有收到，就重传该帧</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/3_7_%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE.png" alt="alt text"></p><h2 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><p>介质访问控制是指控制多个设备如何共享同一个通信介质的技术(避免冲突)</p><h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>这里是直接控制信道，将信道划分为多个子信道，每个设备使用不同的子信道进行通信</p><ul><li>频分复用FDM：频分复用是指将通信介质划分为多个频段，每个设备使用不同的频段进行通信</li><li>时分复用TDM：时分复用是指将通信介质划分为多个时间片，每个设备使用不同的时间片进行通信</li><li>波分复用WDM：波分复用是指将通信介质划分为多个波长，每个设备使用不同的波长进行通信</li><li>码分复用CDM：码分复用是指将通信介质划分为多个码片，每个设备使用不同的码片进行通信(这个理解以下，就相当于比如三个机器共享，那个我们就建立一个三维的坐标系 x轴y轴z轴，当发送一个数据的时候，我们就可以将之类比为发送一个向量，该向量可以拆分为x,y,z三个分量，每个分量对应一个码片，这样就可以实现多个设备同时发送数据，并且不会发生冲突)</li></ul><p><img src="/../0_images/kinglyWay-network/3_8_%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E5%92%8C%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="alt text"></p><h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><p>这里是直接控制设备，不对信道进行划分，而是让设备随机访问信道，通过一定的协议来控制冲突</p><p>1.ALOHA协议</p><ul><li>纯ALOHA协议：其他的都不管，就直接发送，没收到(超时未确认)就是遇到冲突了，重发就行。</li><li>时隙ALOHA协议：将时间划分为固定的时间片，每个设备只能在时间片开始时发送数据, 并且时隙要大于最大传播时延，这样的话保证了在一个数据发送的过程中，没其他的数据要发送，从而避免了冲突。</li></ul><p><img src="/../0_images/kinglyWay-network/3_9_ALOHA%E5%8D%8F%E8%AE%AE.png" alt="alt text"></p><p>2.CSMA(载波监听多路访问)</p><ul><li>1-坚持CSMA：如果一个设备检测到信道空闲，那么它就会发送数据，如果检测到信道忙，他就会继续监听，直到空闲再发送数据</li><li>非坚持CSMA：如果一个设备检测到信道空闲，那么它就会发送数据，如果检测到信道忙，就会放弃监听，等待一段时间之后再继续监听，如果等待时间过长，那么它就会放弃发送数据</li><li>p-坚持CSMA：如果一个设备检测到信道空闲，那么它就会以p的概率发送数据，以(1-p)的概率等待一段时间后再次检测信道</li></ul><p>3.CSMA&#x2F;CD(载波监听多路访问&#x2F;冲突检测)</p><ul><li>CSMA&#x2F;CD协议是CSMA协议和检测冲突的协议的结合，它通过检测冲突来避免冲突的发生，如果检测到冲突，那么就会停止发送数据，等待一段时间后再次发送数据</li><li>CSMA&#x2F;CD的原理是，当一个设备发送数据时，它会监听信道，如果检测到信道空闲，那么它就会发送数据，如果检测到信道忙，那么它会继续监听，直到空闲再发送数据，发送数据的过程种也在不停的监听信道吗，如果检测到冲突，那么它会停止发送数据，等待一段时间后再次发送数据</li><li>先听后发，边听边发，冲突停发，随机重发</li></ul><p>4.CSMA&#x2F;CA(载波监听多路访问&#x2F;冲突避免)</p><ul><li>用于无线局域网(CSMA&#x2F;CD用于有线局域网)</li></ul><h3 id="轮询访问：令牌传递协议"><a href="#轮询访问：令牌传递协议" class="headerlink" title="轮询访问：令牌传递协议"></a>轮询访问：令牌传递协议</h3><ul><li>令牌传递协议是一种轮询访问介质访问控制协议，它通过一个令牌来控制设备访问介质，令牌在设备之间传递，只有持有令牌的设备才能发送数据，其他设备只能等待令牌的到来</li></ul><p>流程：</p><ul><li>当网络空闲的时候，环路之中只有令牌帧在循环传递</li><li>当令牌帧到达了某个要传输设备的站点的时候，该站点回修改令牌帧之中的一个标志位，并在令牌之中附加上自己需要传输的数据，将令牌变成一个数据帧发出去。</li><li>数据帧沿着环路持续传输，接受到数据帧的站点，一边转发一边查看帧的目的地址，如果和自己的相同则复制帧，以便进一步处理</li><li>数据帧沿着环路继续传输，直到源站点，原站点会进行校验，查看传输的过程中有没有出现什么问题，如果有问题，则重传</li><li>原站点传送完数据之后产生一个新的令牌，将令牌沿着环路继续传递，交出信到的控制权</li></ul><h2 id="3-6-局域网-看书"><a href="#3-6-局域网-看书" class="headerlink" title="3.6 局域网(看书)"></a>3.6 局域网(看书)</h2><p>关键的知识点：</p><p>1.IEEE 802 局域网标准 将 数据链路层分为两个子层：LLC(逻辑链路控制)和MAC(媒体访问控制)</p><p>2.以太网的MAC地址</p><ul><li>48位，6个字节，高24位为厂商代码，低24位为厂商自定义的代码</li><li>适配器从网络之中收到一个MAC帧，则会查看帧中的目的MAC地址，如果目的MAC地址与自己的MAC地址相同，那么就会接收该帧，否则就会丢弃该帧</li><li>发往本站的帧：<ul><li>单播帧(一对一):收到的帧的目的地址与本站的MAC地址相同</li><li>广播帧(一对全体):发送给本局域网上的所有的站点的帧(全1地址)</li><li>多播帧(一对多):发送给本局域网之中部分站点的帧</li></ul></li></ul><p> <img src="/../0_images/kinglyWay-network/3_10_MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="alt text"></p><ul><li>MAC帧格式<ul><li>前导码：8个字节，前7个字节为前同步码，用于同步时钟，后一个字节为帧开始定界符，用于标识帧的开始</li><li>目的地址：6个字节，表示帧的接收方</li><li>源地址：6个字节，表示帧的发送方</li><li>类型：2个字节，表示帧的数据类型(交给上层的那个协议处理)</li><li>数据：46-1500个字节，表示帧的数据</li><li>FCS：4个字节，表示帧的校验码<ul><li>32位CRC码，目的地址，源地址，类型。不检验前导码和数据</li></ul></li></ul></li></ul><h2 id="3-7-广域网-看书，这个确实没仔细看"><a href="#3-7-广域网-看书，这个确实没仔细看" class="headerlink" title="3.7 广域网(看书，这个确实没仔细看)"></a>3.7 广域网(看书，这个确实没仔细看)</h2><p>关键的知识点：</p><p>PPP协议：点对点协议，用于在点对点链路上传输数据，它是一种面向字节的协议，它支持多种网络层协议，如IP，IPX等</p><ul><li>PPP协议的帧格式<ul><li>标志字段：1个字节，用于标识帧的开始和结束，值为01111110</li><li>地址字段：1个字节，值为0xFF</li><li>控制字段：1个字节，值为0x03</li><li>协议字段：2个字节，表示帧的数据类型</li><li>帧数据：可变长度，表示帧的数据</li><li>FCS字段：2个字节，表示帧的校验码</li></ul></li></ul><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1-网络层的功能"><a href="#4-1-网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h2><h3 id="异构网络的互连"><a href="#异构网络的互连" class="headerlink" title="异构网络的互连"></a>异构网络的互连</h3><h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><p>路由器提供两个功能</p><ul><li>路由选择：根据路由协议构造路由表</li><li>分组转发：根据路由表将分组从合适的端口转发出去</li></ul><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>1.虚电路</p><p>虚电路建立-&gt;数据传输-&gt;虚电路释放</p><p>特点</p><ul><li>虚电路通信链路建立和拆除需要时间，对长时间、频繁的数据交换效率比较高</li><li>虚电路的路由选择体现在虚电路建立的过程</li><li>虚电路提供可靠的通信，能保证每个分组正常且有序的到达(还方便流量控制)</li><li>虚电路有个致命缺点，就是当虚电路之中的一个节点出现故障，那么整个虚电路都会失效</li><li>虚电路传输的分组不需要有目的地址，只需要包含虚电路号便可以(虚电路建立的时候需要)</li></ul><p>虚电路之所有叫<strong>虚</strong>电路，是因为这条电路不是专用的，不像带你路交换那样，独占线路上的所有节点，其他虚电路也能使用这条虚电路上的节点</p><p>2.数据报</p><p>不需要建立连接，每个分组独立选择路由，不同分组可以走不同的路径</p><p>特点</p><ul><li>发送分组之前不需要建立连接，发送方随时发送，接收方随时接收</li><li>网络尽最大可能交付，不保证可靠性</li><li>网络为不同的分组独立的选择路径，不同的的分组可能经过不同的路径</li><li>数据报分组必须包含接收方和发送发完整的地址</li><li>分组在节点进行存储转发的时候，需要排队等待处理，如果网络拥塞，那么可能会出现分组丢失的情况</li><li>收发双方不会独占某条链路，网络资源利用率高</li></ul><p><img src="/../0_images/kinglyWay-network/4_1_%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="alt text"></p><h3 id="SDN的基本概念"><a href="#SDN的基本概念" class="headerlink" title="SDN的基本概念"></a>SDN的基本概念</h3><p>SDN（Software Defined Networking，软件定义网络）是一种新型的网络架构，它将网络的控制平面和数据平面分离，通过软件定义的方式来实现网络的控制和管理。</p><ul><li>控制平面：控制平面是网络的控制部分，负责路由选择、流量控制、安全策略等网络管理功能。控制平面由控制器组成，控制器通过南向接口与网络设备通信，通过北向接口与上层应用通信。</li><li>数据平面：数据平面是网络的数据传输部分，负责数据的转发和传输。数据平面由网络设备组成，如交换机和路由器等。</li></ul><p>简单理解，就是设置一个服务器负责构建，存储，更新转发表；实现路由选择等功能。这样的话路由器只需要负责 查表，转发数据便可以了。</p><p><img src="/../0_images/kinglyWay-network/4_2_SDN%E7%BB%93%E6%9E%84.png" alt="alt text"></p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>注意和流量控制的区别：</p><ul><li>流量控制：是点对点的通信控制，是接收方控制发送方发送数据的速率，使得发送方的发送速率不要超过接收方的接收速率</li><li>拥塞控制：是全局性的通信控制，是网络层面的，防止过多的数据注入到网络中，避免网络中的路由器或者链路过载</li></ul><h2 id="4-2-IPv4"><a href="#4-2-IPv4" class="headerlink" title="4.2 IPv4"></a>4.2 IPv4</h2><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p><img src="/../0_images/kinglyWay-network/4_3_IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt="alt text"></p><ul><li>版本：4位，表示IP协议的版本，IPv4的值为4</li><li>首部长度：4位，表示IP数据报的首部长度，单位为4字节，最小值为5，最大值为15，最大值为15*4&#x3D;60字节</li><li>服务类型：8位，表示IP数据报的服务类型，用于指示数据报的优先级和可靠性要求</li><li>总长度：16位，表示IP数据报的总长度，单位为字节，最大值为65535字节</li><li>标识：16位，用于标识数据报，用于分片和重组</li><li>标志：3位，MF(更多分片) DF(分不分片)</li><li>片偏移：13位，用于标识分片的位置</li><li>TTL(生存时间)：8位，表示IP数据报的生存时间，每经过一个路由器，TTL减1，当TTL为0时，数据报被丢弃</li><li>协议：8位，表示IP数据报的协议类型，如TCP，UDP等</li><li>首部校验和：16位，用于校验IP数据报的首部，注意不包含数据部分</li><li>源地址：32位，表示IP数据报的源地址</li><li>目的地址：32位，表示IP数据报的目的地址</li></ul><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h3><ul><li>IP数据报在传输过程中可能会经过不同的网络，不同的网络可能对数据报的长度有不同的要求，因此需要进行分片</li><li>分片是在数据链路层进行的，数据链路层对数据报的长度有限制，如果数据报的长度超过了数据链路层的限制，那么就需要进行分片</li><li>分片是在IP数据报的首部进行标识的，每个分片都有一个标识，用于标识分片所属的数据报</li><li>分片在到达目的地之后需要进行重组，重组是根据标识进行重组的</li></ul><p><img src="/../0_images/kinglyWay-network/4_4_IP%E5%88%86%E7%89%87%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="alt text"></p><h3 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h3><ul><li>IPv4地址由32位组成，通常用点分十进制表示，如192.168.1.1</li><li>IPv4地址分为网络地址和主机地址，网络地址表示网络，主机地址表示主机，网络地址和主机地址之间用点分十进制表示，如192.168.1.1&#x2F;24，表示网络地址为192.168.1.0，主机地址为1</li><li>IP地址 &#x3D; {&lt;网络号&gt;，&lt;主机号&gt;}<br><img src="/../0_images/kinglyWay-network/4_5_IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="alt text"></li></ul><p>特殊地址</p><ul><li>主机号全为0：表示网络地址，如192.168.1.0&#x2F;24</li><li>主机号全为1：表示广播地址，如192.168.1.255&#x2F;24</li><li>127.0.0.1：回环地址，用于本地回环测试</li><li>0.0.0.0：表示本网络上的任何主机</li><li>255.255.255.255：广播地址，表示本网络上的所有主机</li></ul><p>NAT(Network Address Translation，网络地址转换)是一种将私有IP地址转换为公有IP地址的技术，用于解决IPv4地址不足的问题。</p><p>私有地址IP：</p><ul><li><p>A类：10.0.0.0~10.255.255.255</p></li><li><p>B类：172.16.0.0~172.31.255.255</p></li><li><p>C类：192.168.0.0~192.168.255.255</p></li><li><p>NAT工作原理</p><ul><li>当一个私有网络中的主机需要访问外部网络时，NAT会将主机的私有IP地址转换为公有IP地址，并将数据报发送到外部网络</li><li>当外部网络返回数据报时，NAT会将数据报的公有IP地址转换为私有IP地址，并将数据报发送到私有网络中的主机</li></ul></li><li><p>NAT的优点</p><ul><li>可以解决IPv4地址不足的问题</li><li>可以隐藏内部网络的拓扑结构</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/4_5_NAT.png" alt="alt text"></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><ul><li>IP地址 &#x3D; {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li><li>划分主机只是把主机号部分再划分成子网号和主机号两部分，不会改变原始的网络号</li><li>子网之中主机号为全0和全1的不会被指派给主机使用，全0表示子网地址，全1表示广播地址</li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>子网掩码是一个32位的二进制数，用于标识IP地址中的网络号和主机号</li><li>子网掩码中的网络号部分为1，主机号部分为0</li><li>子网掩码与IP地址进行按位与运算，可以得到网络地址</li></ul><h3 id="CIDR-无类别域间路由"><a href="#CIDR-无类别域间路由" class="headerlink" title="CIDR(无类别域间路由)"></a>CIDR(无类别域间路由)</h3><p>不需要考虑A,B,C等类别的网络，直接使用斜线记法，表示IP地址和子网掩码，如192.168.1.1&#x2F;24</p><ul><li>CIDR使用斜线记法，表示IP地址和子网掩码，如192.168.1.1&#x2F;24</li><li>CIDR可以表示任意大小的子网，而不仅仅是2的幂次方</li><li>CIDR可以减少路由表的大小，因为CIDR可以表示多个子网，只需要一个路由表项就可以表示多个子网</li></ul><p>有几个概念：</p><ul><li>路由聚合：将多个连续的子网合并为一个更大的子网，减少路由表的大小，看书中的例子(206.1.0.0&#x2F;17与206.1.128.0&#x2F;17合并为206.1.0.0&#x2F;16)</li><li>最长前缀匹配：当路由器收到一个数据报时，会根据数据报的目的IP地址，在路由表中查找最长的匹配项，然后根据匹配项进行转发(前缀越长越具体)</li></ul><h3 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h3><p>ARP(Address Resolution Protocol，地址解析协议)用于将IP地址转换为MAC地址，用于局域网中的通信。</p><p>ARP工作原理：</p><ul><li>当一个主机需要发送数据报给另一个主机时，首先会查询ARP缓存，如果缓存中有对应的MAC地址，那么就直接使用，如果没有，那么就发送ARP请求，请求目的主机的MAC地址</li><li>目的主机收到ARP请求后，会发送ARP响应，将自己的MAC地址发送给请求的主机</li><li>请求的主机收到ARP响应后，会将目的主机的IP地址和MAC地址添加到ARP缓存中，以便下次使用</li></ul><h3 id="DHCP-Dynamic-Host-Configuration-Protocol，动态主机配置协议"><a href="#DHCP-Dynamic-Host-Configuration-Protocol，动态主机配置协议" class="headerlink" title="DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)"></a>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)</h3><p>DHCP用于为局域网中的主机动态分配IP地址，DHCP服务器会为客户端分配一个IP地址，并在一段时间后回收该IP地址。</p><p>DHCP工作原理：</p><ul><li>当一个主机需要获取IP地址时，会发送DHCP Discover报文，广播给局域网中的所有主机和DHCP服务器(源地址为0.0.0.0，目的地址为255.255.255.255)</li><li>DHCP服务器收到DHCP Discover报文后，会发送DHCP Offer报文，将自己的IP地址和提供给主机的IP地址提供出去。(源地址为DHCP服务器的IP地址，目的地址为255.255.255.255)</li><li>主机收到DHCP Offer报文后，若同意这个IP，就会发送DHCP Request报文，请求DHCP服务器分配IP地址。(源地址为0.0.0.0，目的地址为255.255.255.255)</li><li>DHCP服务器收到DHCP Request报文后，会发送DHCP Ack报文，确认分配IP地址。(源地址为DHCP服务器的IP地址，目的地址为255.255.255.255)</li></ul><p>注意DHCP分配的IP地址是临时的，时间由DHCP服务器决定，时间到了之后，DHCP服务器会回收该IP地址。</p><h3 id="ICMP-Internet-Control-Message-Protocol，互联网控制消息协议"><a href="#ICMP-Internet-Control-Message-Protocol，互联网控制消息协议" class="headerlink" title="ICMP(Internet Control Message Protocol，互联网控制消息协议)"></a>ICMP(Internet Control Message Protocol，互联网控制消息协议)</h3><p>ICMP用于在主机和路由器之间传递控制消息，用于诊断网络问题。</p><p>ICMP报文5种类型</p><ul><li>终点不可达：当路由器或主机无法将数据报发送到目的地时，会发送终点不可达报文</li><li>源点抑制：当路由器或主机收到数据报时，如果网络拥塞，会发送源点抑制报文，要求发送方降低发送速率</li><li>时间超过：当路由器或主机收到数据报时，如果TTL为0，会发送时间超过报文</li><li>参数问题：当路由器或主机收到数据报时，如果IP数据报的首部有问题，会发送参数问题报文</li><li>重定向：当路由器或主机收到数据报时，如果发现更优的路径，会发送重定向报文，告诉发送方使用新的路径</li></ul><h2 id="4-3-IPv6-了解一下"><a href="#4-3-IPv6-了解一下" class="headerlink" title="4.3 IPv6(了解一下)"></a>4.3 IPv6(了解一下)</h2><h3 id="IPv6引入"><a href="#IPv6引入" class="headerlink" title="IPv6引入"></a>IPv6引入</h3><p>IPv4地址空间已经耗尽</p><ul><li>采用无类别编址CIDR，使得IP地址分配更加合理</li><li>采用NAT技术，使得IPv4地址可以重复使用</li><li>引入更大的地址空间，IPv6地址由128位组成，可以提供2^128个地址</li></ul><h3 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h3><p><img src="/../0_images/kinglyWay-network/4_6_IPv6%E9%A6%96%E9%83%A8.png" alt="alt text"></p><ul><li>版本：4位，表示IP协议的版本，IPv6的值为6</li><li>通信量类：8位，用来区分不同IPv6数据报的类别或优先级</li><li>流标签：20位，用来标识一条数据报流，用于QoS</li><li>有效载荷长度：16位，表示IPv6数据报的有效载荷长度，单位为字节</li><li>下一个首部：8位，表示IPv6数据报的下一个首部，用于标识IPv6数据报的协议类型</li><li>跳限制：8位，类似于IPv4的TTL，用于限制数据报的传输跳数</li><li>源地址：128位，表示IPv6数据报的源地址</li><li>目的地址：128位，表示IPv6数据报的目的地址</li></ul><h2 id="4-4-路由算法和路由协议"><a href="#4-4-路由算法和路由协议" class="headerlink" title="4.4 路由算法和路由协议"></a>4.4 路由算法和路由协议</h2><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p><strong>静态路由和动态路由</strong></p><ul><li>静态路由：由网络管理员手动配置，不会自动更新，适用于小型网络或网络拓扑变化不大的情况</li><li>动态路由：由路由器自动计算和更新，适用于大型网络或网络拓扑变化较大的情况<ul><li>可以分为两类：距离-向量路由算法和链路状态路由算法</li></ul></li></ul><p><strong>距离-向量路由算法</strong></p><ul><li>每个路由器维护一个路由表，记录到达每个目的地的最短路径</li><li>路由器会定期向<strong>相邻</strong>的路由器发送自己的路由表，相邻的路由器收到路由表后，会更新自己的路由表</li><li>路由器会根据路由表中的信息，选择到达目的地的最短路径</li></ul><p>注意：只会与相邻的路由器交换路由表，不会与所有的路由器交换路由表，这样可以减少网络流量，提高网络效率</p><p><strong>链路状态路由算法</strong></p><ul><li>每个路由器维护一个链路状态数据库，记录到达每个目的地的最短路径</li><li>路由器会定期向<strong>所有</strong>的路由器发送自己的链路状态信息，所有路由器收到链路状态信息后，会更新自己的链路状态数据库</li><li>路由器会根据链路状态数据库中的信息，选择到达目的地的最短路径</li></ul><p>注意：会与所有的路由器交换链路状态信息，这样可以保证路由器拥有最新的网络拓扑信息，提高路由的准确性</p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><ul><li>内部网关协议IGP：RIP、OSPF</li><li>外部网关协议EGP：BGP</li></ul><h3 id="路由信息协议RIP-Routing-Information-Protocol"><a href="#路由信息协议RIP-Routing-Information-Protocol" class="headerlink" title="路由信息协议RIP(Routing Information Protocol)"></a>路由信息协议RIP(Routing Information Protocol)</h3><p>基本介绍：</p><ul><li>每个路由器都要维护一个路由表，记录到达每个目的地的最短路径</li><li>RIP使用跳数(它认为最好的路由就是通过路由器数量最少的路径)作为度量值，跳数越小，路径越短</li><li>最大跳数为15，超过15跳的路由被认为是不可达的</li><li>路由表项的三个关键词：目的网络、距离、下一跳</li><li>RIP使用UDP协议，端口号为520</li></ul><p>特点：</p><ul><li>和谁交换信息：和相邻的路由器交换信息</li><li>交换什么信息：交换路由表的全部信息</li><li>多久交换一次：每隔30秒交换一次</li></ul><p>算法过程可以看一下书中的例子，这个不难理解</p><p><img src="/../0_images/kinglyWay-network/4_7_RIP%E6%94%B6%E6%95%9B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="alt text"></p><p>RIP的优缺点：</p><ul><li>优点：简单，易于实现</li><li>缺点：收敛速度慢，跳数限制为15，不适合大型网络</li><li>(好消息传递速度快，坏消息传递慢)</li></ul><h3 id="开放最短路径优先OSPF-Open-Shortest-Path-First"><a href="#开放最短路径优先OSPF-Open-Shortest-Path-First" class="headerlink" title="开放最短路径优先OSPF(Open Shortest Path First)"></a>开放最短路径优先OSPF(Open Shortest Path First)</h3><p>基本介绍：</p><ul><li>OSPF使用链路状态路由算法，每个路由器维护一个链路状态数据库，记录到达每个目的地的最短路径</li><li>OSPF允许对每条路径设计代价，可以不适用跳数作为度量值</li></ul><p>特点：</p><ul><li>OSPF使用洪范法，和所有的路由器交换链路状态信息</li><li>发送的信息是与本路由器<strong>相邻</strong>的路由器的链路状态信息</li><li>只有当链路状态发生变化时，才洪范发送链路状态信息</li><li>OSPF使用IP协议(网络层协议)，端口号为89</li></ul><p>OSPF的分组类型：</p><ul><li>问候分组： 用于发现和维护邻居关系</li><li>数据库描述分组：用于交换链路状态数据库中的信息</li><li>链路状态请求分组：用于请求邻居路由器的链路状态信息</li><li>链路状态更新分组：用于发送链路状态信息</li><li>链路状态确认分组：用于确认收到的链路状态信息</li></ul><p><img src="/../0_images/kinglyWay-network/4_8_OSFP%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="alt text"></p><h3 id="边界网关协议BGP-Border-Gateway-Protocol"><a href="#边界网关协议BGP-Border-Gateway-Protocol" class="headerlink" title="边界网关协议BGP(Border Gateway Protocol)"></a>边界网关协议BGP(Border Gateway Protocol)</h3><p>基本介绍：</p><ul><li>BGP是运行在AS之间的路由协议，用于在不同的AS(Autonomous System，自治系统)之间交换路由信息</li><li>BGP使用TCP协议，端口号为179</li><li>寻找一条能够到达目的地的最佳路径，而不是寻找一条最短路径</li></ul><p>BGP路由的选择：</p><ul><li>选择本地偏好度最高的路由</li><li>选择AS路径最短的路由</li><li>使用热土豆算法</li><li>选择BGP标识符最小的路由</li></ul><p>BGP的分组类型：</p><ul><li>打开分组：用于建立TCP连接</li><li>更新分组：用于交换路由信息</li><li>保活分组：用于周期性的证实邻站的连通性</li><li>通知报文：用于报告错误</li></ul><p><img src="/../0_images/kinglyWay-network/4_9_%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="alt text"></p><h2 id="4-5-IP多播-了解，看书吧"><a href="#4-5-IP多播-了解，看书吧" class="headerlink" title="4.5 IP多播(了解，看书吧)"></a>4.5 IP多播(了解，看书吧)</h2><h2 id="4-6-移动IP-了解，看书吧"><a href="#4-6-移动IP-了解，看书吧" class="headerlink" title="4.6 移动IP(了解，看书吧)"></a>4.6 移动IP(了解，看书吧)</h2><h2 id="4-7-网络层设备-了解，看书吧"><a href="#4-7-网络层设备-了解，看书吧" class="headerlink" title="4.7 网络层设备(了解，看书吧)"></a>4.7 网络层设备(了解，看书吧)</h2><h1 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h1><h2 id="5-1-传输层提供的服务"><a href="#5-1-传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h2><h3 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h3><ul><li>为应用进程之间提供端到端的通信<ul><li>网络层提供的IP地址完成了主机与主机之间的通信，而传输层提供的端口号则完成了应用进程之间的通信</li></ul></li><li>复用和分用</li><li>差错检测</li><li>提供面向连接和无连接的服务<ul><li>面向连接的服务：TCP</li><li>无连接的服务：UDP</li></ul></li></ul><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3><ul><li>传输层使用端口号来标识不同的应用进程</li><li>端口号是一个16位的无符号整数，范围是0-65535</li><li>熟知端口号：0-1023，用于系统进程</li><li>注册端口号：1024-49151，用于用户进程</li><li>动态或私有端口号：49152-65535，用于用户进程</li></ul><p><img src="/../0_images/kinglyWay-network/5_1_%E7%86%9F%E7%9F%A5%E5%BA%94%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="alt text"></p><p>套接字：</p><ul><li>套接字是传输层提供的一种抽象，用于表示一个通信端点</li><li>套接字由IP地址和端口号组成，用于标识一个通信端点</li><li>套接字(Socket) &#x3D; (IP地址:端口号)</li></ul><h2 id="5-2-用户数据报协议UDP-User-Datagram-Protocol"><a href="#5-2-用户数据报协议UDP-User-Datagram-Protocol" class="headerlink" title="5.2 用户数据报协议UDP(User Datagram Protocol)"></a>5.2 用户数据报协议UDP(User Datagram Protocol)</h2><h3 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h3><p>特点：</p><ul><li>UDP是无连接的，发送数据之前不需要建立连接</li><li>UDP首部开销小，只有8个字节（TCP有20个字节）</li><li>UDP不保证数据报的顺序，不保证数据报的完整性</li><li>UDP没有拥塞控制，因此网络之中的拥塞不会影响主机发送数据，这就需要某些实时的应用能够接受部分的数据丢失</li><li>UDP适用于实时通信，如视频会议、语音通信等</li><li>UDP支持一对一，一对多，多对一和多对多的通信方式（TCP不提供广播和多播的服务）</li></ul><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><ul><li>源端口：源端口号，占16位</li><li>目的端口：目的端口号，占16位</li><li>长度：UDP数据报的长度，占16位</li><li>检验和：用于检验UDP数据报的完整性，占16位</li></ul><p><img src="/../0_images/kinglyWay-network/5_2_UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="alt text"></p><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>这里要注意，UDP校验的时候会先在UDP数据报的头部加上12字节的伪首部，伪首部包含源IP地址、目的IP地址、协议号和UDP长度，用于计算校验和。</p><p>IP数据报只校验IP数据报的首部，而UDP校验的是整个UDP数据报，包括UDP首部和UDP数据。</p><p><img src="/../0_images/kinglyWay-network/5_3_UDP%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.png" alt="alt text"></p><p>具体的校验方法：看书吧</p><h2 id="5-3-传输控制协议TCP-Transmission-Control-Protocol"><a href="#5-3-传输控制协议TCP-Transmission-Control-Protocol" class="headerlink" title="5.3 传输控制协议TCP(Transmission Control Protocol)"></a>5.3 传输控制协议TCP(Transmission Control Protocol)</h2><p>在不可靠的IP层之上实现的可靠的数据传输协议；可靠，有序，无丢失，无重复</p><p>特点：</p><ul><li>TCP是面向连接的，发送数据之前需要建立连接(TCP连接是一条逻辑连接)</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li><li>TCP提供可靠的数据传输服务，保证传送的数据，无差错，无丢失，无重复，并且按序到达</li><li>TCP提供全双工通信，即通信的双方可以在任何时候发送数据(双方都会设有发送缓存和接收缓存)</li><li>TCP是面向字节流的，发送数据时，将数据(来自应用层的数据块)拆分成字节流，接收数据时，将字节流重新组合成数据</li></ul><h3 id="TCP数据报"><a href="#TCP数据报" class="headerlink" title="TCP数据报"></a>TCP数据报</h3><p><img src="/../0_images/kinglyWay-network/5_4_TCP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt="alt text"></p><ul><li>源端口：源端口号，占16位</li><li>目的端口：目的端口号，占16位</li><li>序号：占32位，用于标识从TCP发送端向TCP接收端发送的数据字节流，表示在这个报文段中的第一个数据字节</li><li>确认号：占32位，用于标识期望接收到的下一个报文段的序号，表示期望接收到的下一个报文段的第一个数据字节的序号</li><li>数据偏移：占4位，用于标识TCP报文段的数据部分起始处距离TCP报文段的起始处有多远(其实就是首部长度)</li><li>保留：占6位，保留位，目前未使用</li><li>紧急URG：占1位，当URG&#x3D;1时，表示紧急指针字段有效，表示该报文段中有紧急数据</li><li>确认ACK：占1位，当ACK&#x3D;1时，表示确认号字段有效，表示该报文段是确认报文</li><li>推送PSH：占1位，当PSH&#x3D;1时，表示接收方应该尽快将这个报文段交给应用层</li><li>复位RST：占1位，当RST&#x3D;1时，表示TCP连接出现严重错误，必须释放连接，重新建立连接</li><li>同步SYN：占1位，当SYN&#x3D;1时，表示这是一个连接请求报文段</li><li>终止FIN：占1位，当FIN&#x3D;1时，表示此报文段的发送方已经没有数据要发送了，要求释放连接</li><li>窗口：占16位，用于表示发送方愿意接收的字节数</li><li>检验和：占16位，用于检验TCP报文段的完整性(校验要包含TCP首部和TCP数据)</li><li>紧急指针：占16位，当URG&#x3D;1时，紧急指针字段有效，用于标识紧急数据在报文段中的位置</li><li>选项：占32位，用于提供一些可选的参数</li><li>填充：用于将TCP首部填充到4B的整数倍</li><li>数据：TCP报文段的数据部分</li></ul><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接的时候要解决以下问题：</p><ul><li>每一方都能够确认对方的存在</li><li>双方能够协商一些参数(如窗口大小等)</li><li>能够对一些运输实体资源进行分配</li></ul><p><strong>TCP连接的建立：三次握手</strong> </p><p>这里很重要，要仔细看</p><p><img src="/../0_images/kinglyWay-network/5_5_%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="alt text"><br><img src="/../0_images/kinglyWay-network/5_6_%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="alt text"></p><p><strong>TCP连接的释放：四次挥手</strong></p><p>这里很重要，要仔细看</p><p><img src="/../0_images/kinglyWay-network/5_7_%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="alt text"><br><img src="/../0_images/kinglyWay-network/5_8_%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="alt text"></p><p>TCP建立和释放连接的总结：</p><p>1.建立连接 3 步</p><ul><li>SYN&#x3D;1，seq&#x3D;x</li><li>SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1</li><li>ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</li></ul><p>2.释放连接 4 步</p><ul><li>FIN&#x3D;1，seq&#x3D;u</li><li>ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</li><li>FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;v+1</li><li>ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</li></ul><h3 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h3><p>1.序号</p><ul><li>TCP给发送的每个字节都编上一个序号用于标识本次传输的第一个字节</li></ul><p>2.ACK确认</p><ul><li>表示期待接收到的下一个字节的序号</li><li>TCP使用累积确认的方式，即确认序号之前的所有字节都已经收到</li></ul><p>3.重传</p><ul><li>超时重传：TCP会为每个发送的字节都设置一个超时计时器，如果在超时时间内没有收到ACK，则重传该字节</li><li>冗余ACK: 不好解释，举个例子，比如发送方发送1 2 3 4 5，但是2丢失了，那么接收方对 3 4 5三个字节都会发送ACK，表示期待接收到的下一个字节的序号是2，这样就会造成冗余ACK。当接收方收到3个冗余ACK时，就会直接重传丢失的字节，不会等到超时再重传，这个技术也被称为快速重传。</li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>这个就比较简单了，发送方与接收方相互商量窗口大小便可以，下面是书中的一个例子，看一下就明白</p><p><img src="/../0_images/kinglyWay-network/5_9_%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="alt text"></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制就是防止网络中的数据过多，导致网络拥塞，影响网络性能</p><p>发送方除了维护一个发送窗口之外，还需要维护一个拥塞窗口cwnd，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。</p><p>拥塞控制的方法：</p><ul><li>慢开始：一开始发送方以一个MSS的速率发送数据，然后每经过一个RTT，发送速率就翻倍，直到达到阈值cwnd，然后进入拥塞避免阶段</li><li>拥塞避免：拥塞避免阶段，发送方以一个MSS的速率发送数据，每经过一个RTT，发送速率就增加一个MSS，直到达到阈值cwnd，然后进入拥塞避免阶段</li><li>快重传：快重传是指接收方在收到一个冗余ACK时，会立即发送一个ACK，表示期待接收到的下一个字节的序号，这样发送方就可以立即重传丢失的字节，而不需要等到超时再重传</li><li>快恢复：快恢复是指当发送方收到一个冗余ACK时，会将拥塞窗口的大小设置为阈值cwnd的一半，然后进入拥塞避免阶段</li></ul><p>这个挺简单的，下面是数中的两个例子</p><p><img src="/../0_images/kinglyWay-network/5_10_%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-network/5_11_%E5%BF%AB%E6%81%A2%E5%A4%8D.png" alt="alt text"></p><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1-网络应用模型-看一看，了解"><a href="#6-1-网络应用模型-看一看，了解" class="headerlink" title="6.1 网络应用模型(看一看，了解)"></a>6.1 网络应用模型(看一看，了解)</h2><h3 id="客户-服务器模型-C-S模型"><a href="#客户-服务器模型-C-S模型" class="headerlink" title="客户&#x2F;服务器模型(C&#x2F;S模型)"></a>客户&#x2F;服务器模型(C&#x2F;S模型)</h3><ul><li>客户端(Client)：发起请求的一方</li><li>服务器(Server)：响应请求的一方</li></ul><p>工作流程：</p><ul><li>服务器处于接受请求的状态，等待客户端的请求</li><li>客户端发起请求，服务器响应请求</li><li>服务器处理完请求后，将结果返回给客户端</li></ul><p>特点：</p><ul><li>网络中计算机的地位不平，服务器可以限制用户权限</li><li>客户机相互之间不可以通信</li><li>可扩展性不佳</li></ul><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><ul><li>整个网络之中不再有固定的服务器，每个节点都可以既是客户端又是服务器</li><li>每个节点都具有下载、上传的功能，其权力和义务都大体相等</li><li>各个节点之间可以相互通信</li></ul><p><img src="/../0_images/kinglyWay-network/6_1_%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="alt text"></p><h2 id="6-2-域名系统DNS-Domain-Name-System-！！！"><a href="#6-2-域名系统DNS-Domain-Name-System-！！！" class="headerlink" title="6.2 域名系统DNS(Domain Name System)！！！"></a>6.2 域名系统DNS(Domain Name System)！！！</h2><p>采用客户&#x2F;服务器模式</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul><li>域名是由多个标号组成的，每个标号之间用点号分隔</li><li>标号只能由字母、数字和连字符组成，且不能以连字符开头或结尾</li><li>标号中的字母不区分大小写</li><li>域名最长为255个字符，每个标号不超过63个</li><li>域名由顶级域名(TLD)、二级域名、三级域名等组成</li><li>级别最低的在最左边</li></ul><p><img src="/../0_images/kinglyWay-network/6_2_%E5%9F%9F%E5%90%8D%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="alt text"></p><h3 id="域名空间"><a href="#域名空间" class="headerlink" title="域名空间"></a>域名空间</h3><p><img src="/../0_images/kinglyWay-network/6_3_%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="alt text"></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul><li>根域名服务器：负责管理最高层次的域名，所有的根服务器都知道所有的顶级域名服务器的域名和IP地址</li><li>顶级域名服务器：负责管理该顶级域名所注册的所有二级域名服务器</li><li>权限域名服务器：负责管理该权限域名下的所有主机</li><li>本地域名服务器：负责管理该本地网络中的所有主机</li></ul><p><img src="/../0_images/kinglyWay-network/6_4_DNS%E5%B1%82%E6%AC%A1.png" alt="alt text"></p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>递归查询和迭代查询</p><p>主机向本地服务器发送的查询请求都采用递归查询</p><ul><li>主机向本地服务器发送查询请求</li><li>本地域名服务器若知道相应的IP地址，则直接返回给主机</li><li>本地域名服务器若不知道相应的IP地址，会代替主机，继续发送请求，而不知主机直接发送</li></ul><p>本地服务器向根域名服务器发送的查询请求都采用递归查询和迭代查询</p><p><img src="/../0_images/kinglyWay-network/6_5_DNS%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="alt text"></p><p>下面这个例子一定要看！！！</p><p><img src="/../0_images/kinglyWay-network/6_6_DNS%E4%BE%8B%E5%AD%90.png" alt="alt text"></p><h2 id="6-3-文件传输协议FTP-File-Transfer-Protocol-看看书"><a href="#6-3-文件传输协议FTP-File-Transfer-Protocol-看看书" class="headerlink" title="6.3 文件传输协议FTP(File Transfer Protocol)(看看书)"></a>6.3 文件传输协议FTP(File Transfer Protocol)(看看书)</h2><p>采用客户&#x2F;服务器模式,采用TCP实现可靠传输</p><h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3><ul><li>控制连接：用于传输FTP命令和响应<ul><li>端口 21</li></ul></li><li>数据连接：用于传输文件数据<ul><li>端口 20</li><li>主动模式：FTP服务器主动向客户端发起连接(客户端连接21端口之后，启动一个随机端口供FTP服务器连接)</li><li>被动模式：FTP服务器被动地等待客户端连接(客户端连接21端口之后，FTP服务器启动一个随机端口供客户端连接)</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/6_7_FTP%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5.png" alt="alt text"></p><h2 id="6-4-电子邮件-看看书"><a href="#6-4-电子邮件-看看书" class="headerlink" title="6.4 电子邮件(看看书)"></a>6.4 电子邮件(看看书)</h2><p>注意</p><ul><li><p>用户代理：用户代理是用户与电子邮件系统的接口，用户通过用户代理发送和接收邮件</p></li><li><p>邮件服务器：邮件服务器是电子邮件系统的核心，负责存储和管理用户的邮件</p></li><li><p>邮件发送协议：SMTP</p></li><li><p>邮件接收协议：POP3、IMAP4</p></li><li><p>邮件格式和MIME</p><ul><li>MIME就是邮件扩展协议，用于传输非ASCII编码的邮件，发送的时候将非ASCII编码的邮件转换为ASCII编码的邮件，接收的时候将ASCII编码的邮件转换为非ASCII编码的邮件</li></ul></li></ul><p><img src="/../0_images/kinglyWay-network/6_8_%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="alt text"></p><p><img src="/../0_images/kinglyWay-network/6_9_MIME.png" alt="alt text"></p><h2 id="6-5-万维网WWW-World-Wide-Web"><a href="#6-5-万维网WWW-World-Wide-Web" class="headerlink" title="6.5 万维网WWW(World Wide Web)"></a>6.5 万维网WWW(World Wide Web)</h2><p>万维网是一个分布式、协作的、超媒体的信息系统</p><p>在这个空间之中一样有用的事物成为资源，这些资源通过统一资源定位符(URL)进行标识,通过超文本传输协议(HTTP)协议传送给使用者。</p><p>万维网的内核由三部分构成</p><ul><li>统一资源定位符(URL):用于标识万维网中的资源</li><li>超文本传输协议(HTTP):用于传输万维网中的资源</li><li>超文本标记语言(HTML):用于描述万维网中的资源</li></ul><p>URL的格式</p><ul><li>协议:&#x2F;&#x2F;主机名:端口号&#x2F;路径&#x2F;文件名</li><li>协议：如http、https、ftp等</li><li>主机名：如<a href="http://www.baidu.com/">www.baidu.com</a></li><li>端口号：如80</li><li>路径：如&#x2F;index.html</li><li>文件名：如index.html</li></ul><h3 id="超文本传输协议HTTP-HyperText-Transfer-Protocol"><a href="#超文本传输协议HTTP-HyperText-Transfer-Protocol" class="headerlink" title="超文本传输协议HTTP(HyperText Transfer Protocol)"></a>超文本传输协议HTTP(HyperText Transfer Protocol)</h3><p>HTTP操作过程：</p><ul><li>首先需要DNS解析URL中的主机名，得到对应的IP地址</li><li>服务器进程不断监听80端口，等待客户端的请求，当监听到连接请求后便与浏览器建立TCP连接</li><li>浏览器向服务器发送HTTP请求报文，获取某个web界面</li><li>服务器收到请求报文后，根据请求报文中的URL，找到对应的资源，并将资源发送给浏览器</li><li>浏览器收到资源后，根据资源类型进行解析，并显示在浏览器上</li><li>浏览器与服务器断开连接(TCP释放)</li></ul><p><img src="/../0_images/kinglyWay-network/6_10_%E4%B8%87%E7%BB%B4%E7%BD%91%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="alt text"></p><p>这个比较重要</p><p><img src="/../0_images/kinglyWay-network/6_11_%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="alt text"></p><p>HTTP特点：</p><ul><li>HTTP是无状态的，即服务器不保留客户端的信息(可以用cookies解决)</li><li>HTTP是面向连接的，即浏览器与服务器建立TCP连接后，才能进行通信</li><li>HTTP是媒体独立的，即浏览器可以接收任何类型的资源，服务器也可以发送任何类型的资源</li><li>HTTP是可扩展的，即可以增加新的请求方法、响应状态码等</li></ul><p>HTTP报文结构：</p><p>两类报文：</p><ul><li>请求报文：浏览器发送给服务器的报文</li><li>响应报文：服务器发送给浏览器的报文</li></ul><p><img src="/../0_images/kinglyWay-network/6_12_HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="alt text"></p><ul><li>开始行：在请求和响应报文之中分别称为 请求行或状态行 ，用于描述请求或响应的基本信息，最后的CR LF表示回车和换行</li><li>首部行：用来说明浏览器、服务器或者报文的一些属性，每行一个属性，最后以一个回车和换行来结束</li><li>实体体：用于存放请求或响应的具体数据，比如HTML、图片等</li></ul><p><img src="/../0_images/kinglyWay-network/6_13_HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="alt text"></p><p>HTTP请求方法：</p><ul><li>GET：请求获取URL所标识的资源</li><li>POST：请求服务器接收所描述的信息</li><li>HEAD：请求获取URL所标识资源的响应报文首部</li><li>PUT：请求服务器存储所描述的信息</li><li>DELETE：请求服务器删除所标识的资源</li><li>OPTIONS：请求查询服务器支持哪些方法</li></ul><p>HTTP状态码:</p><ul><li><strong>202 Accepted：请求已接受，但处理尚未完成</strong></li><li>204 No Content：请求已成功处理，但响应不包含内容</li><li>301 Moved Permanently：请求的资源已被永久移动到新位置</li><li>302 Found：请求的资源临时移动到新位置</li><li>304 Not Modified：请求的资源未修改，服务器返回此状态码时，不会返回响应实体</li><li><strong>400 Bad Request：请求无效，服务器无法理解请求的内容</strong></li><li>401 Unauthorized：请求需要身份验证</li><li>403 Forbidden：服务器拒绝请求</li><li><strong>404 Not Found：请求的资源不存在</strong></li><li>500 Internal Server Error：服务器内部错误</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应</li><li>503 Service Unavailable：服务器暂时无法处理请求</li><li>504 Gateway Timeout：服务器作为网关或代理，没有及时从上游服务器收到响应</li><li>505 HTTP Version Not Supported：服务器不支持请求的HTTP版本</li></ul><p>应用层协议小结：<br><img src="/../0_images/kinglyWay-network/6_14_%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%B0%8F%E7%BB%93.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 408学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王道 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式</title>
      <link href="/2025/04/13/DesignPattern/"/>
      <url>/2025/04/13/DesignPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C++设计模式"></a>C++设计模式</h1><p><strong>资料</strong><a href="https://blog.csdn.net/qq_52860170/article/details/142577985">https://blog.csdn.net/qq_52860170/article/details/142577985</a></p><h2 id="软件的设计原则"><a href="#软件的设计原则" class="headerlink" title="软件的设计原则"></a>软件的设计原则</h2><p>目的：为了提高软件系统的可维护性、可复用性，增强软件的可扩展性、灵活性</p><h3 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h3><p>软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能。</p><p>对扩展开放，对修改关闭</p><p>实现：接口和抽象类</p><h3 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h3><p>任何基类可以出现的地方，子类一定可以出现，通俗来说，子类可以扩展父类的功能，但不能改变父类原有的功能</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h3><p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象；对抽象编程，不对实现编程，降低了客户与实现模块间的耦合。</p><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h3><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><p>一个类应该有且仅有一个职责</p><p>比如：手机：拍照、摄影、游戏、GPS</p><p>拆分成多个类:</p><p>拍摄职责：照相机、摄影机</p><p>游戏：PSP</p><p>GPS：专业GPS导航</p><h2 id="高内聚、低耦合"><a href="#高内聚、低耦合" class="headerlink" title="高内聚、低耦合"></a>高内聚、低耦合</h2><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>只需要知道水果的名字则可得到相应的水果</p><p><img src="/../0_images/DesignPattern/1_%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><p><img src="/../0_images/DesignPattern/2_%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_%E8%A7%92%E8%89%B2.png" alt="alt text"></p><p>角色：</p><ul><li><p>Factory：工厂角色</p></li><li><p>Product：抽象产品角色</p></li><li><p>ConcreteProduct：具体产品角色</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的产品：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绘制圆形&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的产品：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绘制矩形&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类，静态的创建函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Shape* <span class="title">createShape</span><span class="params">(<span class="type">const</span> string&amp; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;Circle&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;Rectangle&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;无效的形状类型！&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Shape* circle = ShapeFactory::<span class="built_in">createShape</span>(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">        Shape* rectangle = ShapeFactory::<span class="built_in">createShape</span>(<span class="string">&quot;Rectangle&quot;</span>);</span><br><span class="line"></span><br><span class="line">        circle-&gt;<span class="built_in">draw</span>();      <span class="comment">// 输出：绘制圆形</span></span><br><span class="line">        rectangle-&gt;<span class="built_in">draw</span>();   <span class="comment">// 输出：绘制矩形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> circle;</span><br><span class="line">        <span class="keyword">delete</span> rectangle;</span><br><span class="line"></span><br><span class="line">        Shape* unknown = ShapeFactory::<span class="built_in">createShape</span>(<span class="string">&quot;Triangle&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">const</span> exception&amp; e)&#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式虽然很好用，但是其违背了 <strong>开闭原则</strong> 当需要添加一个产品的时候，需要修改createShape部分的代码，因此便引入了工厂模式。</p><p>PPT之中一个例子<br><img src="/../0_images/DesignPattern/3_%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><img src="/../0_images/DesignPattern/4_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><p>通过 将对象的实例化推迟到子类 来实现：每个具体工厂类只需要关注自己负责的产品创建，系统的扩展通过新增工厂-产品对实现，而不是修改现有代码。这种设计更符合面向对象的设计原则，特别适合需要支持多平台、多系列产品等场景。</p><ul><li><p>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品</p></li><li><p>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</p></li><li><p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</p></li><li><p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的产品：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绘制圆形&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的产品：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绘制矩形&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加产品： 三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绘制三角形&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shape* <span class="title">createShape</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeFactory</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span>: <span class="keyword">public</span> ShapeFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span>: <span class="keyword">public</span> ShapeFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增 三角形工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleFactory</span>: <span class="keyword">public</span> ShapeFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Triangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ShapeFactory* circleFactory = <span class="keyword">new</span> <span class="built_in">CircleFactory</span>();</span><br><span class="line">    Shape* circle = circleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    </span><br><span class="line">    ShapeFactory* rectangleFactory = <span class="keyword">new</span> <span class="built_in">RectangleFactory</span>();</span><br><span class="line">    Shape* rectangle = rectangleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line"></span><br><span class="line">    circle-&gt;<span class="built_in">draw</span>();      <span class="comment">// 输出：绘制圆形</span></span><br><span class="line">    rectangle-&gt;<span class="built_in">draw</span>();   <span class="comment">// 输出：绘制矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增：</span></span><br><span class="line">    ShapeFactory* triangleFactory = <span class="keyword">new</span> <span class="built_in">TriangleFactory</span>();</span><br><span class="line">    Shape* triangle = triangleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    triangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> circle;</span><br><span class="line">    <span class="keyword">delete</span> rectangle;</span><br><span class="line">    <span class="keyword">delete</span> circleFactory;</span><br><span class="line">    <span class="keyword">delete</span> rectangleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> triangle;</span><br><span class="line">    <span class="keyword">delete</span> triangleFactory;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工程模式"><a href="#抽象工程模式" class="headerlink" title="抽象工程模式"></a>抽象工程模式</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类</p><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式</p><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p><ul><li><p>抽象工厂：提供了创建产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品</p></li><li><p>具体工厂：实现了抽象工厂中的多个抽象方法，完成具体产品的创建</p></li><li><p>抽象产品：定义了产品的规范，描述了产品的主要特征和功能，抽象工厂模式有多个抽象产品</p></li><li><p>具体产品：实现了抽象产品所定义的接口，由具体工厂来创建，它具体工厂是多对一关系</p></li></ul><p><img src="/../0_images/DesignPattern/5_%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 抽象产品接口 -------------------------</span></span><br><span class="line"><span class="comment">// 按钮抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本框抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> string&amp; text)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TextBox</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开关抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">toggle</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Switch</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 具体产品实现 -------------------------</span></span><br><span class="line"><span class="comment">// 现代风格组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernButton</span>: <span class="keyword">public</span> Button&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;渲染现代风格按钮 [▣ Minimal]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> string&amp; text)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现代风格文本框输入: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot; (无边框)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernSwitch</span> : <span class="keyword">public</span> Switch &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">toggle</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;切换现代风格开关 ●━━━━●&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复古风格组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetroButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;渲染复古风格按钮 [▣ Beveled]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetroTextBox</span> : <span class="keyword">public</span> TextBox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> string&amp; text)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;复古风格文本框输入: \&quot;&quot;</span> &lt;&lt; text &lt;&lt; <span class="string">&quot;\&quot; (像素字体)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetroSwitch</span> : <span class="keyword">public</span> Switch &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">toggle</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;切换复古开关 ◈━━━◈&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 抽象工厂接口 -------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UIFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;Switch&gt; <span class="title">createSwitch</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">UIFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 具体工厂实现 -------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernUIFactory</span> : <span class="keyword">public</span> UIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ModernButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ModernTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;Switch&gt; <span class="title">createSwitch</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;ModernSwitch&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetroUIFactory</span> : <span class="keyword">public</span> UIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;RetroButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;TextBox&gt; <span class="title">createTextBox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;RetroTextBox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;Switch&gt; <span class="title">createSwitch</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;RetroSwitch&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 客户端代码 -------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createUI</span><span class="params">(<span class="type">const</span> unique_ptr&lt;UIFactory&gt;&amp; factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> button = factory-&gt;<span class="built_in">createButton</span>();</span><br><span class="line">    <span class="keyword">auto</span> textbox = factory-&gt;<span class="built_in">createTextBox</span>();</span><br><span class="line">    <span class="keyword">auto</span> switchCtrl = factory-&gt;<span class="built_in">createSwitch</span>();</span><br><span class="line"></span><br><span class="line">    button-&gt;<span class="built_in">render</span>();</span><br><span class="line">    textbox-&gt;<span class="built_in">input</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    switchCtrl-&gt;<span class="built_in">toggle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=== 现代风格 UI ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">createUI</span>(<span class="built_in">make_unique</span>&lt;ModernUIFactory&gt;());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n=== 复古风格 UI ===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">createUI</span>(<span class="built_in">make_unique</span>&lt;RetroUIFactory&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种工厂模式对比表</p><table><thead><tr><th>特性</th><th>简单工厂模式</th><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td>创建目标</td><td>单一产品</td><td>单一产品</td><td>产品家族（多个关联产品）</td></tr><tr><td>扩展维度</td><td>垂直扩展（产品类型）</td><td>垂直扩展（产品类型）</td><td>水平扩展（产品家族）</td></tr><tr><td>开闭原则</td><td>违反</td><td>支持产品扩展</td><td>支持产品族扩展</td></tr><tr><td>工厂类数量</td><td>1个全能工厂</td><td>N个工厂对应N个产品</td><td>N个工厂对应N个产品族</td></tr><tr><td>适用场景</td><td>简单对象创建</td><td>单一产品扩展</td><td>多系列关联对象创建</td></tr></tbody></table><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p><p><img src="/../0_images/DesignPattern/6_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>; <span class="comment">// 私有构造函数</span></span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>; <span class="comment">// 私有析构函数（可选）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除拷贝和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 线程安全且自动析构</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;testFunction&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">getInstance</span>().<span class="built_in">testFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器-buider-模式"><a href="#生成器-buider-模式" class="headerlink" title="生成器(buider)模式"></a>生成器(buider)模式</h3><p>将一个复杂对象的构建与分离分开表示，使得同样的构建过程可以创建不同的表示</p><ul><li><p>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于: 某个对象的构建过程复杂的情况。</p></li><li><p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象，相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p></li><li><p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p></li></ul><p><strong>结构</strong></p><ul><li><p>抽象建造者类：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体对象部件的创建。</p></li><li><p>具体建造者类：实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p></li><li><p>产品类：要创建的复杂对象</p></li><li><p>指挥者类：调用具体的建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建</p></li></ul><p><img src="/../0_images/DesignPattern/7_%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类：Computer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_cpu;</span><br><span class="line">    string m_memory;</span><br><span class="line">    string m_hardDisk;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCPU</span><span class="params">(<span class="type">const</span> string&amp; cpu)</span></span>&#123; m_cpu = cpu;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMemory</span><span class="params">(<span class="type">const</span> string&amp; memory)</span> </span>&#123; m_memory = memory; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHardDisk</span><span class="params">(<span class="type">const</span> string&amp; hardDisk)</span> </span>&#123; m_hardDisk = hardDisk; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Computer Configuration:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CPU: &quot;</span> &lt;&lt; m_cpu &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Memory: &quot;</span> &lt;&lt; m_memory &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hard Disk: &quot;</span> &lt;&lt; m_hardDisk &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Computer* <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ComputerBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  具体建造者：高端配置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HighEndComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Computer* m_computer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HighEndComputerBuilder</span>() : <span class="built_in">m_computer</span>(<span class="keyword">new</span> <span class="built_in">Computer</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setCPU</span>(<span class="string">&quot;Intel Core i9-12900K&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setMemory</span>(<span class="string">&quot;64GB DDR5 4800MHz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setHardDisk</span>(<span class="string">&quot;2TB Samsung 980 Pro NVMe SSD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Computer* <span class="title">getResult</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HighEndComputerBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：办公配置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OfficeComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Computer* m_computer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OfficeComputerBuilder</span>() : <span class="built_in">m_computer</span>(<span class="keyword">new</span> <span class="built_in">Computer</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setCPU</span>(<span class="string">&quot;Intel Core i5-12400&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setMemory</span>(<span class="string">&quot;16GB DDR4 3200MHz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer-&gt;<span class="built_in">setHardDisk</span>(<span class="string">&quot;512GB Crucial P2 NVMe SSD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Computer* <span class="title">getResult</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">OfficeComputerBuilder</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(ComputerBuilder* builder)</span></span>&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">buildCPU</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildMemory</span>();</span><br><span class="line">        builder-&gt;<span class="built_in">buildHardDisk</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Director director;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建高端电脑</span></span><br><span class="line">    HighEndComputerBuilder highEndBuilder;</span><br><span class="line">    director.<span class="built_in">construct</span>(&amp;highEndBuilder);</span><br><span class="line">    Computer* gamingPC = highEndBuilder.<span class="built_in">getResult</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;High-end Gaming PC:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    gamingPC-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建办公电脑</span></span><br><span class="line">    OfficeComputerBuilder officeBuilder;</span><br><span class="line">    director.<span class="built_in">construct</span>(&amp;officeBuilder);</span><br><span class="line">    Computer* officePC = officeBuilder.<span class="built_in">getResult</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Office PC:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    officePC-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>描述如何将类和对象按某种布局组成更大的结构</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理以控制对该对象的访问</p><ul><li><p>远程（Remote）代理：为一个对象在不同地址空间提供局部代表</p></li><li><p>虚拟（Virtual）代理：在需要创建开销很大对象时缓存对象信息</p></li><li><p>保护（Protection）代理：控制对原始对象的访问</p></li><li><p>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，例如记录访问的流量和次数等</p></li></ul><p>结构：</p><ul><li><p>抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</p></li><li><p>真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</p></li><li><p>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制、扩展真实主图的功能</p></li></ul><p><img src="/../0_images/DesignPattern/8_%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><p>样例：</p><p>如果对象是一个大图片,需要花费很长时间才能显示出来，此时需要做个图片Proxy来代替真正的图片</p><p>如果对象在某远端服务器上,直接操作这个对象因为网络速度原因可能比较慢，那我们可以先用Proxy来代替那个对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Image</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span>: <span class="keyword">public</span> Image&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string filename;</span><br><span class="line">    <span class="comment">// 从磁盘之中加载图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loading image: &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot; from disk&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealImage</span>(<span class="type">const</span> string&amp; filename):<span class="built_in">filename</span>(filename)&#123;</span><br><span class="line">        <span class="built_in">loadFromDisk</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Displaying image: &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImage</span> :<span class="keyword">public</span> Image&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealImage* realImage = <span class="literal">nullptr</span>;</span><br><span class="line">    string filename;</span><br><span class="line">    <span class="type">bool</span> accessAllowed = <span class="literal">true</span>; <span class="comment">// 简单的访问控制标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkAccess</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以添加更复杂的访问控制逻辑</span></span><br><span class="line">        <span class="keyword">return</span> accessAllowed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Logged access to image: &quot;</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProxyImage</span>(<span class="type">const</span> string&amp; filename) : <span class="built_in">filename</span>(filename) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">checkAccess</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Access denied for image: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> <span class="built_in">RealImage</span>(filename); <span class="comment">// 延迟初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        realImage-&gt;<span class="built_in">display</span>();</span><br><span class="line">        <span class="built_in">logAccess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ProxyImage</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> realImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Image* image1 = <span class="keyword">new</span> <span class="built_in">ProxyImage</span>(<span class="string">&quot;photo1.jpg&quot;</span>);</span><br><span class="line">    Image* image2 = <span class="keyword">new</span> <span class="built_in">ProxyImage</span>(<span class="string">&quot;photo2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次访问会加载图片</span></span><br><span class="line">    image1-&gt;<span class="built_in">display</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次访问直接显示（已加载）</span></span><br><span class="line">    image1-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    image2-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> image1;</span><br><span class="line">    <span class="keyword">delete</span> image2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口换成客户希望的另一个接口，使得原本由于接口不兼容而不能在一起工作那些类能一起工作</p><p>分类：</p><ul><li><p>类适配器模式（耦合更高，应用较少）</p></li><li><p>对象适配器模式</p></li></ul><p>结构：</p><ul><li><p>目标接口：当前系统业务所期待的接口，它可以是抽象类或者接口</p></li><li><p>适配者类：它是被访问和适配的现存主件库中的组件接口</p></li><li><p>适配器类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按照目标接口的格式访问适配者</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口（Target Interface） - 客户端期望的充电器规格</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Charger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">charge</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Charger</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者（Adaptee） - 已存在的欧洲插头实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EuroPlug</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">specificCharge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;⚡ 使用欧洲插头充电 (220V)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器（Adapter） - 将欧洲插头适配到标准充电器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EuroChargerAdapter</span> : <span class="keyword">public</span> Charger&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EuroPlug* euroPlug_;  <span class="comment">// 持有被适配对象的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EuroChargerAdapter</span>(EuroPlug* plug)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;euroPlug_ = plug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">charge</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(euroPlug_) &#123;</span><br><span class="line">            <span class="comment">//使用转接口之后，就可以用欧洲的插头了</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;🔌 使用电源适配器转换&quot;</span> &lt;&lt; endl;</span><br><span class="line">            euroPlug_-&gt;<span class="built_in">specificCharge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建被适配的欧洲插头</span></span><br><span class="line">    EuroPlug euroPlug;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建适配器并将欧洲插头接入</span></span><br><span class="line">    Charger* charger = <span class="keyword">new</span> <span class="built_in">EuroChargerAdapter</span>(&amp;euroPlug);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用标准接口充电</span></span><br><span class="line">    charger-&gt;<span class="built_in">charge</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> charger;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>指在不改变现有对象结构的情况下，动态的给该对象增加一些职责（增加额外功能）的模式</p><p>例子：快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p><img src="/../0_images/DesignPattern/9_%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Beverage</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span>: <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CondimentDecorator</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Beverage* beverage;  <span class="comment">// 被装饰的对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CondimentDecorator</span>(Beverage* b) : <span class="built_in">beverage</span>(b) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CondimentDecorator</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者：摩卡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mocha</span> : <span class="keyword">public</span> CondimentDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mocha</span>(Beverage* b) : <span class="built_in">CondimentDecorator</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">cost</span>() + <span class="number">0.20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">description</span>() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者：牛奶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> : <span class="keyword">public</span> CondimentDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Milk</span>(Beverage* b) : <span class="built_in">CondimentDecorator</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">cost</span>() + <span class="number">0.50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">description</span>() + <span class="string">&quot;, Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建基础饮料</span></span><br><span class="line">    Beverage* espresso = <span class="keyword">new</span> <span class="built_in">Espresso</span>();</span><br><span class="line">    cout &lt;&lt; espresso-&gt;<span class="built_in">description</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot; $&quot;</span> &lt;&lt; espresso-&gt;<span class="built_in">cost</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用装饰者添加配料</span></span><br><span class="line">    Beverage* espressoWithMocha = <span class="keyword">new</span> <span class="built_in">Mocha</span>(espresso);</span><br><span class="line">    Beverage* espressoWithMochaMilk = <span class="keyword">new</span> <span class="built_in">Milk</span>(espressoWithMocha);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; espressoWithMochaMilk-&gt;<span class="built_in">description</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot; $&quot;</span> &lt;&lt; espressoWithMochaMilk-&gt;<span class="built_in">cost</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：装饰者会负责删除被装饰对象</span></span><br><span class="line">    <span class="keyword">delete</span> espressoWithMochaMilk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>​ 将抽象和实现分离，使它们可以独立变化。它是组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p><p><img src="/../0_images/DesignPattern/10_%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><p>结构：</p><ul><li><p>抽象化角色：定义抽象类，并包含一个对实现化角色的引用</p></li><li><p>扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</p></li><li><p>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用</p></li><li><p>具体实现化角色：给出实现化角色接口的具体实现</p></li></ul><p><img src="/../0_images/DesignPattern/11_%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawAPI</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">const</span> string&amp; shape)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DrawAPI</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现：使用OpenGL绘图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLAPI</span>:<span class="keyword">public</span> DrawAPI&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">const</span> string&amp; shape)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;OpenGL绘制: &quot;</span>&lt;&lt;shape&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现：使用DirectX绘图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectXAPI</span>: <span class="keyword">public</span> DrawAPI&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">const</span> string&amp; shape)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DirectX绘制: &quot;</span>&lt;&lt;shape&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象部分：图形基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    unique_ptr&lt;DrawAPI&gt; drawAPI;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(DrawAPI * api):<span class="built_in">drawAPI</span>(api)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:<span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string myShape;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(string shape,DrawAPI * api):<span class="built_in">Shape</span>(api),<span class="built_in">myShape</span>(shape)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        drawAPI-&gt;<span class="built_in">draw</span>(<span class="keyword">this</span>-&gt;myShape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string myShape;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(string shape,DrawAPI * api):<span class="built_in">Shape</span>(api),<span class="built_in">myShape</span>(shape)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        drawAPI-&gt;<span class="built_in">draw</span>(<span class="keyword">this</span>-&gt;myShape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用OpenGL绘制圆形</span></span><br><span class="line">    unique_ptr&lt;Shape&gt; circle = <span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="string">&quot;圆形&quot;</span>, <span class="keyword">new</span> <span class="built_in">OpenGLAPI</span>());</span><br><span class="line">    <span class="comment">// 使用DirectX绘制矩形</span></span><br><span class="line">    unique_ptr&lt;Shape&gt; rect = <span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="string">&quot;矩形&quot;</span>, <span class="keyword">new</span> <span class="built_in">DirectXAPI</span>());</span><br><span class="line">    </span><br><span class="line">    circle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    rect-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试其他组合</span></span><br><span class="line">    Shape* openglRect = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="string">&quot;矩形&quot;</span>, <span class="keyword">new</span> <span class="built_in">OpenGLAPI</span>());</span><br><span class="line">    Shape* directxCircle = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="string">&quot;圆形&quot;</span>, <span class="keyword">new</span> <span class="built_in">DirectXAPI</span>());</span><br><span class="line">    </span><br><span class="line">    openglRect-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    directxCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> openglRect;</span><br><span class="line">    <span class="keyword">delete</span> directxCircle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><img src="/../0_images/DesignPattern/12_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><p>结构：</p><ul><li><p>外观角色：为多个子系统对外提供一个共同的接口</p></li><li><p>子系统角色：实现系统的部分功能，客户可以通过外观角色访问它</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统类：音频解码器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioDecoder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decodeAudio</span><span class="params">(<span class="type">const</span> string&amp; file)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;解码音频: &quot;</span> &lt;&lt; file &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统类：视频解码器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoDecoder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decodeVideo</span><span class="params">(<span class="type">const</span> string&amp; file)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;解码视频: &quot;</span> &lt;&lt; file &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子系统类：文件加载器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLoader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">load</span><span class="params">(<span class="type">const</span> string&amp; path)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加载文件: &quot;</span> &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> path.<span class="built_in">substr</span>(path.<span class="built_in">find_last_of</span>(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外观类：封装多媒体播放的复杂操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlaybackManager</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FileLoader    fileLoader;</span><br><span class="line">    AudioDecoder  audioDecoder;</span><br><span class="line">    VideoDecoder  videoDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">const</span> string&amp; filePath)</span> </span>&#123;</span><br><span class="line">        string fileName = fileLoader.<span class="built_in">load</span>(filePath);</span><br><span class="line">        audioDecoder.<span class="built_in">decodeAudio</span>(fileName);</span><br><span class="line">        videoDecoder.<span class="built_in">decodeVideo</span>(fileName);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;开始播放 &quot;</span> &lt;&lt; fileName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PlaybackManager player;</span><br><span class="line">    player.<span class="built_in">play</span>(<span class="string">&quot;/media/movie.mp4&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>部分整体模式，是用于把一组相似的对象当做一个单一的对象，组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，她创建了对象组的树形结构。</p><p><img src="/../0_images/DesignPattern/13_%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><p>结构：</p><ul><li><p>抽象根节点：定义系统各层次对象共有方法和属性，可以预先定义一些默认行为和属性</p></li><li><p>树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构</p></li><li><p>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点：文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> string&amp; name,<span class="type">size_t</span> size):<span class="built_in">name_</span>(name),<span class="built_in">size_</span>(size)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">&#x27;\t&#x27;</span>) &lt;&lt; <span class="string">&quot;📄 &quot;</span> &lt;&lt; name_ </span><br><span class="line">            &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; size_ &lt;&lt; <span class="string">&quot; bytes)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合节点：目录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span>:<span class="keyword">public</span> FileSystemComponent&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;</span><br><span class="line">    vector&lt;shared_ptr&lt;FileSystemComponent&gt;&gt; children_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addComponent</span><span class="params">(shared_ptr&lt;FileSystemComponent&gt; component)</span></span>&#123;</span><br><span class="line">        children_.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeComponent</span><span class="params">(shared_ptr&lt;FileSystemComponent&gt; component)</span></span>&#123;</span><br><span class="line">        children_.<span class="built_in">erase</span>(</span><br><span class="line">            <span class="built_in">remove</span>(children_.<span class="built_in">begin</span>(), children_.<span class="built_in">end</span>(), component),</span><br><span class="line">            children_.<span class="built_in">end</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">&#x27;\t&#x27;</span>) &lt;&lt; <span class="string">&quot;📁 &quot;</span> &lt;&lt; name_ </span><br><span class="line">            &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; <span class="built_in">getSize</span>() &lt;&lt; <span class="string">&quot; bytes]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : children_) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">display</span>(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : children_) &#123;</span><br><span class="line">            total += child-&gt;<span class="built_in">getSize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">auto</span> file1 = <span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;document.txt&quot;</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="keyword">auto</span> file2 = <span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;image.jpg&quot;</span>, <span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">auto</span> file3 = <span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;notes.md&quot;</span>, <span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子目录</span></span><br><span class="line">    <span class="keyword">auto</span> subdir = <span class="built_in">make_shared</span>&lt;Directory&gt;(<span class="string">&quot;Downloads&quot;</span>);</span><br><span class="line">    subdir-&gt;<span class="built_in">addComponent</span>(file2);</span><br><span class="line">    subdir-&gt;<span class="built_in">addComponent</span>(file3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根目录</span></span><br><span class="line">    <span class="keyword">auto</span> root = <span class="built_in">make_shared</span>&lt;Directory&gt;(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line">    root-&gt;<span class="built_in">addComponent</span>(file1);</span><br><span class="line">    root-&gt;<span class="built_in">addComponent</span>(subdir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加另一个文件到根目录</span></span><br><span class="line">    root-&gt;<span class="built_in">addComponent</span>(<span class="built_in">make_shared</span>&lt;File&gt;(<span class="string">&quot;backup.zip&quot;</span>, <span class="number">4200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示整个结构</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File System Structure:\n&quot;</span>;</span><br><span class="line">    root-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nTotal size of root: &quot;</span> </span><br><span class="line">            &lt;&lt; root-&gt;<span class="built_in">getSize</span>() &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>内部状态。不会随着环境的改变而改变的可共享部分</p><p>外部状态。随着环境的改变而改变的不可共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p><p>引例：</p><p><img src="/../0_images/DesignPattern/14_%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元对象：包含树木的固有属性（内部状态）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeType</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name_;   <span class="comment">// 内部状态</span></span><br><span class="line">    string color_;  <span class="comment">// 内部状态</span></span><br><span class="line">    string texture_; <span class="comment">// 内部状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeType</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; color, <span class="type">const</span> string&amp; texture)</span><br><span class="line">        : <span class="built_in">name_</span>(name), <span class="built_in">color_</span>(color), <span class="built_in">texture_</span>(texture) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> age)</span> <span class="type">const</span> </span>&#123; <span class="comment">// 外部状态作为参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;绘制 &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot; 在 (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;)，颜色：&quot;</span> &lt;&lt; color_ </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;，纹理：&quot;</span> &lt;&lt; texture_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;年\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string,TreeType&gt; treeTypes_;</span><br><span class="line">    <span class="comment">// 生成唯一键</span></span><br><span class="line">    <span class="function">string <span class="title">makeKey</span><span class="params">(<span class="type">const</span> string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> string&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> string&amp; texture)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;_&quot;</span> + color + <span class="string">&quot;_&quot;</span> + texture;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> TreeType&amp; <span class="title">getTreeType</span><span class="params">(<span class="type">const</span> string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> string&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> string&amp; texture)</span> </span>&#123;</span><br><span class="line">        string key = <span class="built_in">makeKey</span>(name, color, texture);</span><br><span class="line">        <span class="comment">// 如果不存在则创建新类型</span></span><br><span class="line">        <span class="keyword">if</span> (treeTypes_.<span class="built_in">find</span>(key) == treeTypes_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;创建新的树木类型: &quot;</span> &lt;&lt; key &lt;&lt; endl;</span><br><span class="line">            treeTypes_.<span class="built_in">emplace</span>(key, <span class="built_in">TreeType</span>(name, color, texture));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeTypes_.<span class="built_in">at</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含外部状态的树木对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;         <span class="comment">// 外部状态</span></span><br><span class="line">    <span class="type">int</span> y_;         <span class="comment">// 外部状态</span></span><br><span class="line">    <span class="type">int</span> age_;       <span class="comment">// 外部状态</span></span><br><span class="line">    <span class="type">const</span> TreeType&amp; type_; <span class="comment">// 指向享元的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> age, <span class="type">const</span> TreeType&amp; type)</span><br><span class="line">        : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">age_</span>(age), <span class="built_in">type_</span>(type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        type_.<span class="built_in">draw</span>(x_, y_, age_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 森林包含多个树木</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Forest</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Tree&gt; trees_;</span><br><span class="line">    TreeFactory factory_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plantTree</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> age,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> string&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> string&amp; texture)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> TreeType&amp; type = factory_.<span class="built_in">getTreeType</span>(name, color, texture);</span><br><span class="line">        trees_.<span class="built_in">emplace_back</span>(x, y, age, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tree : trees_) &#123;</span><br><span class="line">            tree.<span class="built_in">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Forest forest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 种植不同类型的树</span></span><br><span class="line">    forest.<span class="built_in">plantTree</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="string">&quot;松树&quot;</span>, <span class="string">&quot;深绿&quot;</span>, <span class="string">&quot;针叶纹理&quot;</span>);</span><br><span class="line">    forest.<span class="built_in">plantTree</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">&quot;橡树&quot;</span>, <span class="string">&quot;浅绿&quot;</span>, <span class="string">&quot;宽叶纹理&quot;</span>);</span><br><span class="line">    forest.<span class="built_in">plantTree</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="string">&quot;松树&quot;</span>, <span class="string">&quot;深绿&quot;</span>, <span class="string">&quot;针叶纹理&quot;</span>); <span class="comment">// 复用已有类型</span></span><br><span class="line">    forest.<span class="built_in">plantTree</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="string">&quot;白桦&quot;</span>, <span class="string">&quot;白色&quot;</span>, <span class="string">&quot;条纹纹理&quot;</span>);</span><br><span class="line">    forest.<span class="built_in">plantTree</span>(<span class="number">9</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">&quot;橡树&quot;</span>, <span class="string">&quot;浅绿&quot;</span>, <span class="string">&quot;宽叶纹理&quot;</span>); <span class="comment">// 复用已有类型</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n开始绘制森林：\n&quot;</span>;</span><br><span class="line">    forest.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法完成的任务，涉及算法与对象之间职责的分配</p><ul><li><p>类行为型模式（继承实现）</p></li><li><p>对象行为型模式（组合或聚合实现）（满足合成复用原则，灵活性高）</p></li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><img src="/../0_images/DesignPattern/15_%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><p>​ 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重定义该算法的某些特定步骤</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepareBeverage</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">boilWater</span>();</span><br><span class="line">        <span class="built_in">brew</span>();</span><br><span class="line">        <span class="built_in">pourInCup</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">customerWantsCondiments</span>()) &#123; <span class="comment">// 钩子方法</span></span><br><span class="line">            <span class="built_in">addCondiments</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 具体方法（已实现）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Boiling water&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pouring into cup&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法（需要子类实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法（可选重写）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认添加调料</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体子类：咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span>:<span class="keyword">public</span> Beverage&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Brewing coffee grounds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding sugar and milk&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写钩子方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">customerWantsCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> choice;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Would you like milk and sugar with your coffee? (y/n) &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; choice;</span><br><span class="line">        <span class="keyword">return</span> choice == <span class="string">&#x27;y&#x27;</span> || choice == <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体子类：茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Steeping the tea&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding lemon&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不重写钩子方法，保持默认添加调料</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Making coffee:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Coffee coffee;</span><br><span class="line">    coffee.<span class="built_in">prepareBeverage</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nMaking tea:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Tea tea;</span><br><span class="line">    tea.<span class="built_in">prepareBeverage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>​该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响到使用算法的用户，策略模式属于对象行为模式，通过对算法进行封装，把使用算法的责任和算法是实现分割开来，并委派给不同对象对这些算法进行管理</p><p>结构:</p><ul><li><p>抽象策略类：通常由一个接口或抽象类来实现，此角色给出所有具体策略类所需的接口</p></li><li><p>具体策略类：实现了抽象策略类所定义的接口，提供具体的算法实现或行为</p></li><li><p>环境类：持有一个策略类的引用，最终给客户端调用</p></li></ul><p>策略模式引例</p><p><img src="/../0_images/DesignPattern/16_%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略接口：支付方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略：信用卡支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span>:<span class="keyword">public</span> PaymentStrategy&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;使用信用卡支付：&quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt;endl;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略：支付宝支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayPayment</span>:<span class="keyword">public</span> PaymentStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;使用支付宝支付：&quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略：微信支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeChatPayment</span>:<span class="keyword">public</span> PaymentStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;使用微信支付：&quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类：订单</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;PaymentStrategy&gt; thisPaymentStrategy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPaymentStrategy</span><span class="params">(unique_ptr&lt;PaymentStrategy&gt; strategy)</span></span>&#123;</span><br><span class="line">        thisPaymentStrategy = <span class="built_in">move</span>(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkout</span><span class="params">(<span class="type">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thisPaymentStrategy) &#123;</span><br><span class="line">            thisPaymentStrategy-&gt;<span class="built_in">pay</span>(amount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;错误：未选择支付方式！\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Order order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信用卡支付</span></span><br><span class="line">    order.<span class="built_in">setPaymentStrategy</span>(<span class="built_in">make_unique</span>&lt;CreditCardPayment&gt;());</span><br><span class="line">    order.<span class="built_in">checkout</span>(<span class="number">100.50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切换为支付宝支付</span></span><br><span class="line">    order.<span class="built_in">setPaymentStrategy</span>(std::<span class="built_in">make_unique</span>&lt;AlipayPayment&gt;());</span><br><span class="line">    order.<span class="built_in">checkout</span>(<span class="number">200.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切换为微信支付</span></span><br><span class="line">    order.<span class="built_in">setPaymentStrategy</span>(std::<span class="built_in">make_unique</span>&lt;WeChatPayment&gt;());</span><br><span class="line">    order.<span class="built_in">checkout</span>(<span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开，这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加和管理</p><p>结构：</p><ul><li><p>抽象命令类角色：定义命令的接口，声明执行的方法</p></li><li><p>具体命令角色：具体的命令，实现命令接口；通常会持有接受者，并调用接受者的功能来完成命令要执行的操作</p></li><li><p>实现者&#x2F;接受者角色：接受者，真正执行命令的对象，任何类都可成为一个接收者，只要它能够实现命令要求实现的相应的功能</p></li><li><p>调用者&#x2F;请求者角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多命令对象</p></li></ul><p>引例：</p><p><img src="/../0_images/DesignPattern/17_%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><p>简单的：遥控器，集成很多的命令</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者接口（家电基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Appliance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Appliance</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体接收者：电灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span>:<span class="keyword">public</span> Appliance&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;电灯打开了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;电灯关闭了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体接收者：风扇</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fan</span>:<span class="keyword">public</span> Appliance&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;风扇打开了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;风扇关闭了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：打开命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOnCommand</span>:<span class="keyword">public</span> Command&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Appliance* appliance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TurnOnCommand</span>(Appliance* app) : <span class="built_in">appliance</span>(app) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; appliance-&gt;<span class="built_in">on</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; appliance-&gt;<span class="built_in">off</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：关闭命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOffCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line">    Appliance* appliance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TurnOffCommand</span>(Appliance* app) : <span class="built_in">appliance</span>(app) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; appliance-&gt;<span class="built_in">off</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; appliance-&gt;<span class="built_in">on</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者（遥控器按钮）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command * command;</span><br><span class="line">    Command* lastCommand;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommand</span><span class="params">(Command* cmd)</span> </span>&#123;</span><br><span class="line">        command = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pressButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        lastCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pressUndo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastCommand) &#123;</span><br><span class="line">            lastCommand-&gt;<span class="built_in">undo</span>();</span><br><span class="line">            lastCommand = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 创建家电设备</span></span><br><span class="line">    Light livingRoomLight;</span><br><span class="line">    Fan bathroomFan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建命令</span></span><br><span class="line">    <span class="function">TurnOnCommand <span class="title">lightOn</span><span class="params">(&amp;livingRoomLight)</span></span>;</span><br><span class="line">    <span class="function">TurnOffCommand <span class="title">fanOff</span><span class="params">(&amp;bathroomFan)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置遥控器</span></span><br><span class="line">    RemoteControl remote;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试电灯控制</span></span><br><span class="line">    remote.<span class="built_in">setCommand</span>(&amp;lightOn);</span><br><span class="line">    remote.<span class="built_in">pressButton</span>();  <span class="comment">// 开灯</span></span><br><span class="line">    remote.<span class="built_in">pressUndo</span>();    <span class="comment">// 关灯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试风扇控制</span></span><br><span class="line">    remote.<span class="built_in">setCommand</span>(&amp;fanOff);</span><br><span class="line">    remote.<span class="built_in">pressButton</span>();  <span class="comment">// 关风扇</span></span><br><span class="line">    remote.<span class="built_in">pressUndo</span>();    <span class="comment">// 开风扇</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><img src="/../0_images/DesignPattern/18_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类（采购请求）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> type;  <span class="comment">// 请求类型</span></span><br><span class="line">    <span class="type">int</span> id;     <span class="comment">// 请求ID</span></span><br><span class="line">    <span class="type">double</span> amount; <span class="comment">// 金额</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PurchaseRequest</span>(<span class="type">int</span> t, <span class="type">int</span> i, <span class="type">double</span> a)</span><br><span class="line">        : <span class="built_in">type</span>(t), <span class="built_in">id</span>(i), <span class="built_in">amount</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Approver</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Approver * successor; <span class="comment">// 下一级处理者</span></span><br><span class="line">    string name;         <span class="comment">// 处理者名称</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Approver</span>(string n) : <span class="built_in">name</span>(n), <span class="built_in">successor</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(Approver* s)</span> </span>&#123;</span><br><span class="line">        successor = s;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest* request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：经理（可审批5000元以下）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> :<span class="keyword">public</span> Approver&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Manager</span>(string n) : <span class="built_in">Approver</span>(n) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest* request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request-&gt;amount&lt;<span class="number">5000</span>)&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;经理审批采购单#&quot;</span></span><br><span class="line">                 &lt;&lt; request-&gt;id &lt;&lt; <span class="string">&quot;，金额：&quot;</span></span><br><span class="line">                 &lt;&lt; request-&gt;amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            successor-&gt;<span class="built_in">processRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：总监（可审批10000元以下）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> : <span class="keyword">public</span> Approver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Director</span>(string n) : <span class="built_in">Approver</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest* request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request-&gt;amount &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot;总监审批采购单#&quot;</span></span><br><span class="line">                 &lt;&lt; request-&gt;id &lt;&lt; <span class="string">&quot;，金额：&quot;</span></span><br><span class="line">                 &lt;&lt; request-&gt;amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (successor != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            successor-&gt;<span class="built_in">processRequest</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者：CEO（可审批任意金额）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CEO</span> : <span class="keyword">public</span> Approver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CEO</span>(string n) : <span class="built_in">Approver</span>(n) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest* request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; <span class="string">&quot;CEO审批采购单#&quot;</span></span><br><span class="line">             &lt;&lt; request-&gt;id &lt;&lt; <span class="string">&quot;，金额：&quot;</span></span><br><span class="line">             &lt;&lt; request-&gt;amount &lt;&lt; <span class="string">&quot;元&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建处理者</span></span><br><span class="line">    <span class="function">Manager <span class="title">manager</span><span class="params">(<span class="string">&quot;张&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Director <span class="title">director</span><span class="params">(<span class="string">&quot;王&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CEO <span class="title">ceo</span><span class="params">(<span class="string">&quot;李&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置责任链</span></span><br><span class="line">    manager.<span class="built_in">setSuccessor</span>(&amp;director);</span><br><span class="line">    director.<span class="built_in">setSuccessor</span>(&amp;ceo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="function">PurchaseRequest <span class="title">req1</span><span class="params">(<span class="number">1</span>, <span class="number">1001</span>, <span class="number">4500</span>)</span></span>;</span><br><span class="line">    <span class="function">PurchaseRequest <span class="title">req2</span><span class="params">(<span class="number">2</span>, <span class="number">1002</span>, <span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="function">PurchaseRequest <span class="title">req3</span><span class="params">(<span class="number">3</span>, <span class="number">1003</span>, <span class="number">150000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链首开始处理请求</span></span><br><span class="line">    manager.<span class="built_in">processRequest</span>(&amp;req1); <span class="comment">// 经理处理</span></span><br><span class="line">    manager.<span class="built_in">processRequest</span>(&amp;req2); <span class="comment">// 总监处理</span></span><br><span class="line">    manager.<span class="built_in">processRequest</span>(&amp;req3); <span class="comment">// CEO处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>​对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p><p>结构：</p><ul><li><p>环境角色：也称上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对像来处理</p></li><li><p>抽象状态：定义了一个接口，用以封装环境对象中的特定状态所对应的行为</p></li><li><p>具体状态：实现抽象状态所对应的行为</p></li></ul><p><img src="/../0_images/DesignPattern/19_%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElevatorContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">openDoors</span><span class="params">(ElevatorContext* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">closeDoors</span><span class="params">(ElevatorContext* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">(ElevatorContext* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">stop</span><span class="params">(ElevatorContext* context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ElevatorState</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前声明具体状态类（关键修改点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorsOpenState</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorsClosedState</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingState</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElevatorContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;ElevatorState&gt; currentState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ElevatorContext</span>(unique_ptr&lt;ElevatorState&gt; state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委托方法给当前状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">requestOpenDoors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">requestCloseDoors</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">requestMove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">requestStop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeState</span><span class="params">(unique_ptr&lt;ElevatorState&gt; state)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayState</span><span class="params">(<span class="type">const</span> string&amp; stateName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorsOpenState</span> : <span class="keyword">public</span> ElevatorState &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorsClosedState</span> : <span class="keyword">public</span> ElevatorState &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingState</span> : <span class="keyword">public</span> ElevatorState &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeDoors</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">(ElevatorContext* context)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类方法实现</span></span><br><span class="line">ElevatorContext::<span class="built_in">ElevatorContext</span>(unique_ptr&lt;ElevatorState&gt; state)</span><br><span class="line">    : <span class="built_in">currentState</span>(<span class="built_in">move</span>(state)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::requestOpenDoors</span><span class="params">()</span> </span>&#123; currentState-&gt;<span class="built_in">openDoors</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::requestCloseDoors</span><span class="params">()</span> </span>&#123; currentState-&gt;<span class="built_in">closeDoors</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::requestMove</span><span class="params">()</span> </span>&#123; currentState-&gt;<span class="built_in">move</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::requestStop</span><span class="params">()</span> </span>&#123; currentState-&gt;<span class="built_in">stop</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::changeState</span><span class="params">(unique_ptr&lt;ElevatorState&gt; state)</span> </span>&#123;</span><br><span class="line">    currentState = <span class="built_in">move</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ElevatorContext::displayState</span><span class="params">(<span class="type">const</span> string&amp; stateName)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Elevator is now in [&quot;</span> &lt;&lt; stateName &lt;&lt; <span class="string">&quot;] state\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类方法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsOpenState::openDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Doors are already open\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsOpenState::closeDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Closing doors...\n&quot;</span>;</span><br><span class="line">    context-&gt;<span class="built_in">changeState</span>(<span class="built_in">make_unique</span>&lt;DoorsClosedState&gt;());</span><br><span class="line">    context-&gt;<span class="built_in">displayState</span>(<span class="string">&quot;Doors Closed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsOpenState::move</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cannot move while doors are open\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsOpenState::stop</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Already stopped with open doors\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsClosedState::openDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Opening doors...\n&quot;</span>;</span><br><span class="line">    context-&gt;<span class="built_in">changeState</span>(<span class="built_in">make_unique</span>&lt;DoorsOpenState&gt;());</span><br><span class="line">    context-&gt;<span class="built_in">displayState</span>(<span class="string">&quot;Doors Open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsClosedState::closeDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Doors are already closed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsClosedState::move</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Starting movement...\n&quot;</span>;</span><br><span class="line">    context-&gt;<span class="built_in">changeState</span>(<span class="built_in">make_unique</span>&lt;MovingState&gt;());</span><br><span class="line">    context-&gt;<span class="built_in">displayState</span>(<span class="string">&quot;Moving&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoorsClosedState::stop</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Already stopped with closed doors\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::openDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cannot open doors while moving\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::closeDoors</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Doors are already closed\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::move</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Already moving\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovingState::stop</span><span class="params">(ElevatorContext* context)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stopping...\n&quot;</span>;</span><br><span class="line">    context-&gt;<span class="built_in">changeState</span>(<span class="built_in">make_unique</span>&lt;DoorsClosedState&gt;());</span><br><span class="line">    context-&gt;<span class="built_in">displayState</span>(<span class="string">&quot;Doors Closed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ElevatorContext <span class="title">elevator</span><span class="params">(make_unique&lt;DoorsOpenState&gt;())</span></span>;</span><br><span class="line">    </span><br><span class="line">    elevator.<span class="built_in">requestCloseDoors</span>(); <span class="comment">// 关门并进入门已关闭状态</span></span><br><span class="line">    elevator.<span class="built_in">requestMove</span>();       <span class="comment">// 开始移动</span></span><br><span class="line">    elevator.<span class="built_in">requestOpenDoors</span>();  <span class="comment">// 尝试开门（应失败）</span></span><br><span class="line">    elevator.<span class="built_in">requestStop</span>();       <span class="comment">// 停止并回到门已关闭状态</span></span><br><span class="line">    elevator.<span class="built_in">requestOpenDoors</span>();  <span class="comment">// 开门回到初始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>​又称为发布-订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时检测某一主题对象，这个主题对象在状态变化时，会通知所有的观察者对象，使它们能够自动更新自己</p><p>结构：</p><ul><li><p>抽象主题（抽象被观察者），抽象主题角色吧所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象</p></li><li><p>具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p></li><li><p>抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p></li><li><p>具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态</p></li></ul><p><img src="/../0_images/DesignPattern/20_%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B%E5%AD%90.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Subject* subject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Observer*&gt; observers_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span></span>&#123;</span><br><span class="line">        observers_.<span class="built_in">erase</span>(<span class="built_in">remove</span>(observers_.<span class="built_in">begin</span>(),observers_.<span class="built_in">end</span>(),observer), observers_.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> observer: observers_)&#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题：气象站</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> temperature_;</span><br><span class="line">    <span class="type">float</span> humidity_;</span><br><span class="line">    <span class="type">float</span> pressure_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        temperature_ = temperature;</span><br><span class="line">        humidity_ = humidity;</span><br><span class="line">        pressure_ = pressure;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getTemperature</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> temperature_; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getHumidity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> humidity_; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">getPressure</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pressure_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者：当前天气状况显示 显示当前天气数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WeatherStation* weatherStation_;</span><br><span class="line">    <span class="type">float</span> temperature_;</span><br><span class="line">    <span class="type">float</span> humidity_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CurrentConditionsDisplay</span>(WeatherStation* weatherStation)</span><br><span class="line">            : <span class="built_in">weatherStation_</span>(weatherStation) &#123;</span><br><span class="line">            weatherStation_-&gt;<span class="built_in">attach</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Subject* subject)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> ws = <span class="built_in">dynamic_cast</span>&lt;WeatherStation*&gt;(subject)) &#123;</span><br><span class="line">            temperature_ = ws-&gt;<span class="built_in">getTemperature</span>();</span><br><span class="line">            humidity_ = ws-&gt;<span class="built_in">getHumidity</span>();</span><br><span class="line">            <span class="built_in">display</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Current conditions: &quot;</span></span><br><span class="line">                  &lt;&lt; temperature_ &lt;&lt; <span class="string">&quot;°C and &quot;</span></span><br><span class="line">                  &lt;&lt; humidity_ &lt;&lt; <span class="string">&quot;humidity\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者：天气预报显示 根据气压变化显示天气预报</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForecastDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ForecastDisplay</span><span class="params">(WeatherStation* weatherStation)</span></span></span><br><span class="line"><span class="function">        : weatherStation_(weatherStation) &#123;</span></span><br><span class="line">        weatherStation_-&gt;<span class="built_in">attach</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Subject* subject)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> ws = <span class="built_in">dynamic_cast</span>&lt;WeatherStation*&gt;(subject)) &#123;</span><br><span class="line">            lastPressure_ = currentPressure_;</span><br><span class="line">            currentPressure_ = ws-&gt;<span class="built_in">getPressure</span>();</span><br><span class="line">            <span class="built_in">display</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Forecast: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentPressure_ &gt; lastPressure_) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Improving weather!\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentPressure_ == lastPressure_) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;More of the same\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Watch out for cooler, rainy weather\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WeatherStation* weatherStation_;</span><br><span class="line">    <span class="type">float</span> currentPressure_ = <span class="number">1013.0f</span>;</span><br><span class="line">    <span class="type">float</span> lastPressure_ = <span class="number">1013.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeatherStation weatherStation;</span><br><span class="line">    </span><br><span class="line">    <span class="function">CurrentConditionsDisplay <span class="title">currentDisplay</span><span class="params">(&amp;weatherStation)</span></span>;</span><br><span class="line">    <span class="function">ForecastDisplay <span class="title">forecastDisplay</span><span class="params">(&amp;weatherStation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟天气数据更新</span></span><br><span class="line">    weatherStation.<span class="built_in">setMeasurements</span>(<span class="number">25.0f</span>, <span class="number">65.0f</span>, <span class="number">1015.0f</span>);</span><br><span class="line">    weatherStation.<span class="built_in">setMeasurements</span>(<span class="number">22.5f</span>, <span class="number">70.0f</span>, <span class="number">1012.0f</span>);</span><br><span class="line">    weatherStation.<span class="built_in">setMeasurements</span>(<span class="number">20.0f</span>, <span class="number">90.0f</span>, <span class="number">1008.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="built_in">default</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题（被观察者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemperatureSensor</span> &#123;</span><br><span class="line">    std::vector&lt;Observer*&gt; observers_;</span><br><span class="line">    <span class="type">float</span> temperature_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTemperature</span><span class="params">(<span class="type">float</span> newTemp)</span> </span>&#123;</span><br><span class="line">        temperature_ = newTemp;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> observer : observers_) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(temperature_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;温度更新: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="string">&quot;°C\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TemperatureSensor sensor;</span><br><span class="line">    Display display;</span><br><span class="line"></span><br><span class="line">    sensor.<span class="built_in">attach</span>(&amp;display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟温度变化</span></span><br><span class="line">    sensor.<span class="built_in">setTemperature</span>(<span class="number">25.5</span>);</span><br><span class="line">    sensor.<span class="built_in">setTemperature</span>(<span class="number">23.0</span>);</span><br><span class="line">    sensor.<span class="built_in">setTemperature</span>(<span class="number">20.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>又叫调停模式。定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变他们之间的交互</p><p>结构：</p><ul><li><p>抽象中介者：中介者的借口，提供了同事对象注册与转发同事对象信息的抽象方法</p></li><li><p>具体中介：实现中介者借口，定义一个List集合来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色</p></li><li><p>抽象同事类：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p></li><li><p>具体同事类：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message,<span class="type">const</span> Colleague* sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addColleague</span><span class="params">(Colleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator* mediator_;</span><br><span class="line">    string name_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Colleague</span>(Mediator* mediator, <span class="type">const</span> string&amp; name)</span><br><span class="line">        : <span class="built_in">mediator_</span>(mediator), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Colleague</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者（聊天室）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoomMediator</span>:<span class="keyword">public</span> Mediator&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Colleague*&gt; colleagues_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addColleague</span><span class="params">(Colleague* colleague)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        colleagues_.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message, <span class="type">const</span> Colleague* sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> colleague : colleagues_) &#123;</span><br><span class="line">            <span class="comment">// 不将消息发送给发送者自己</span></span><br><span class="line">            <span class="keyword">if</span> (colleague != sender) &#123;</span><br><span class="line">                colleague-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事类（用户）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="keyword">public</span> Colleague&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(Mediator* mediator, <span class="type">const</span> string&amp; name)</span><br><span class="line">    : <span class="built_in">Colleague</span>(mediator, name) &#123;</span><br><span class="line">        mediator_-&gt;<span class="built_in">addColleague</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; 发送消息: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        mediator_-&gt;<span class="built_in">sendMessage</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; name_ &lt;&lt; <span class="string">&quot; 收到消息: &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ChatRoomMediator chatRoom;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">alice</span><span class="params">(&amp;chatRoom, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">bob</span><span class="params">(&amp;chatRoom, <span class="string">&quot;Bob&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">charlie</span><span class="params">(&amp;chatRoom, <span class="string">&quot;Charlie&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    alice.<span class="built_in">send</span>(<span class="string">&quot;大家好！&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    bob.<span class="built_in">send</span>(<span class="string">&quot;今天天气不错！&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    charlie.<span class="built_in">send</span>(<span class="string">&quot;有人想去喝咖啡吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><p>结构:</p><ul><li><p>抽象聚合对象：定义存储、添加、删除聚合元素以及创建迭代器对象的接口</p></li><li><p>具体聚合对象：实现抽象聚合类，返回一个具有迭代器的实例</p></li><li><p>抽象迭代器对象：定义访问和遍历聚合元素的接口，通常包含hasNext（）、next（）等方法</p></li><li><p>具体迭代器对象：实现抽象迭代器接口所定义的方法，完成对聚合对象的遍历，记录遍历当前位置</p></li></ul><p>将遍历的功能分开，专门使用一个类来管理</p><p><img src="/../0_images/DesignPattern/21_%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringCollection</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Collection</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">createIterator</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> StringCollection&amp; collection;</span><br><span class="line">    <span class="type">size_t</span> currentIndex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringIterator</span>(<span class="type">const</span> StringCollection&amp; coll);</span><br><span class="line">    <span class="function">string <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体集合类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringCollection</span> : <span class="keyword">public</span> Collection &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string items[<span class="number">5</span>];</span><br><span class="line">    <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> string&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            items[count++] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> items[index]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">StringIterator</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器实现</span></span><br><span class="line">StringIterator::<span class="built_in">StringIterator</span>(<span class="type">const</span> StringCollection&amp; coll)</span><br><span class="line">    : <span class="built_in">collection</span>(coll), <span class="built_in">currentIndex</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">StringIterator::next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> collection.<span class="built_in">get</span>(currentIndex++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StringIterator::hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentIndex &lt; collection.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    StringCollection collection;</span><br><span class="line">    collection.<span class="built_in">add</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    collection.<span class="built_in">add</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    collection.<span class="built_in">add</span>(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator* it = collection.<span class="built_in">createIterator</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (it-&gt;<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;<span class="built_in">next</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> it;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>​封装一些作用于某些数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作</p><p>结构：</p><ul><li><p>抽象访问者：定义了对每一个元素访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数是一样的，从这点不难看出，访问者模式要求元素的个数不能改变</p></li><li><p>具体访问者：给出对每一个元素类访问时所产生的具体行为<br>抽象元素：定义了一个接受访问者的方法，每一个元素都要可以被访问者访问</p></li><li><p>具体元素：提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用范文哲提供的访问该元素类的方法</p></li><li><p>对象结构角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特征的类，它会含有一组元素，并且可以迭代这些元素，供访问者访问</p></li></ul><p><img src="/../0_images/DesignPattern/22_%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA* element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB* element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor-&gt;<span class="built_in">visit</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> : <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA* element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;访问者正在访问 &quot;</span> &lt;&lt; element-&gt;<span class="built_in">operationA</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB* element)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;访问者正在访问 &quot;</span> &lt;&lt; element-&gt;<span class="built_in">operationB</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构（管理元素集合）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Element*&gt; elements;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Element* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor* visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : elements) &#123;</span><br><span class="line">            elem-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectStructure structure;</span><br><span class="line">    structure.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementA</span>());</span><br><span class="line">    structure.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementB</span>());</span><br><span class="line">    </span><br><span class="line">    ConcreteVisitor visitor;</span><br><span class="line">    structure.<span class="built_in">accept</span>(&amp;visitor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态</p><p>结构：</p><ul><li><p>发起人角色：记录当前时刻的内部状态信息，提供创建备忘录和回复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p></li><li><p>备忘录角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</p></li><li><p>管理者角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问和修改</p></li></ul><p><img src="/../0_images/DesignPattern/23_%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%BC%95%E4%BE%8B.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白盒实现：Memento 内部状态对 Caretaker 可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextMemento</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string text_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextMemento</span>(string text) : <span class="built_in">text_</span>(<span class="built_in">move</span>(text)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 暴露内部状态的公共方法</span></span><br><span class="line">    <span class="function">string <span class="title">GetText</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> text_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetText</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123; text_ = text; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Originator（原发器）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string content_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123; content_ += text; &#125;</span><br><span class="line">    <span class="function">TextMemento <span class="title">CreateMemento</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TextMemento</span>(content_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RestoreMemento</span><span class="params">(<span class="type">const</span> TextMemento&amp; memento)</span> </span>&#123;</span><br><span class="line">        content_ = memento.<span class="built_in">GetText</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Current content: &quot;</span> &lt;&lt; content_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caretaker（管理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;TextMemento&gt; history_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Save</span><span class="params">(<span class="type">const</span> TextMemento&amp; memento)</span> </span>&#123;</span><br><span class="line">        history_.<span class="built_in">push_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TextMemento <span class="title">Undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!history_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> history_.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TextMemento</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    TextEditor editor;</span><br><span class="line">    History history;</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">Write</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    history.<span class="built_in">Save</span>(editor.<span class="built_in">CreateMemento</span>());</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">Write</span>(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">RestoreMemento</span>(history.<span class="built_in">Undo</span>());</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象备忘录接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IMemento</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IMemento</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Originator（原发器）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 内部 Memento 实现</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TextMemento</span> : <span class="keyword">public</span> IMemento &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TextMemento</span>(std::string text) : <span class="built_in">text_</span>(std::<span class="built_in">move</span>(text)) &#123;&#125;</span><br><span class="line">        <span class="comment">// 只有 TextEditor 可以访问私有成员</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string text_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123; content_ += text; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMemento* <span class="title">CreateMemento</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextMemento</span>(content_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RestoreMemento</span><span class="params">(<span class="type">const</span> IMemento* memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> concrete = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> TextMemento*&gt;(memento);</span><br><span class="line">        <span class="keyword">if</span> (concrete) &#123;</span><br><span class="line">            content_ = concrete-&gt;text_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current content: &quot;</span> &lt;&lt; content_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Caretaker（管理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;IMemento*&gt; history_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Save</span><span class="params">(IMemento* memento)</span> </span>&#123;</span><br><span class="line">        history_.<span class="built_in">emplace_back</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">IMemento* <span class="title">Undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!history_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> history_.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor editor;</span><br><span class="line">    History history;</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">Write</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    history.<span class="built_in">Save</span>(editor.<span class="built_in">CreateMemento</span>());</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">Write</span>(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line">    </span><br><span class="line">    editor.<span class="built_in">RestoreMemento</span>(history.<span class="built_in">Undo</span>());</span><br><span class="line">    editor.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白盒实现：</p><ul><li><p>Memento 类保持公共接口</p></li><li><p>Caretaker 可以直接访问 Memento 的内部状态</p></li><li><p>实现简单但破坏了封装性</p></li></ul><p>黑盒实现：</p><ul><li><p>使用接口类 IMemento 隐藏实现细节</p></li><li><p>具体 Memento 作为 Originator 的内部类</p></li><li><p>通过友元关系保持封装性</p></li><li><p>Caretaker 只能处理抽象接口</p></li><li><p>更符合面向对象设计原则</p></li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>​给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>结构：</p><ul><li><p>抽象表达式角色： 定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret</p></li><li><p>终结符表达式角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之对应</p></li><li><p>非终结符表达式角色：也是抽象表达式的子类。是来实现文法中与非终结符相关的操作，文法中发每条规则都对应于一个非终结符表达式</p></li><li><p>环境角色：通常包含各个解释器需要的数据或者是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值</p></li><li><p>客户端：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(<span class="type">const</span> string&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        variables[var] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getVariable</span><span class="params">(<span class="type">const</span> string&amp; var)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> variables.<span class="built_in">at</span>(var); <span class="comment">// 使用at()进行安全访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象表达式接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式：变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string varName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">VariableExpression</span><span class="params">(string var)</span> : varName(move(var)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.<span class="built_in">getVariable</span>(varName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式：数字常量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NumberExpression</span><span class="params">(<span class="type">int</span> num)</span> : number(num) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：加法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;Expression&gt; left;</span><br><span class="line">    unique_ptr&lt;Expression&gt; right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(unique_ptr&lt;Expression&gt; l, unique_ptr&lt;Expression&gt; r)</span><br><span class="line">        : <span class="built_in">left</span>(<span class="built_in">move</span>(l)), <span class="built_in">right</span>(<span class="built_in">move</span>(r)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>(context) + right-&gt;<span class="built_in">interpret</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：减法操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractExpression</span> : <span class="keyword">public</span> Expression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;Expression&gt; left;</span><br><span class="line">    unique_ptr&lt;Expression&gt; right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubtractExpression</span>(unique_ptr&lt;Expression&gt; l, unique_ptr&lt;Expression&gt; r)</span><br><span class="line">        : <span class="built_in">left</span>(<span class="built_in">move</span>(l)), <span class="built_in">right</span>(<span class="built_in">move</span>(r)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>(context) - right-&gt;<span class="built_in">interpret</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line">    context.<span class="built_in">setVariable</span>(<span class="string">&quot;x&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    context.<span class="built_in">setVariable</span>(<span class="string">&quot;y&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建表达式树：(x + 20) - (y + 5)</span></span><br><span class="line">    <span class="keyword">auto</span> expr = <span class="built_in">make_unique</span>&lt;SubtractExpression&gt;(</span><br><span class="line">        <span class="built_in">make_unique</span>&lt;AddExpression&gt;(</span><br><span class="line">            <span class="built_in">make_unique</span>&lt;VariableExpression&gt;(<span class="string">&quot;x&quot;</span>),</span><br><span class="line">            <span class="built_in">make_unique</span>&lt;NumberExpression&gt;(<span class="number">20</span>)</span><br><span class="line">        ),</span><br><span class="line">        <span class="built_in">make_unique</span>&lt;AddExpression&gt;(</span><br><span class="line">            <span class="built_in">make_unique</span>&lt;VariableExpression&gt;(<span class="string">&quot;y&quot;</span>),</span><br><span class="line">            <span class="built_in">make_unique</span>&lt;NumberExpression&gt;(<span class="number">5</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = expr-&gt;<span class="built_in">interpret</span>(context);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计算结果: &quot;</span> &lt;&lt; result &lt;&lt; endl; <span class="comment">// 输出：20 = (10+20)-(5+5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Thread</title>
      <link href="/2025/04/13/C++Thread/"/>
      <url>/2025/04/13/C++Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="C-线程"><a href="#C-线程" class="headerlink" title="C++线程"></a>C++线程</h1><h2 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h2><p>1.多线程的含义</p><p>多线程（multithreading），是指在软件或者硬件上实现多个线程并发执行的技术。具有多核CPU的支持的计算机能够真正在同一时间执行多个程序片段，进而提升程序的处理性能。在一个程序中，这些独立运行的程序片段被称为“线程”（Thread），利用其编程的概念就叫作“多线程处理”。</p><p>2.进程与线程的区别</p><p>进程是指一个程序的运行实例，而线程是指进程中独立的执行流程。一个进程可以有多个线程，多个线程之间可以并发执行。</p><ul><li><p>一个程序有且只有一个进程，但可以拥有至少一个的线程。</p></li><li><p>不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。</p></li></ul><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>thread</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunctionA</span><span class="params">(<span class="type">int</span> A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;线程 A：&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunctionB</span><span class="params">(<span class="type">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;B;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;线程 B：&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">ThreadA</span><span class="params">(ThreadFunctionA,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">ThreadB</span><span class="params">(ThreadFunctionB,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ThreadA.<span class="built_in">join</span>();ThreadB.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join-和-detach"><a href="#join-和-detach" class="headerlink" title="join() 和 detach()"></a>join() 和 detach()</h2><p>在C++中，创建了一个线程时，它通常被称为一个可联接(joinable)的线程，可以通过调用join()函数或detach()函数来管理线程的执行。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>等待一个线程完成，如果该线程还未执行完毕，则当前线程（一般是主线程）将被阻塞，直到该线程执行完成，主线程才会继续执行。</td></tr><tr><td>detach()</td><td>将当前线程与创建的线程分离，使它们分别运行，当分离的线程执行完毕后，系统会自动回收其资源。如果一个线程被分离了，就不能再使用 join() 函数了，因为线程已经无法被联接了。</td></tr><tr><td>joinable()</td><td>判断线程是否可以执行 join() 函数，返回 true&#x2F;false</td></tr></tbody></table><p>注意：</p><ul><li><p>线程是在thread对象被定义的时候开始执行的，而不是在调用join()函数时才执行的，调用join()函数只是阻塞等待线程结束并回收资源。</p></li><li><p>分离的线程（执行过detach()的线程）会在调用它的线程结束或自己结束时自动释放资源。</p></li><li><p>线程会在函数运行完毕后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏。</p></li><li><p>若没有执行join()或detach()的线程在程序结束时会引发异常。</p></li></ul><h2 id="当前线程的功能函数-this-thread"><a href="#当前线程的功能函数-this-thread" class="headerlink" title="当前线程的功能函数 this_thread"></a>当前线程的功能函数 this_thread</h2><table><thead><tr><th>使用</th><th>说明</th></tr></thead><tbody><tr><td><code>std::this_thread::sleep_for()</code></td><td>当前线程休眠指定的时间</td></tr><tr><td><code>std::this_thread::sleep_until()</code></td><td>当前线程休眠直到指定时间点</td></tr><tr><td><code>std::this_thread::yield()</code></td><td>当前线程让出CPU，允许其他线程运行</td></tr><tr><td><code>std::this_thread::get_id()</code></td><td>获取当前线程的ID</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_thread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Thread ID&quot;</span>&lt;&lt;this_thread::<span class="built_in">get_id</span>()&lt;&lt;<span class="string">&quot; start! &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; running: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();<span class="comment">// 让出当前线程的时间片</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));  <span class="comment">// 线程休眠200毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; end！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(my_thread)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(my_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>在多线程编程中，需要注意以下问题：</p><p>线程之间的共享数据访问需要进行同步，以防止数据竞争和其他问题。可以使用互斥量、条件变量等机制进行同步。<br>可能会发生死锁问题，即多个线程互相等待对方释放锁，导致程序无法继续执行。<br>可能会发生竞态条件问题，即多个线程执行的顺序导致结果的不确定性。</p><p>std::mutex是 C++11 中最基本的互斥量，一个线程将mutex锁住时，其它的线程就不能操作mutex，直到这个线程将mutex解锁。</p><p><strong>1.lock() 与 unlock()</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>lock()</td><td>将mutex上锁。如果mutex已经被其它线程上锁，那么会阻塞，直到解锁；如果mutex已经被同一个线程锁住，那么会产生死锁。</td></tr><tr><td>unlock()</td><td>将mutex解锁，释放其所有权。如果有线程因为调用 lock() 不能上锁而被阻塞，则调用此函数会将mutex的主动权随机交给其中一个线程；如果mutex不是被此线程上锁，那么会引发未定义的异常。</td></tr><tr><td>try_lock()</td><td>尝试将mutex上锁。如果mutex未被上锁，则将其上锁并返回true；如果mutex已被锁则返回false。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样其实还不明显，比如写1+到10000,分10个线程运行，加不加锁就非常明显了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">(<span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        n++;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    thread myThread[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(thread &amp;a:myThread)&#123;</span><br><span class="line">        a = <span class="built_in">thread</span>(thread_function,<span class="built_in">ref</span>(num));</span><br><span class="line">        a.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Main thread exits!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.lock_guard</strong></p><p>std::lock_guard是C++标准库中的一个模板类，用于实现资源的自动加锁和解锁。它是基于RAII（资源获取即初始化）的设计理念，能够确保在作用域结束时自动释放锁资源，避免了手动管理锁的复杂性和可能出现的错误。</p><p>std::lock_guard的主要特点如下：</p><ul><li><p>自动加锁： 在创建std::lock_guard对象时，会立即对指定的互斥量进行加锁操作。这样可以确保在进入作用域后，互斥量已经被锁定，避免了并发访问资源的竞争条件。</p></li><li><p>自动解锁：std::lock_guard对象在作用域结束时，会自动释放互斥量。无论作用域是通过正常的流程结束、异常抛出还是使用return语句提前返回，std::lock_guard都能保证互斥量被正确解锁，避免了资源泄漏和死锁的风险。</p></li><li><p>适用于局部锁定： 由于std::lock_guard是通过栈上的对象实现的，因此适用于在局部范围内锁定互斥量。当超出std::lock_guard对象的作用域时，互斥量会自动解锁，释放控制权。</p></li></ul><p>使用std::lock_guard的一般步骤如下：</p><ul><li><p>创建一个std::lock_guard对象，传入要加锁的互斥量作为参数。<br>执行需要加锁保护的代码块。</p></li><li><p>std::lock_guard对象的作用域结束时，自动调用析构函数解锁互斥量。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;  <span class="comment">// 互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁互斥量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 执行需要加锁保护的代码</span></span><br><span class="line">&#125;  <span class="comment">// lock_guard对象的析构函数自动解锁互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread exits!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，std::lock_guard对象lock会在thread_function中加锁互斥量，保护了输出语句的执行。当thread_function结束时，lock_guard对象的析构函数会自动解锁互斥量。这样可以确保互斥量在合适的时候被锁定和解锁，避免了多线程间的竞争问题。</p><p>总而言之，std::lock_guard提供了一种简单而安全的方式来管理互斥量的锁定和解锁，使多线程编程更加方便和可靠。</p><p><strong>3.unique_lock</strong></p><p>std::unique_lock是C++标准库中的一个模板类，用于实现更加灵活的互斥量的加锁和解锁操作。它提供了比std::lock_guard更多的功能和灵活性。</p><p>std::unique_lock的主要特点如下：</p><ul><li><p>自动加锁和解锁： 与std::lock_guard类似，std::unique_lock在创建对象时立即对指定的互斥量进行加锁操作，确保互斥量被锁定。在对象的生命周期结束时，会自动解锁互斥量。这种自动加锁和解锁的机制避免了手动管理锁的复杂性和可能出现的错误。</p></li><li><p>支持灵活的加锁和解锁： 相对于std::lock_guard的自动加锁和解锁，std::unique_lock提供了更灵活的方式。它可以在需要的时候手动加锁和解锁互斥量，允许在不同的代码块中对互斥量进行多次加锁和解锁操作。</p></li><li><p>支持延迟加锁和条件变量：std::unique_lock还支持延迟加锁的功能，可以在不立即加锁的情况下创建对象，稍后根据需要进行加锁操作。此外，它还可以与条件变量（std::condition_variable）一起使用，实现更复杂的线程同步和等待机制。</p></li></ul><p>使用std::unique_lock的一般步骤如下：</p><ul><li><p>创建一个std::unique_lock对象，传入要加锁的互斥量作为参数。</p></li><li><p>执行需要加锁保护的代码块。</p></li><li><p>可选地手动调用lock函数对互斥量进行加锁，或者在需要时调用unlock函数手动解锁互斥量。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex mtx;  <span class="comment">// 互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁互斥量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 执行需要加锁保护的代码</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 手动解锁互斥量</span></span><br><span class="line">    <span class="comment">// 执行不需要加锁保护的代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 再次加锁互斥量</span></span><br><span class="line">    <span class="comment">// 执行需要加锁保护的代码</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// unique_lock对象的析构函数自动解锁互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Main thread exits!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>std::condition_variable是C++标准库中的一个类，用于在多线程编程中实现线程间的条件变量和线程同步。它提供了等待和通知的机制，使得线程可以等待某个条件成立时被唤醒，或者在满足某个条件时通知其他等待的线程。其提供了以下几个函数用于等待和通知线程：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>wait()</td><td>使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 函数唤醒。该函数需要一个互斥锁作为参数，调用时会自动释放互斥锁，并在被唤醒后重新获取互斥锁。</td></tr><tr><td>wait_for()</td><td>使当前线程进入等待状态，最多等待一定的时间，直到被其他线程通过 notify_one() 或 notify_all() 函数唤醒，或者等待超时。该函数需要一个互斥锁和一个时间段作为参数，返回时有两种情况：等待超时返回 <code>std::cv_status::timeout</code>，被唤醒返回 <code>std::cv_status::no_timeout</code>。</td></tr><tr><td>wait_until()</td><td>使当前线程进入等待状态，直到被其他线程通过 notify_one() 或 notify_all() 函数唤醒，或者等待时间达到指定的绝对时间点。该函数需要一个互斥锁和一个绝对时间点作为参数，返回时有两种情况：时间到达返回 <code>std::cv_status::timeout</code>，被唤醒返回 <code>std::cv_status::no_timeout</code>。</td></tr><tr><td>notify_one()</td><td>唤醒一个等待中的线程，如果有多个线程在等待，则选择其中一个线程唤醒。</td></tr><tr><td>notify_all()</td><td>唤醒所有等待中的线程，使它们从等待状态返回。</td></tr></tbody></table><p>std::condition_variable的主要特点如下：</p><ul><li><p>等待和通知机制：std::condition_variable允许线程进入等待状态，直到某个条件满足时才被唤醒。线程可以调用wait函数进入等待状态，并指定一个互斥量作为参数，以确保线程在等待期间互斥量被锁定。当其他线程满足条件并调用notify_one或notify_all函数时，等待的线程将被唤醒并继续执行。</p></li><li><p>与互斥量配合使用：std::condition_variable需要与互斥量（std::mutex或std::unique_lock&lt;std::mutex&gt;）配合使用，以确保线程之间的互斥性。在等待之前，线程必须先锁定互斥量，以避免竞争条件。当条件满足时，通知其他等待的线程之前，必须再次锁定互斥量。</p></li><li><p>支持超时等待：std::condition_variable提供了带有超时参数的等待函数wait_for和wait_until，允许线程在等待一段时间后自动被唤醒。这对于处理超时情况或限时等待非常有用</p></li></ul><p>使用std::condition_variable的一般步骤如下：</p><ul><li><p>创建一个std::condition_variable对象。</p></li><li><p>创建一个互斥量对象（std::mutex或std::unique_lock<a href="std::mutex">std::mutex</a>）。</p></li><li><p>在等待线程中，使用std::unique_lock锁定互斥量，并调用wait函数进入等待状态。</p></li><li><p>在唤醒线程中，使用std::unique_lock锁定互斥量，并调用notify_one或notify_all函数通知等待的线程。</p></li><li><p>等待线程被唤醒后，继续执行相应的操作。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;  <span class="comment">// 互斥量</span></span><br><span class="line">condition_variable cv;  <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> isReady = <span class="literal">false</span>;  <span class="comment">// 条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!isReady) </span><br><span class="line">    &#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);  <span class="comment">// 等待条件满足</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread is notified&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段耗时操作</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        isReady = <span class="literal">true</span>;  <span class="comment">// 设置条件为true</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// 通知等待的线程</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>std::mutex可以很好地解决多线程资源争抢的问题，但它每次循环都要加锁、解锁，这样固然会浪费很多的时间。</p><p>在 C++ 中，std::atomic 是用来提供原子操作的类，atomic，本意为原子，原子操作是最小的且不可并行化的操作。这就意味着即使是多线程，也要像同步进行一样同步操作原子对象，从而省去了互斥量上锁、解锁的时间消耗。</p><p>使用 std::atomic 可以保证数据在操作期间不被其他线程修改，这样就避免了数据竞争，使得程序在多线程并发访问时仍然能够正确执行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span>   <span class="comment">//必须包含</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic_int num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">(atomic_int &amp;n)</span>  <span class="comment">//修改类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread myThread[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">for</span> (thread &amp;a : myThread)</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="built_in">thread</span>(thread_function, <span class="built_in">ref</span>(num));</span><br><span class="line">a.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Main thread exits!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ template</title>
      <link href="/2025/04/13/C++template/"/>
      <url>/2025/04/13/C++template/</url>
      
        <content type="html"><![CDATA[<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h1><p>C++提供了模板(template)编程的概念。所谓模板，实际上是建立一个通用函数或类，其类内部的类型和函数的形参类型不具体指定，用一个虚拟的类型来代表。这种通用的方式称为模板。模板是泛型编程的基础,泛型编程即以一种独立于任何特定类型的方式编写代码。</p><h2 id="C-函数模板的使用"><a href="#C-函数模板的使用" class="headerlink" title="C++函数模板的使用"></a>C++函数模板的使用</h2><p>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。 凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</p><pre><code>由以下三部分组成：模板说明 + 函数定义 + 函数模板调用    template &lt; 类型形式参数表 &gt; 类型    函数名 ( 形式参数表 )    &#123;            //语句序列    &#125;</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int Max(int a, int b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return a&gt;b ? a:b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">char Max(char a, char b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return a&gt;b ? a:b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">float Max(float a, float b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return a&gt;b ? a:b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//template 关键字告诉 C++编译器 我要开始泛型编程了,请你不要随意报错</span></span><br><span class="line"><span class="comment">//T - 参数化数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;max(1, 2) = &quot;</span>&lt;&lt;<span class="built_in">Max</span>(x, y)&lt;&lt;endl; <span class="comment">//实现参数类型的自动推导</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;max(1, 2) = &quot;</span>&lt;&lt;<span class="built_in">Max</span>&lt;<span class="type">int</span>&gt;(x,y)&lt;&lt;endl;<span class="comment">//显示类型调用</span></span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;max(2.0, 3.0) = &quot;</span>&lt;&lt;<span class="built_in">Max</span>(a, b)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../0_images/C++template/1_%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0.png" alt="alt text"></p><p>函数模板和普通函数区别结论：</p><ul><li><p>两者允许并存</p></li><li><p>函数模板不允许自动类型转化</p></li><li><p>普通函数能够进行自动类型转换</p></li></ul><p>函数模板和普通函数在一起，调用规则：</p><ul><li><p>函数模板可以像普通函数一样被重载</p></li><li><p>C++编译器优先考虑普通函数</p></li><li><p>如果函数模板可以产生一个更好的匹配，那么选择模板</p></li><li><p>可以通过空模板实参列表的语法限定编译器只通过模板匹配</p></li></ul><p><strong>编译器并不是把函数模板处理成能够处理任意类型的函数</strong></p><p><strong>编译器从函数模板通过具体类型产生不同的函数</strong></p><h2 id="类模板的使用"><a href="#类模板的使用" class="headerlink" title="类模板的使用"></a>类模板的使用</h2><p>类模板与函数模板的定义和使用类似，有时，有两个或多个类，其功能是相同的，仅仅是 数据类型不同，我们可以通过如下面语句声明了一个类模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typenameType&gt;</span><br><span class="line">classClassName</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//ClassName的成员函数</span></span><br><span class="line"> <span class="keyword">private</span>：</span><br><span class="line">     TypeDataMember;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板用于实现类所需数据的类型参数化</p><p>类模板在表示支持多种数据结构显得特别重要，这些数据结构的表示和算法不受所 包含的元素类型的影响</p><p>简单样例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里还是需要指明参数的 A&lt;int&gt; &amp;a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">     cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//1.模板类定义类对象，必须显示指定类型</span></span><br><span class="line">     <span class="comment">//2.模板种如果使用了构造函数，则遵守以前的类的构造函数的调用规则</span></span><br><span class="line">     <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">     cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line">     <span class="comment">//模板类做为函数参数</span></span><br><span class="line">     <span class="built_in">printA</span>(a);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承中类模板的使用</strong></p><p>子类从模板类继承的时候,需要让编译器知道父类的数据类型具体是什么</p><ul><li><p>父类一般类，子类是模板类,和普通继承的玩法类似</p></li><li><p>子类是一般类，父类是模板类,继承时必须在子类里实例化父类的类型参数</p></li><li><p>父类和子类都时模板类时，子类的虚拟的类型可以传递到父类中</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tb&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&lt;Tb&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(Tb b):<span class="built_in">A</span>&lt;Tb&gt;(b)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Tb b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里还是需要指明参数的 A&lt;int&gt; &amp;a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">     cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.模板类定义类对象，必须显示指定类型</span></span><br><span class="line">    <span class="comment">//2.模板种如果使用了构造函数，则遵守以前的类的构造函数的调用规则</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">B&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">888</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b(888):&quot;</span>&lt;&lt;b.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板类做为函数参数</span></span><br><span class="line">    <span class="built_in">printA</span>(a);</span><br><span class="line">    <span class="comment">//模板类做为函数参数</span></span><br><span class="line">    <span class="built_in">printA</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板函数的三种表达描述方式</strong></p><ul><li><p>所有的类模板函数写在类的内部(如上面的例子)</p></li><li><p>所有的类模板函数写在类的外部，在一个cpp中</p></li><li><p>所有的类模板函数写在类的外部，在不同的.h和.cpp中</p></li></ul><p>对与第二点：所有的类模板函数写在类的外部，在一个cpp中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t);</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; A&lt;T&gt;::<span class="built_in">getT</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个cpp文件中把模板类的成员函数放到类的外部，需要注意以下几点</p><ul><li><p>函数前声明template</p></li><li><p>类的成员函数前的类限定域说明必须要带上虚拟参数列表</p></li><li><p>返回的变量是模板类的对象时必须带上虚拟参数列表</p></li><li><p>成员函数参数中出现模板类的对象时必须带上虚拟参数列表</p></li><li><p>成员函数内部没有限定</p></li></ul><p>对于第三点：所有的类模板函数写在类的外部，在不同的.h和.cpp中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//simpleTemplateClass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMPLE_TEMPLATE_CLASS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_TEMPLATE_CLASS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(T t);</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//simpleTemplateClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;simpleTemplateClass.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; A&lt;T&gt;::<span class="built_in">getT</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simpleTemplateClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;simpleTemplateClass.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里还是需要指明参数的 A&lt;int&gt; &amp;a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(A&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.模板类定义类对象，必须显示指定类型</span></span><br><span class="line">    <span class="comment">//2.模板种如果使用了构造函数，则遵守以前的类的构造函数的调用规则</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">666</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getT</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//模板类做为函数参数</span></span><br><span class="line">    <span class="built_in">printA</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：当类模板的声明(.h文件)和实现(.cpp或.hpp文件)完全分离，因为类模板的特殊实现， 我们应在使用类模板时使用#include包含实现部分的.cpp或.hpp文件。</p><p><strong>特殊情况友元函数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明模板类和模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; A&lt;T&gt; <span class="title">addA</span><span class="params">(<span class="type">const</span> A&lt;T&gt;&amp; a, <span class="type">const</span> A&lt;T&gt;&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(T t);</span><br><span class="line"> </span><br><span class="line">    <span class="function">T&amp; <span class="title">getT</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> A&lt;T&gt; <span class="built_in">addA</span>&lt;T&gt;(<span class="type">const</span> A&lt;T&gt;&amp; a, <span class="type">const</span> A&lt;T&gt;&amp; b); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">A&lt;T&gt;::<span class="built_in">A</span>(T t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; A&lt;T&gt;::<span class="built_in">getT</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T&gt;::<span class="built_in">print</span>()&#123;</span><br><span class="line">     cout&lt;&lt;<span class="keyword">this</span>-&gt;t&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">A&lt;T&gt; <span class="title">addA</span><span class="params">(<span class="type">const</span> A&lt;T&gt; &amp;a, <span class="type">const</span> A&lt;T&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    A&lt;T&gt; tmp;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;call add A()...&quot;</span>&lt;&lt;endl;</span><br><span class="line">    tmp.t=a.t+b.t;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">666</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">888</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;a.getT()&lt;&lt;endl;</span></span><br><span class="line">    A&lt;<span class="type">int</span>&gt; tmp1=<span class="built_in">addA</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    tmp<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>模板类和静态成员</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> T staticValue; <span class="comment">// 静态成员变量</span></span><br><span class="line">    T value;              <span class="comment">// 普通成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(T val) : <span class="built_in">value</span>(val) &#123;</span><br><span class="line">        staticValue = val; <span class="comment">// 初始化静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：打印静态成员变量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printStaticValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static Value: &quot;</span> &lt;&lt; staticValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：设置静态成员变量</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setStaticValue</span><span class="params">(<span class="type">const</span> T&amp; newVal)</span> </span>&#123;</span><br><span class="line">        staticValue = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式模板实例化 ！！！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyClass&lt;T&gt;::staticValue = <span class="built_in">T</span>(); <span class="comment">// 直接初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个对象</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印静态成员变量的初始值</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: 0</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态成员函数修改静态成员变量</span></span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt;::<span class="built_in">setStaticValue</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印静态成员变量的值</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: 100</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用普通成员函数</span></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">printValue</span>();       <span class="comment">// 输出：Value: 10</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">printValue</span>();       <span class="comment">// 输出：Value: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个不同类型的对象</span></span><br><span class="line">    <span class="function">MyClass&lt;std::string&gt; <span class="title">obj3</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印静态成员变量的初始值</span></span><br><span class="line">    obj<span class="number">3.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: (空字符串)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改静态成员变量</span></span><br><span class="line">    MyClass&lt;std::string&gt;::<span class="built_in">setStaticValue</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印静态成员变量的值</span></span><br><span class="line">    obj<span class="number">3.</span><span class="built_in">printStaticValue</span>(); <span class="comment">// 输出：Static Value: World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员</p><p>和非模板类的static数据成员一样，模板类的static数据成员也应该在文件范围定义和初始化</p><p>static 数据成员也可以使用虚拟类型参数T</p>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ stream</title>
      <link href="/2025/04/13/C++stream/"/>
      <url>/2025/04/13/C++stream/</url>
      
        <content type="html"><![CDATA[<h1 id="C-流"><a href="#C-流" class="headerlink" title="C++流"></a>C++流</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要是文件操作比较重要</p><p>用户数据不能永久保存, 程序关闭后, 数据消失. 因此需要把一些重要的东西存储在文件之中</p><p>IO: 向设备输入数据和输出数据</p><p><img src="/../0_images/C++stream/1_io%E6%B5%81.png" alt="alt text"></p><p><strong>设备：</strong></p><ul><li><p>文件</p></li><li><p>控制台</p></li><li><p>特定的数据类型(stringstream)</p></li></ul><p><strong>C++之中的IO库</strong></p><p><img src="/../0_images/C++stream/2_IO%E5%BA%93.png" alt="alt text"></p><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件流: 对文件进行读写操作头文件: &lt;fstream&gt; 类库:</p><ul><li><p>ifstream: 文件输入（读文件）</p></li><li><p>ofstream: 文件输出（写文件）</p></li><li><p>fstream: 文件输入或输出</p></li></ul><p>对文本文件流读写，打开标识(可以使用位操作 | 组合起来):</p><ul><li><p>ios::in : 读方式打开文件</p></li><li><p>ios:out : 写方式打开文件</p></li><li><p>ios::trunc : 如果此文件已经存在, 就会打开文件之前把文件长度截断为 0</p></li><li><p>ios::app : 尾部最加方式(在尾部写入)</p></li><li><p>ios::ate : 文件打开后, 定位到文件尾</p></li><li><p>ios::binary : 二进制方式(默认是文本方式)</p></li></ul><p>写文件样例(简单的写)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//也可以使用fstream, 但是fstream的默认打开方式不截断文件长度</span></span><br><span class="line">    ofstream outfile; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入姓名:&quot;</span>; </span><br><span class="line">    cin &gt;&gt; name; </span><br><span class="line">    outfile &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>; </span><br><span class="line">    cin &gt;&gt; age; </span><br><span class="line">    outfile &lt;&lt; age &lt;&lt; endl; <span class="comment">//文本文件写入</span></span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读文件样例（简单的读）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    ifstream infile; </span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    infile &gt;&gt; name; </span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    infile &gt;&gt; age;</span><br><span class="line">    cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对二进制文件流读写</strong></p><p>思考：文本文件和二进制文件的区别？</p><p>文本文件： 写数字 1， 实际写入的是 ‘1’（字符1）</p><p>二进制文件：写数字 1， 实际写入的是 整数 1（4 个字节，最低字节是 1， 高 3 个字节都是 0）写字符‘R’实际输入的还是‘R’</p><p>写二进制文件</p><p>使用文件流对象的 write 方法写入二进制数据</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    ofstream outfile; </span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;test.dat&quot;</span>, ios::out | ios::trunc | ios::binary);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入姓名:&quot;</span>; </span><br><span class="line">    cin &gt;&gt; name; </span><br><span class="line">    outfile &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>; </span><br><span class="line">    cin &gt;&gt; age; </span><br><span class="line">    outfile.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;age, <span class="built_in">sizeof</span>(age));</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读二进制文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    ifstream infile; </span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">open</span>(<span class="string">&quot;test.dat&quot;</span>, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line">    infile &gt;&gt; name; </span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过中间的制表符</span></span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    infile.<span class="built_in">read</span>(&amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;age, <span class="built_in">sizeof</span>(age));</span><br><span class="line">    cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候会用到二进制的读写：</p><ul><li><p>处理非文本数据：如图像、音频等，避免数据格式错误。</p></li><li><p>保持数据完整性：直接按内存布局存储和读取，不受字符编码等影响。(对结构体的读写)</p></li><li><p>提高读写效率：减少格式解析步骤，适合大量数据处理。</p></li><li><p>实现加密或压缩：加密和压缩算法通常基于二进制操作。</p></li><li><p>与外部程序或设备交互：满足特定协议要求。</p></li></ul><p><strong>对文件流按格式读写取数据</strong></p><p>使用 stringstream</p><p>按指定格式写文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//也可以使用fstream, 但是fstream的默认打开方式不截断文件长度</span></span><br><span class="line">    ofstream outfile; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入姓名:&quot;</span>; </span><br><span class="line">    cin &gt;&gt; name; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入年龄: &quot;</span>; </span><br><span class="line">    cin &gt;&gt; age; </span><br><span class="line"></span><br><span class="line">    stringstream s; </span><br><span class="line">    s &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\tage:&quot;</span> &lt;&lt; age &lt;&lt; endl; </span><br><span class="line">    outfile &lt;&lt; s.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读就正常的读就好了</p><h2 id="其他的一些函数"><a href="#其他的一些函数" class="headerlink" title="其他的一些函数"></a>其他的一些函数</h2><p><strong>文件状态函数</strong>(这些函数都不经常用到，但是is_open一定要记住，用于作异常处理)</p><ul><li><p>file.is_open();   &#x2F;&#x2F;判断文件打开状态，成功打开返回TRUE，否则返回FALSE</p></li><li><p>file.eof();   &#x2F;&#x2F;判断文件是否到达文件末尾，到达返回TRUE，否则返回FALSE</p></li><li><p>file.bad();   &#x2F;&#x2F;在读写过程中出错，返回TRUE，否则默认为FALSE</p></li><li><p>file.fail();    &#x2F;&#x2F;读写过程中出错，或者格式错误是返回TRUE，否则默认为FALSE</p></li><li><p>file.good();   &#x2F;&#x2F;以上函数返回TRUE时，此函数返回FALSE</p></li><li><p>file.clear();   &#x2F;&#x2F;重置上述函数的参数为默认值</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 尝试打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件已成功打开！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="type">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="keyword">while</span> (!file.<span class="built_in">eof</span>()) &#123; <span class="comment">// 判断是否到达文件末尾</span></span><br><span class="line">        <span class="built_in">getline</span>(file, line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查读取是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;读取文件时出错！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!line.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            lineCount++;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;第 &quot;</span> &lt;&lt; lineCount &lt;&lt; <span class="string">&quot; 行: &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否正常关闭</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;关闭文件时出错！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个错误状态</span></span><br><span class="line">    file.<span class="built_in">clear</span>(); <span class="comment">// 清除之前的错误状态</span></span><br><span class="line">    file.<span class="built_in">setstate</span>(ios::failbit); <span class="comment">// 设置失败状态</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;文件状态已设置为失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件状态</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">good</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件状态良好！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;文件状态异常！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件流位置函数</strong>（了解一下，需要用到的时候知道就行）</p><ul><li><p>file.tellg();</p><ul><li>返回pos_type类型的值（根据ANSI-C++标准），是一个整数，代表当前get流指针的位置（指向下一个将被读取的元素）文件打开时（非ios::ate方式）该指针指向文件开头，即0。</li></ul></li><li><p>file.tellp();  </p><ul><li>返回put流指针的位置（指向写入下一个元素的位置），注意，如果文件不是以ios::ate方式打开，该指针在文件打开时是指向文件开头的，也就是说，在写入时，会覆盖之前的文件内容。</li></ul></li><li><p>file.seekg(pos_type position); </p><ul><li>设置get流指针的位置，参数即表示第几个字符的下标</li></ul></li><li><p>file.seekg(off_typeoffset,seekdir direction);   </p><ul><li>参数一为偏移量，可正可负，参数二为偏移基址，可取的值有三个：ios::beg 输入流的开始 ios::cur 输入流的当前位置 ios::end 输入流的结束</li></ul></li><li><p>file.seekp(pos_typeposition);</p></li><li><p>file.seekp(off_type,seekdirdirection);</p></li></ul><p><strong>获取文件内容</strong>(getline比较常用)</p><p>文件以ios::in打开时，可以获取文件内容：</p><ul><li><p>file.getline(buffer,size);&#x2F;&#x2F;从文件中读取一行字符到buffer指向的缓存中</p></li><li><p>file.read(uchar *buffer, int size);&#x2F;&#x2F;从文件中读取size个字符到buffer中</p></li><li><p>int x;  file&gt;&gt;x;&#x2F;&#x2F;从文件中输入一个int值到x中（其实cin也是一个输入流文件，它指键盘）</p></li><li><p>file.get();&#x2F;&#x2F;从文件流当前位置获取一个字符并返回（默认为int，可以显式转换为char）</p></li><li><p>file.get(x);&#x2F;&#x2F;从文件中读取一个字符保存到x中</p></li><li><p>file.get(char *buf,int num ,char delim&#x3D;’n’);&#x2F;&#x2F; 这种形式把字符读入由buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’n’。例如：</p></li><li><p>file2.get(str1,127,’A’);&#x2F;&#x2F;从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 用于字符串操作</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并写入文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法创建文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;12345\n&quot;</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;This is a test line with A character A\n&quot;</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Another line.\n&quot;</span>;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.getline(buffer, size)</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用 file.getline(buffer, size) 读取一行：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    inFile.<span class="built_in">getline</span>(buffer, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.read(buffer, size)</span></span><br><span class="line">    <span class="type">char</span> buffer2[<span class="number">10</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n使用 file.read(buffer, size) 读取 10 个字符：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    inFile.<span class="built_in">read</span>(buffer2, <span class="number">10</span>);</span><br><span class="line">    buffer2[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以空字符结尾</span></span><br><span class="line">    cout &lt;&lt; buffer2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file &gt;&gt; x 读取一个 int 值</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n使用 file &gt;&gt; x 读取一个 int 值：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    inFile &gt;&gt; x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取的整数是：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.get() 读取一个字符</span></span><br><span class="line">    <span class="type">char</span> ch = inFile.<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n使用 file.get() 读取一个字符：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取的字符是：&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.get(x) 读取一个字符到变量中</span></span><br><span class="line">    <span class="type">char</span> ch2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n使用 file.get(x) 读取一个字符到变量中：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    inFile.<span class="built_in">get</span>(ch2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取的字符是：&quot;</span> &lt;&lt; ch2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.get(buffer, num, delim)</span></span><br><span class="line">    <span class="type">char</span> str1[<span class="number">127</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n使用 file.get(buffer, num, delim) 读取字符到字符串，直到遇到 &#x27;A&#x27;：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    inFile.<span class="built_in">get</span>(str1, <span class="number">127</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取的字符串是：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取文件内容</strong></p><ul><li><p>file&lt;&lt;”xxxxx”&lt;&lt;endl;&#x2F;&#x2F;将字符串“xxxxx”输出到文件中</p></li><li><p>file.put(‘a’);&#x2F;&#x2F;向文件流当前位置写入一个字符’a’</p></li><li><p>file.write(uchar *buffer,int counter); &#x2F;&#x2F;从buffer指向的缓存中写num个字符到文件中</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 用于字符串操作</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并打开文件用于写入</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file &lt;&lt; &quot;xxxxx&quot; &lt;&lt; endl; 写入字符串</span></span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;This is a test file.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.put(&#x27;a&#x27;); 写入单个字符</span></span><br><span class="line">    outFile.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    outFile.<span class="built_in">put</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    outFile.<span class="built_in">put</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    outFile &lt;&lt; endl; <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 file.write(buffer, counter); 写入缓冲区中的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* buffer = <span class="string">&quot;This is written using write()&quot;</span>;</span><br><span class="line">    <span class="type">int</span> bufferSize = <span class="built_in">strlen</span>(buffer); <span class="comment">// 获取字符串长度</span></span><br><span class="line">    outFile.<span class="built_in">write</span>(buffer, bufferSize); <span class="comment">// 写入缓冲区中的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一些额外内容</span></span><br><span class="line">    outFile &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Another line added at the end.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL</title>
      <link href="/2025/04/13/C++STL/"/>
      <url>/2025/04/13/C++STL/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的学习以下C-的STL"><a href="#简单的学习以下C-的STL" class="headerlink" title="简单的学习以下C++的STL"></a>简单的学习以下C++的STL</h1><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p>STL主要分为分为三类：</p><ul><li><p>algorithm（算法）  -   对数据进行处理(解决问题)步骤的有限集合</p></li><li><p>container（容器）  -   用来管理一组数据元素</p></li><li><p>Iterator  (迭代器) -   可遍历STL容器内全部或部分元素的对象</p></li></ul><p><strong>容器</strong></p><p>&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;</p><table><thead><tr><th>数据结构</th><th>描述</th><th>实现头文件</th></tr></thead><tbody><tr><td>向量(vector)</td><td>连续存储的元素</td><td><code>&lt;vector&gt;</code></td></tr><tr><td>列表(list)</td><td>由节点组成的双向链表，每个结点包含着一个元素</td><td><code>&lt;list&gt;</code></td></tr><tr><td>双向队列(deque)</td><td>连续存储的指向不同元素的指针所组成的数组</td><td><code>&lt;deque&gt;</code></td></tr><tr><td>集合(set)</td><td>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td><code>&lt;set&gt;</code></td></tr><tr><td>多重集合(multiset)</td><td>允许存在两个次序相等的元素的集合</td><td><code>&lt;set&gt;</code></td></tr><tr><td>栈(stack)</td><td>后进先出的元素的排列</td><td><code>&lt;stack&gt;</code></td></tr><tr><td>队列(queue)</td><td>先进先出的元素的排列</td><td><code>&lt;queue&gt;</code></td></tr><tr><td>优先队列(priority_queue)</td><td>元素的次序是由作用于所存储的值对上的某种优先级决定的一种队列</td><td><code>&lt;queue&gt;</code></td></tr><tr><td>映射(map)</td><td>由(键，值)对组成的集合，以某种作用于键对上的谓词排列</td><td><code>&lt;map&gt;</code></td></tr><tr><td>多重映射(multimap)</td><td>允许键对有相等的次序的映射</td><td><code>&lt;map&gt;</code></td></tr></tbody></table><h2 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h2><p>vector是将元素置于一个动态数组中加以管理的容器。</p><p>vector可以随机存取元素,支持索引值直接存取， 用[]操作符或at()方法对元素进行操作</p><p><img src="/../0_images/C++STL/1_vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.png" alt="alt text"></p><p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</p><p><strong>构造</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>(beg,end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span></span><br><span class="line"><span class="built_in">vector</span>(n,elem); <span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;v1);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//默认构造</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1 的元素个数: &quot;</span>&lt;&lt;v<span class="number">1.</span><span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;v1 容器的大小：&quot;</span>&lt;&lt;v<span class="number">1.</span><span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//构造时就分配空间，同时插入10个元素，元素为0</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2 的元素个数: &quot;</span>&lt;&lt;v<span class="number">2.</span><span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;v2 容器的大小：&quot;</span>&lt;&lt;v<span class="number">2.</span><span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v<span class="number">2.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;v2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">666</span>)</span></span>;  <span class="comment">//构造时就分配空间，同时插入10个元素，元素为666</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v3 的元素个数: &quot;</span>&lt;&lt;v<span class="number">3.</span><span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;v3 容器的大小：&quot;</span>&lt;&lt;v<span class="number">3.</span><span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v<span class="number">3.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;v3[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> test[]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(test, test<span class="number">+2</span>)</span></span>;  <span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v4 的元素个数: &quot;</span>&lt;&lt;v<span class="number">4.</span><span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;v4 容器的大小：&quot;</span>&lt;&lt;v<span class="number">4.</span><span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v<span class="number">4.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;v4[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector的基本操作(比较常用的)</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector 的赋值-------------------</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">assign</span>(<span class="number">2</span>, <span class="number">888</span>);               <span class="comment">//第一种玩法  改变原来vector 中的元素个数和值(个数比变成2个，值都是888)</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">assign</span>(v<span class="number">3.</span><span class="built_in">begin</span>(), v<span class="number">3.</span><span class="built_in">end</span>()); <span class="comment">//第二种玩法，使用迭代器重新赋值</span></span><br><span class="line"><span class="type">int</span> test1[]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v<span class="number">2.</span><span class="built_in">assign</span>(test1, test1<span class="number">+3</span>);       <span class="comment">//第三种玩法，使用指针赋值</span></span><br><span class="line">v2 = v3;                         <span class="comment">//第四种玩法，赋值运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector的大小-------------------</span></span><br><span class="line">vector.<span class="built_in">size</span>();       <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">vector.<span class="built_in">empty</span>();      <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector末尾的添加移除操作 --------------</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">1</span>);    <span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">pop_back</span>();      <span class="comment">//移除容器中最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector的数据存取------------</span></span><br><span class="line">v2[<span class="number">0</span>] = <span class="number">100</span>;                   <span class="comment">// 使用下标操作 </span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>;                <span class="comment">//使用at 方法 //第一和第二种方式必须注意越界</span></span><br><span class="line">v<span class="number">2.f</span>ront() 和 v<span class="number">2.</span><span class="built_in">back</span>()        <span class="comment">//接口返回的引用 v2.front() 和 v2.back() </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector的插入------------</span></span><br><span class="line">vector.<span class="built_in">insert</span>(pos,elem);      <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">vector.<span class="built_in">insert</span>(pos,n,elem);    <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">vector.<span class="built_in">insert</span>(pos,beg,end);   <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector的删除------------</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">clear</span>();                  <span class="comment">//把整个vector 都干掉</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">erase</span>(v<span class="number">2.</span><span class="built_in">begin</span>()<span class="number">+1</span>);      <span class="comment">//干掉单个元素</span></span><br><span class="line">v<span class="number">2.</span><span class="built_in">erase</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">begin</span>()<span class="number">+3</span>);  <span class="comment">//干掉多个元素</span></span><br></pre></td></tr></table></figure><p><strong>基本操作：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myVectorCopy = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;myVector 的元素个数: &quot;</span>&lt;&lt;myVector.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;myVector 容器的大小：&quot;</span>&lt;&lt;myVector.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">assign</span>(<span class="number">2</span>,<span class="number">888</span>); <span class="comment">//改变原来vector 中的元素个数和值(个数比变成2个，值都是888)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">assign</span>(myVectorCopy.<span class="built_in">begin</span>(),myVectorCopy.<span class="built_in">end</span>());  <span class="comment">//用迭代器重新赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;myVector 的元素个数: &quot;</span>&lt;&lt;myVector.<span class="built_in">size</span>()&lt;&lt;endl;       <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;myVector 是否为空: &quot;</span>&lt;&lt;myVector.<span class="built_in">empty</span>()&lt;&lt;endl;        <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">1000</span>); <span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">pop_back</span>();      <span class="comment">//移除容器中最后一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">888</span>); <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>()<span class="number">+1</span>);   <span class="comment">//干掉单个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">insert</span>(myVector.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">5</span>,<span class="number">888</span>); <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>()<span class="number">+1</span>,myVector.<span class="built_in">begin</span>()<span class="number">+6</span>);   <span class="comment">//干掉多个元素(左开右闭)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myVector.<span class="built_in">clear</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;myVector 的元素个数: &quot;</span>&lt;&lt;myVector.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;myVector 容器的大小：&quot;</span>&lt;&lt;myVector.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myVector.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myVector[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deuqe容器"><a href="#deuqe容器" class="headerlink" title="deuqe容器"></a>deuqe容器</h2><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，唯一不同的是：</p><p>deque是双端数组，而vector是单端的。</p><p><img src="/../0_images/C++STL/2_deque%E4%B8%8Evector%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="alt text"></p><p>Deque 特点：</p><ul><li><p>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p></li><li><p>deque可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法）</p></li><li><p><strong>deque头部和尾部添加或移除元素都非常快速, 但是在中部安插元素或移除元素比较费时。</strong></p></li></ul><p><strong>基本操作</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造-------------------------------</span></span><br><span class="line"><span class="built_in">deque</span>(beg,end);                   <span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);                    <span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque  &amp;deq);         <span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque头部和末尾的添加移除操作-------------------</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(element);        <span class="comment">//容器尾部添加一个数据</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(element);       <span class="comment">//容器头部插入一个数据</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();                <span class="comment">//删除容器最后一个数据</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();               <span class="comment">//删除容器第一个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque的数据存取------------------------</span></span><br><span class="line">deqIntA[<span class="number">0</span>] = <span class="number">100</span>;                  <span class="comment">//使用下标操作</span></span><br><span class="line">deqIntA.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>;               <span class="comment">// 使用at 方法</span></span><br><span class="line">deqIntA.<span class="built_in">front</span>() 和 deqIntA.<span class="built_in">back</span>()  <span class="comment">//接口返回的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque与迭代器------------------------</span></span><br><span class="line">deque.<span class="built_in">begin</span>();   <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line">deque.<span class="built_in">end</span>();     <span class="comment">//返回容器中最后一个元素之后的迭代器。（注意之后！！！）</span></span><br><span class="line">deque.<span class="built_in">rbegin</span>();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line">deque.<span class="built_in">rend</span>();    <span class="comment">//返回容器中第一个元素之前的迭代器。 （注意之前！！！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque的赋值------------------------</span></span><br><span class="line">deque.<span class="built_in">assign</span>(beg,end);    <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span></span><br><span class="line">deque.<span class="built_in">assign</span>(n,elem);     <span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符</span></span><br><span class="line">deque.<span class="built_in">swap</span>(deq);          <span class="comment">// 将deque与本身的元素互换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque的大小------------------------</span></span><br><span class="line">deque.<span class="built_in">size</span>();  <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">empty</span>();   <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque的插入------------------------</span></span><br><span class="line">deque.<span class="built_in">insert</span>(pos,elem);     <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">deque.<span class="built_in">insert</span>(pos,n,elem);   <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">deque.<span class="built_in">insert</span>(pos,beg,end);  <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deque的删除------------------------</span></span><br><span class="line">deque.<span class="built_in">clear</span>();          <span class="comment">//移除容器的所有数据</span></span><br><span class="line">deque.<span class="built_in">erase</span>(beg,end);   <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">deque.<span class="built_in">erase</span>(pos);       <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><p>很多都用不到，要记住push 迭代器，判空 getsize等基本操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; myDeque= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myDeque.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myDeque[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::iterator it = myDeque.<span class="built_in">begin</span>();it!=myDeque.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意反向迭代器的使用 it++ 不是 -- </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myDeque.<span class="built_in">rbegin</span>();it != myDeque.<span class="built_in">rend</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">8888</span>); </span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">6666</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myDeque.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myDeque[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>();</span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;myDeque.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">cout&lt;&lt;myDeque.<span class="built_in">at</span>(i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h2><p>list是一个双向链表容器，可高效地进行插入删除元素。</p><p>list不可以随机存取元素，所以不支持at.(position)函数与[]操作符。可以对其迭代器执行++，但是不能这样操作迭代器：it+3</p><p><img src="/../0_images/C++STL/3_list.png" alt="alt text"></p><p><strong>基本操作</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list对象的带参数构造--------------</span></span><br><span class="line"><span class="built_in">list</span>(beg,end);              <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(n,elem);               <span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list &amp;lst);      <span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加移除操作--------------</span></span><br><span class="line">list.<span class="built_in">push_back</span>(elem);      <span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">list.<span class="built_in">pop_back</span>();           <span class="comment">//删除容器中最后一个元素</span></span><br><span class="line">list.<span class="built_in">push_front</span>(elem);     <span class="comment">//在容器开头插入一个元素</span></span><br><span class="line">list.<span class="built_in">pop_front</span>();          <span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的数据存取--------------</span></span><br><span class="line">list.<span class="built_in">front</span>();   <span class="comment">//返回第一个元素。</span></span><br><span class="line">list.<span class="built_in">back</span>();    <span class="comment">//返回最后一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list与迭代器--------------</span></span><br><span class="line">list.<span class="built_in">begin</span>();   <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line">list.<span class="built_in">end</span>();     <span class="comment">//返回容器中最后一个元素之后的迭代器。（注意之后！！！）</span></span><br><span class="line">list.<span class="built_in">rbegin</span>();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line">list.<span class="built_in">rend</span>();    <span class="comment">//返回容器中第一个元素之前的迭代器。 （注意之前！！！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的赋值--------------</span></span><br><span class="line">list.<span class="built_in">assign</span>(beg,end);               <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line">list.<span class="built_in">assign</span>(n,elem);                <span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> list &amp;lst);   <span class="comment">//重载等号操作符。</span></span><br><span class="line">list.<span class="built_in">swap</span>(lst);                     <span class="comment">//将lst与本身的元素互换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的大小--------------</span></span><br><span class="line">list.<span class="built_in">size</span>();         <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">list.<span class="built_in">empty</span>();        <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的插入--------------</span></span><br><span class="line">list.<span class="built_in">insert</span>(pos,elem);     <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">list.<span class="built_in">insert</span>(pos,n,elem);   <span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">list.<span class="built_in">insert</span>(pos,beg,end);  <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的删除--------------</span></span><br><span class="line">list.<span class="built_in">clear</span>();          <span class="comment">//移除容器的所有数据</span></span><br><span class="line">list.<span class="built_in">erase</span>(beg,end);   <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">list.<span class="built_in">erase</span>(pos);       <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line">lst.<span class="built_in">remove</span>(elem);      <span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list的反序排列--------------</span></span><br><span class="line">list.<span class="built_in">reverse</span>();       <span class="comment">//反转链表，比如list包含1, 2, 3, 4, 5五个元素，运行此方</span></span><br></pre></td></tr></table></figure><p>要记住一些基本的操作，还有反序，还有迭代器 遍历</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; myList= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//错误！！</span></span><br><span class="line">    <span class="comment">//auto it = myList.begin();</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;*(it+2)&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">reverse</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    myList.<span class="built_in">reverse</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">6666</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">8888</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line">    myList.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不支持myList.begin() + 5 这种格式感觉有点不方便</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(++myList.<span class="built_in">begin</span>(),<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    myList.<span class="built_in">erase</span>(++myList.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator itBegin=myList.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator itEnd=myList.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">    myList.<span class="built_in">erase</span>(itBegin,itEnd);<span class="comment">//(左开右闭)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();it!=myList.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Set和multiset容器"><a href="#Set和multiset容器" class="headerlink" title="Set和multiset容器"></a>Set和multiset容器</h2><p>set和multiset是一个集合容器，其中set所包含的元素是唯一的，集合中的元素按一定的顺序排列。set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。在n个数中查找目标数的效率是 log2 n</p><p><strong>Set 和 multiset 特点</strong></p><ul><li><p>set中元素插入过程是按排序规则插入，所以不能指定插入位置。</p></li><li><p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p></li><li><p>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</p></li><li><p>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素</p></li><li><p>头文件 #include <set></p></li></ul><p><strong>基本操作：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; setInt;                     <span class="comment">//一个存放int的set容器。</span></span><br><span class="line">set&lt;<span class="type">float</span>&gt; setFloat;                 <span class="comment">//一个存放float的set容器。</span></span><br><span class="line">set&lt;string&gt; setString;               <span class="comment">//一个存放string的set容器。</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulsetInt;             <span class="comment">//一个存放int的multi set容器。</span></span><br><span class="line">multiset&lt;<span class="type">float</span>&gt; multisetFloat;       <span class="comment">//一个存放float的multi set容器。</span></span><br><span class="line">multiset&lt;string&gt; multisetString;     <span class="comment">//一个存放string的multi set容器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(beg,end);                <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;s);           <span class="comment">//拷贝构造函数。</span></span><br><span class="line"><span class="built_in">multiset</span>(beg,end);           <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">multiset</span>(<span class="type">const</span> multiset &amp;s); <span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set &amp;st);                      <span class="comment">//拷贝构造函数</span></span><br><span class="line">set&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set &amp;st);           <span class="comment">//重载等号操作符</span></span><br><span class="line">set.<span class="built_in">swap</span>(st);                            <span class="comment">//交换两个集合容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//constructorFunc.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; setIntA;</span><br><span class="line"></span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; setIntC;</span><br><span class="line">    setIntC = setIntA;<span class="comment">//1 2 3 4 5 </span></span><br><span class="line">    setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);      <span class="comment">//1 2 3 4 5 6</span></span><br><span class="line">    setIntC.<span class="built_in">swap</span>(setIntA);  <span class="comment">//交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntA.<span class="built_in">begin</span>();it!=setIntA.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntB.<span class="built_in">begin</span>();it!=setIntB.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntC.<span class="built_in">begin</span>();it!=setIntC.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>set创建的时候会有比较的过程，默认是按照升序来进行排列的，这样会调用系统自带的一些比较（double，int，float等都可以，用模板来实现）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以int为例子（这个不用我们自己来实现，系统会自动调用）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; iLeft, <span class="type">const</span> <span class="type">int</span>&amp; iRight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (iLeft&gt;iRight);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; iLeft, <span class="type">const</span> <span class="type">int</span>&amp; iRight)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (iLeft&lt;iRight);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greaterLess.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认的是less</span></span><br><span class="line">    set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setIntA;</span><br><span class="line"></span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    setIntA.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">setIntB</span>(setIntA);</span><br><span class="line">    set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setIntC;</span><br><span class="line">    setIntC = setIntA;<span class="comment">//1 2 3 4 5 </span></span><br><span class="line">    setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);      <span class="comment">//1 2 3 4 5 6</span></span><br><span class="line">    setIntC.<span class="built_in">swap</span>(setIntA);  <span class="comment">//交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntA.<span class="built_in">begin</span>();it!=setIntA.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntB.<span class="built_in">begin</span>();it!=setIntB.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setIntC.<span class="built_in">begin</span>();it!=setIntC.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果碰到一些无法比较的，我们自己定义的结构的话就会出问题，比如类 结构体等，这个时候需要我们自己定义比较函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//主要是为了比较，name啥的属性就不写了</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Student &amp; right) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getAge</span>() &lt; right.<span class="built_in">getAge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Student &amp; right) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getAge</span>() &gt; right.<span class="built_in">getAge</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;Student&gt;  setStuLess;  <span class="comment">//相当于 set&lt;student,less&lt;student&gt;&gt; （student之中定义了比较函数）</span></span><br><span class="line">    setStuLess.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">20</span>));</span><br><span class="line">    setStuLess.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">18</span>));</span><br><span class="line">    setStuLess.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">19</span>));</span><br><span class="line">    setStuLess.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">19</span>));   <span class="comment">//这个插入无效，但是没有报错，这里一定要注意</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it =  setStuLess.<span class="built_in">begin</span>();it!=setStuLess.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;<span class="built_in">getAge</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set&lt;Student,greater&lt;Student&gt;&gt;  setStuGreater;  <span class="comment">//相当于 set&lt;student,less&lt;student&gt;&gt; （student之中定义了比较函数）</span></span><br><span class="line">    setStuGreater.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">20</span>));</span><br><span class="line">    setStuGreater.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">18</span>));</span><br><span class="line">    setStuGreater.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">19</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it =  setStuGreater.<span class="built_in">begin</span>();it!=setStuGreater.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;<span class="built_in">getAge</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set插入：insert，返回一个pair   pair&lt;set&lt;int&gt;::iterator, bool&gt;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;  setInt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = setInt.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">if</span>(ret.second)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;插入 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;*ret.first&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;插入 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = setInt.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">if</span>(ret.second)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;插入 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;*ret.first&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;插入 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">begin</span>();   <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">end</span>();     <span class="comment">//返回容器中最后一个元素之后的迭代器。（注意之后！！！）</span></span><br><span class="line">set.<span class="built_in">rbegin</span>();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">rend</span>();    <span class="comment">//返回容器中第一个元素之前的迭代器。 （注意之前！！！）</span></span><br></pre></td></tr></table></figure><p>set&#x2F;multiset的大小</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">size</span>(); <span class="comment">//返回容器中元素的数目</span></span><br><span class="line">set.<span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><p>set&#x2F;multiset的删除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">clear</span>();             <span class="comment">//清除所有元素</span></span><br><span class="line">set.<span class="built_in">erase</span>(pos);     <span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">erase</span>(beg,end);   <span class="comment">//删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">erase</span>(elem);     <span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure><p>set&#x2F;multiset的查找 !!!!!!!</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">find</span>(elem);   <span class="comment">//查找elem元素，返回指向elem元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">count</span>(elem);   <span class="comment">//返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</span></span><br><span class="line">set.<span class="built_in">lower_bound</span>(elem);  <span class="comment">//返回第一个&gt;=elem元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">upper_bound</span>(elem);    <span class="comment">//  返回第一个&gt;elem元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">equal_range</span>(elem);         <span class="comment">//返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setFind.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;  setInt;</span><br><span class="line">    setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    setInt.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it1 = setInt.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;*it1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iCount = setInt.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;iCount&lt;&lt;endl;</span><br><span class="line">    iCount = setInt.<span class="built_in">count</span>(<span class="number">100</span>);</span><br><span class="line">    cout&lt;&lt;iCount&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it2 = setInt.<span class="built_in">lower_bound</span>(<span class="number">3</span>);</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it3 = setInt.<span class="built_in">upper_bound</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;*it2&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;*it3&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    pair&lt; set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">4</span>);  </span><br><span class="line">    cout&lt;&lt;*pairIt.first&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;*pairIt.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map和multimap容器"><a href="#Map和multimap容器" class="headerlink" title="Map和multimap容器"></a>Map和multimap容器</h2><p>map是标准的关联式容器，一个map里存储的元素是一个键值对序列，叫做(key,value)键值对。它提供基于key快速检索数据的能力。</p><ul><li><p>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p></li><li><p>map底层的具体实现是采用红黑树变体的平衡二叉树的数据结构。在插入操作、删除和检索操作上比vector快很多。</p></li><li><p>map可以直接存取key所对应的value，支持[]操作符，如map[key]&#x3D;value。</p></li><li><p>#include <map></p></li></ul><p><strong>multimap与map的区别：</strong></p><p>map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p><p><strong>构造</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map/multimap采用模板类实现，对象的默认构造形式：</span><br><span class="line">map&lt;T1,T2&gt; map TT;</span><br><span class="line">multimap&lt;T1,T2&gt;  multimap TT; </span><br><span class="line">如：</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">char</span>&gt; mapA;</span><br><span class="line">map&lt;string,<span class="type">float</span>&gt; mapB;</span><br></pre></td></tr></table></figure><p><strong>map和multimap对象的带参数构造</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(beg,end);     <span class="comment">//将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mapObject); <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><p><strong>map的插入与迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>( <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>) );    <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="comment">//方式一、通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(  <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>)  );</span><br><span class="line"><span class="comment">//方式二、通过pair的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">inset</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, “李四”));</span><br><span class="line"><span class="comment">//方式三、通过value_type的方式插入对象</span></span><br><span class="line">mapStu.<span class="built_in">insert</span>(  map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>)  );</span><br><span class="line"><span class="comment">//方式四、通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">4</span>] = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小七&quot;</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; mapStu;</span><br><span class="line"></span><br><span class="line">    mapStu.<span class="built_in">insert</span>( <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>) );    <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line">    <span class="comment">//方式一、通过pair的方式插入对象</span></span><br><span class="line">    mapStu.<span class="built_in">insert</span>(  <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>)  );</span><br><span class="line">    <span class="comment">//方式二、通过pair的方式插入对象</span></span><br><span class="line">    mapStu.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>));</span><br><span class="line">    <span class="comment">//方式三、通过value_type的方式插入对象</span></span><br><span class="line">    mapStu.<span class="built_in">insert</span>(  map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>)  );</span><br><span class="line">    <span class="comment">//方式四、通过数组的方式插入值</span></span><br><span class="line">    mapStu[<span class="number">4</span>] = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">    mapStu[<span class="number">5</span>] = <span class="string">&quot;小七&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=mapStu.<span class="built_in">begin</span>();it!=mapStu.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt;</p></li><li><p>第四种方法非常直观，但碰到相同的键时会进行覆盖操作。比如插入key 为4的键值时，先在mapStu中查找主键为4的项，若不存在，则将一个键为4，值为默认初始化值的对组插入到mapStu中，然后再将值修改成“赵六”。若发现已存在4这个键，则修改这个键对应的value。</p></li><li><p>string strName &#x3D; mapStu[8];   &#x2F;&#x2F;取值操作或插入操作</p></li><li><p>只有当mapStu存在8这个键时才是正确的取操作，否则会自动插入一个实例，键为8，值为默认构造时的初始化值。</p></li></ul><p><strong>迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">begin</span>();   <span class="comment">//返回容器中第一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">end</span>();     <span class="comment">//返回容器中最后一个元素之后的迭代器。（注意之后！！！）</span></span><br><span class="line">set.<span class="built_in">rbegin</span>();  <span class="comment">//返回容器中倒数第一个元素的迭代器。</span></span><br><span class="line">set.<span class="built_in">rend</span>();    <span class="comment">//返回容器中第一个元素之前的迭代器。 （注意之前！！！）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>map&#x2F;multimap 排序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;T1,T2,less&lt;T1&gt; &gt;  mapA;    <span class="comment">//该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</span></span><br><span class="line">map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;   <span class="comment">//该容器是按键的降序方式排列元素。</span></span><br><span class="line">less&lt;T1&gt;与greater&lt;T1&gt;          <span class="comment">///可以替换成其它的函数对象functor。</span></span><br><span class="line"><span class="comment">//可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对</span></span><br></pre></td></tr></table></figure><p><strong>map对象的拷贝构造与赋值</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="type">const</span> map &amp;mp);                     <span class="comment">//拷贝构造函数</span></span><br><span class="line">map&amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;mp);          <span class="comment">//重载等号操作符</span></span><br><span class="line">map.<span class="built_in">swap</span>(mp);                           <span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><p><strong>map的大小</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">size</span>();     <span class="comment">//返回容器中元素的数目</span></span><br><span class="line">map.<span class="built_in">empty</span>();    <span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><p><strong>map的删除</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">clear</span>();          <span class="comment">//删除所有元素</span></span><br><span class="line">map.<span class="built_in">erase</span>(pos);     <span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">map.<span class="built_in">erase</span>(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">map.<span class="built_in">erase</span>(key);     <span class="comment">//删除容器中key为key的对组,返回删除的对组个数</span></span><br><span class="line">Map.<span class="built_in">erase</span>(key_type *first, key_type *last)  <span class="comment">//删除数组指定的半闭半开的区间中特定的key对应的所有队组</span></span><br></pre></td></tr></table></figure><p><strong>map&#x2F;multimap的查找</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">find</span>(key);    <span class="comment">//查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</span></span><br><span class="line">map.<span class="built_in">count</span>(key);   <span class="comment">//返回容器中键值为key的对组个数。对map来说，要么是0，要么是1;对multimap来说，值&gt;=0。</span></span><br><span class="line">map.<span class="built_in">lower_bound</span>(keyElem);  <span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">map.<span class="built_in">upper_bound</span>(keyElem);  <span class="comment">// 返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">map.<span class="built_in">equal_range</span>(keyElem);  <span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</span></span><br></pre></td></tr></table></figure><p>许多用法基本上和set是一样的</p><h2 id="Queue容器（队列的-先进先出）"><a href="#Queue容器（队列的-先进先出）" class="headerlink" title="Queue容器（队列的 先进先出）"></a>Queue容器（队列的 先进先出）</h2><p>queue是队列容器，是一种“先进先出”的容器。</p><ul><li><p>默认情况下queue是利用deque容器实现的一种容器。</p></li><li><p>它只允许在队列的前端（front）进行删除操作，而在队列的后端（back）进行插入操作</p></li><li><p>#include <queue></p></li></ul><p><strong>基本用法（都比较常规）</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造------</span></span><br><span class="line">queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT;  如：</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queueInt;             <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line">queue&lt;<span class="type">float</span>&gt; queueFloat;         <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line">queue&lt;string&gt; queueString;       <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; queueList;        <span class="comment">//内部使用list 来存储队列元素的queue 容器.</span></span><br><span class="line">错误: queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; queueList; <span class="comment">//内部不能使用vector来存储队列元素     </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);                 <span class="comment">//拷贝构造函数</span></span><br><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);      <span class="comment">//重载等号操作符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// queue的push()与pop()方法---------</span></span><br><span class="line">queue.<span class="built_in">push</span>(elem);   <span class="comment">//往队尾添加元素</span></span><br><span class="line">queue.<span class="built_in">pop</span>();       <span class="comment">//从队头处移除队首元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//queue的数据存取----------</span></span><br><span class="line">queue.<span class="built_in">back</span>();   <span class="comment">//返回最后一个元素</span></span><br><span class="line">queue.<span class="built_in">front</span>();   <span class="comment">//返回第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//queue的大小-----</span></span><br><span class="line">queue.<span class="built_in">empty</span>();   <span class="comment">//判断队列是否为空</span></span><br><span class="line">queue.<span class="built_in">size</span>();      <span class="comment">//返回队列的大小</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意点：queue基本上不使用迭代器来遍历</p><ul><li>可以使用底层的实现来迭代器遍历 如：使用deque实现的队列，可以直接对deque使用迭代器遍历，但是非常不推荐(这个理论上是可以的，但是GPT里面生成的代码也有问题)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 用一个tempQueue先存储一下，然后再push进取</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; tempQueue;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> frontElement = q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; frontElement &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        tempQueue.<span class="built_in">push</span>(frontElement);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 将元素再压回原队列</span></span><br><span class="line">    <span class="keyword">while</span> (!tempQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(tempQueue.<span class="built_in">front</span>());</span><br><span class="line">        tempQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二:非常非常巧妙，利用函数的形参，来拷贝一份queue，对拷贝的queue进行pop不会影响u</span></span><br><span class="line"><span class="comment">//原来的queue，并且函数结束之后还会释放调拷贝的queue，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverseQueue</span><span class="params">(queue&lt;<span class="type">int</span>&gt; q)</span> </span>&#123; <span class="comment">// 传值创建副本</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">// 弹出副本元素，不影响原队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最推荐的，不耗费内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(std::queue&lt;<span class="type">int</span>&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> element = q.<span class="built_in">front</span>();  <span class="comment">// 获取队首元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();                   <span class="comment">// 弹出元素</span></span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理元素（此处为打印）</span></span><br><span class="line">        q.<span class="built_in">push</span>(element);           <span class="comment">// 重新插入队尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优先级队列priority-queue"><a href="#优先级队列priority-queue" class="headerlink" title="优先级队列priority_queue"></a>优先级队列priority_queue</h2><p>英雄联盟游戏里面防御塔都有一个自动攻击功能，小兵排着队进入防御塔的攻击范围，防御塔先攻击靠得最近的小兵，这时候大炮车的优先级更高（因为系统判定大炮车对于防御塔的威胁更大），所以防御塔会优先攻击大炮车。而当大炮车阵亡，剩下的全部都是普通小兵，这时候离得近的优先级越高，防御塔优先攻击距离更近的小兵。</p><p>优先队列： 它的入队顺序没有变化，但是出队的顺序是根据优先级的高低来决定的。优先级高的优先出队。</p><ul><li><p>最大值优先级队列、最小值优先级队列  </p></li><li><p>用来开发一些特殊的应用</p></li><li><p>#include <queue></p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, deque&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pqA;  <span class="comment">//使用deque 值越小，优先级越大</span></span><br><span class="line">    pqA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">pqA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pqA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;pqA.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//读取队首的元素,但元素不出列</span></span><br><span class="line">            pqA.<span class="built_in">pop</span>();           <span class="comment">//出队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack容器-栈，先进后出"><a href="#stack容器-栈，先进后出" class="headerlink" title="stack容器 (栈，先进后出)"></a>stack容器 (栈，先进后出)</h2><p>stack是堆栈容器，是一种“先进后出”的容器。</p><p><img src="/../0_images/C++STL/4_%E6%A0%88.png" alt="alt text"></p><ul><li><p>stack是基于deque容器而实现的容器。</p></li><li><p>#include <stack></p></li></ul><p>基本操作：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br><span class="line">stack的<span class="built_in">push</span>()与<span class="built_in">pop</span>()方法</span><br><span class="line">stack.<span class="built_in">push</span>(elem);   <span class="comment">//往栈头添加元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();        <span class="comment">//从栈头移除第一个元素</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkInt;        </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stkInt.<span class="built_in">pop</span>();  </span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">此时stkInt存放的元素是<span class="number">1</span>, <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">stack对象的拷贝构造与赋值</span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);             <span class="comment">//拷贝构造函数</span></span><br><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);     <span class="comment">//重载等号操作符</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>;         <span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;                       <span class="comment">//赋值</span></span><br><span class="line"> </span><br><span class="line">stack的数据存取</span><br><span class="line">stack.<span class="built_in">top</span>();       <span class="comment">//返回最后一个压入栈元素</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> iTop = stkIntA.<span class="built_in">top</span>();        <span class="comment">//3</span></span><br><span class="line">stkIntA.<span class="built_in">top</span>() = <span class="number">88</span>;               <span class="comment">//88</span></span><br><span class="line"> </span><br><span class="line">stack的大小</span><br><span class="line">stack.<span class="built_in">empty</span>();   <span class="comment">//判断堆栈是否为空</span></span><br><span class="line">stack.<span class="built_in">size</span>();        <span class="comment">//返回堆栈的大小</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkInt;</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> iSize = stkInt.<span class="built_in">size</span>();         <span class="comment">//3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Array容器"><a href="#Array容器" class="headerlink" title="Array容器"></a>Array容器</h2><p>array是将元素置于一个固定数组中加以管理的容器。</p><p>array可以随机存取元素,支持索引值直接存取， 用[]操作符或at()方法对元素进行操作，也可以使用迭代器访问</p><p>不支持动态的新增删除操作</p><p>array可以完全替代C语言中的数组，使操作数组元素更加安全！</p><p>基本操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="comment">//&lt;类型，大小&gt;</span></span><br><span class="line">array&lt;<span class="type">int</span>, 6&gt; a1;     <span class="comment">//一个存放int的array容器</span></span><br><span class="line">array&lt;<span class="type">float</span>, 6&gt; a2;   <span class="comment">//一个存放float的array容器</span></span><br><span class="line">array&lt;student, 6&gt; a3; <span class="comment">//一个存放student的array容器</span></span><br><span class="line">array&lt;<span class="type">int</span>, 6&gt; a1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//定义时同时初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//arra的赋值</span></span><br><span class="line">array 的赋值</span><br><span class="line">a<span class="number">2.</span><span class="built_in">assign</span>(<span class="number">0</span>);<span class="comment">//第一种玩法  改变原来array中的所有元素的值</span></span><br><span class="line">array&lt;<span class="type">int</span>, 6&gt; a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 6&gt; a2 ;</span><br><span class="line">a2 = a1;    <span class="comment">//第二种玩法 赋值运算，将a1 赋值给a2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//array的大小</span></span><br><span class="line">array.<span class="built_in">size</span>();        <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">array.<span class="built_in">max_size</span>(); <span class="comment">//返回容器中最大的元素个数，与size 等同</span></span><br><span class="line">array.<span class="built_in">empty</span>();   <span class="comment">//判断容器是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存取</span></span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">//第一  使用下标操作</span></span><br><span class="line">a<span class="number">1.</span><span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>; <span class="comment">//第二  使用at 方法 如: </span></span><br><span class="line">a<span class="number">2.f</span>ront() 和 a<span class="number">2.</span><span class="built_in">back</span>() <span class="comment">//第三  接口返回的引用 </span></span><br><span class="line">a<span class="number">1.</span><span class="built_in">data</span>()  <span class="comment">//第四  返回内建数组的指针 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find、find_if、find_first_of、adjacent_find、search、binary_search、lower_bound、upper_bound、equal_range</p><h3 id="C-查找算法速查表"><a href="#C-查找算法速查表" class="headerlink" title="C++ 查找算法速查表"></a>C++ 查找算法速查表</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>find</code></td><td>在范围内线性查找<strong>指定值</strong>的首次出现</td></tr><tr><td><code>find_if</code></td><td>查找第一个满足<strong>谓词条件</strong>的元素</td></tr><tr><td><code>find_first_of</code></td><td>查找范围内<strong>任意匹配指定集合</strong>的元素</td></tr><tr><td><code>adjacent_find</code></td><td>查找<strong>相邻重复元素</strong>的首次出现</td></tr><tr><td><code>search</code></td><td>在范围内查找<strong>子序列</strong>的首次出现</td></tr><tr><td><code>binary_search</code></td><td>在有序范围内通过二分查找<strong>判断值是否存在</strong>（返回布尔值）</td></tr><tr><td><code>lower_bound</code></td><td>在有序范围中找<strong>第一个不小于目标值</strong>的位置（下界）</td></tr><tr><td><code>upper_bound</code></td><td>在有序范围中找<strong>第一个大于目标值</strong>的位置（上界）</td></tr><tr><td><code>equal_range</code></td><td>在有序范围中<strong>同时获取目标值的下界和上界</strong>，返回区间范围</td></tr></tbody></table><hr><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul><li><strong>线性查找</strong>：<code>find</code>&#x2F;<code>find_if</code>&#x2F;<code>find_first_of</code>&#x2F;<code>adjacent_find</code>&#x2F;<code>search</code>（时间复杂度 O(n)）</li><li><strong>二分查找</strong>：<code>binary_search</code>&#x2F;<code>lower_bound</code>&#x2F;<code>upper_bound</code>&#x2F;<code>equal_range</code>（要求有序范围，时间复杂度 O(log n)）</li><li><strong>边界定位</strong>：<code>lower_bound</code> + <code>upper_bound</code> &#x3D; <code>equal_range</code></li><li><strong>模式匹配</strong>：<code>search</code> 用于子序列定位，<code>find_first_of</code> 用于集合元素匹配</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; subset = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find() 函数，返回迭代器（指针|位置），其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</span></span><br><span class="line">    <span class="keyword">auto</span> it_find = <span class="built_in">find</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(),<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (it_find != data.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;find(8) at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_find) &lt;&lt; endl; <span class="comment">// 输出: 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find_if()、find_if_not() 函数，根据指定的【查找规则】进行查找，在指定区域内查找第一个符合该函数要求（使函数返回 true）的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it_find_if = <span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x &gt; <span class="number">7</span>;&#125;);</span><br><span class="line">    <span class="keyword">if</span> (it_find_if != data.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;find_if(&gt;7): &quot;</span> &lt;&lt; *it_find_if &lt;&lt; <span class="string">&quot; at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_find_if) &lt;&lt; endl; <span class="comment">// 输出: 7 at pos:5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find_first_of() 函数，查找范围A中第一个与范围B中【任一元素】等价的元素的位置</span></span><br><span class="line">    <span class="keyword">auto</span> it_first_of = <span class="built_in">find_first_of</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it_first_of != data.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;find_first_of(subset) at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_first_of) &lt;&lt; endl; <span class="comment">// 输出:1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjacent_find() 函数，查找两个相邻（adjacent）的等价（identical）元素</span></span><br><span class="line">    <span class="keyword">auto</span> it_adj = <span class="built_in">adjacent_find</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it_adj != data.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;adjacent_find: &quot;</span> &lt;&lt; *it_adj &lt;&lt; <span class="string">&quot; at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_adj) &lt;&lt; endl; <span class="comment">// 输出:3 at pos:5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找子串</span></span><br><span class="line">    <span class="keyword">auto</span> it_search = <span class="built_in">search</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), subset.<span class="built_in">begin</span>(), subset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it_search != data.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;search(subset) at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_search) &lt;&lt; endl; <span class="comment">// 输出:6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对有序区间操作</span></span><br><span class="line">    <span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>()); <span class="comment">// 排序为:1 2 3 3 3 3 4 5 6 7 8 8 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary_search: 检查元素是否存在</span></span><br><span class="line">    <span class="type">bool</span> exists = <span class="built_in">binary_search</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;binary_search(6): &quot;</span> &lt;&lt; boolalpha &lt;&lt; exists &lt;&lt; endl; <span class="comment">// 输出:true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lower_bound: 第一个&gt;=5的位置</span></span><br><span class="line">    <span class="keyword">auto</span> it_low = <span class="built_in">lower_bound</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower_bound(5) at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_low) &lt;&lt; endl; <span class="comment">// 输出:7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//upper_bound: 第一个&gt;8的位置</span></span><br><span class="line">    <span class="keyword">auto</span> it_high = <span class="built_in">upper_bound</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;upper_bound(8) at pos: &quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it_high) &lt;&lt; endl; <span class="comment">// 输出:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//equal_range: 查找3的范围</span></span><br><span class="line">    <span class="keyword">auto</span> eq_pair = <span class="built_in">equal_range</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;equal_range(3): [&quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), eq_pair.first) </span><br><span class="line">         &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), eq_pair.second) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl; <span class="comment">// 输出:[2,5)</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="C-排序算法速查表"><a href="#C-排序算法速查表" class="headerlink" title="C++ 排序算法速查表"></a>C++ 排序算法速查表</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>sort</code></td><td>对范围进行<strong>快速排序</strong>（非稳定排序）</td><td>O(n log n)</td><td>通用排序&#x2F;高性能需求</td></tr><tr><td><code>stable_sort</code></td><td>对范围进行<strong>稳定排序</strong>（保持相等元素原始顺序）</td><td>O(n log² n)</td><td>需要稳定性的排序</td></tr><tr><td><code>partial_sort</code></td><td>对范围前N个元素进行排序（剩余元素无序）</td><td>O(n log k)</td><td>获取TopN元素</td></tr><tr><td><code>nth_element</code></td><td>将第N个元素放到排序位置，左侧≤它，右侧≥它</td><td>O(n)</td><td>快速查找中位数&#x2F;分位数</td></tr><tr><td><code>is_sorted</code></td><td>检查范围是否已排序</td><td>O(n)</td><td>排序状态验证</td></tr><tr><td><code>partial_sort_copy</code></td><td>将部分排序结果复制到新范围（不修改原数据）</td><td>O(n log k)</td><td>安全获取TopN</td></tr><tr><td><code>inplace_merge</code></td><td>原地合并两个<strong>已排序的连续子序列</strong></td><td>O(n log n)</td><td>归并排序实现</td></tr><tr><td><code>sort_heap</code></td><td>将堆结构转换为有序范围（会破坏堆特性）</td><td>O(n log n)</td><td>堆排序场景</td></tr></tbody></table><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 包含所有排序相关函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> i,<span class="type">int</span> v):<span class="built_in">id</span>(i),<span class="built_in">value</span>(v)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;Data&gt; items = &#123;&#123;<span class="number">1</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">9</span>&#125;, &#123;<span class="number">4</span>,<span class="number">1</span>&#125;, &#123;<span class="number">5</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort() 示例（快速排序，非稳定）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sort(): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;nums[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is sorted? &quot;</span> &lt;&lt;boolalpha&lt;&lt;<span class="built_in">is_sorted</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stable_sort() 示例（归并排序，稳定）</span></span><br><span class="line">    <span class="built_in">stable_sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [](<span class="type">const</span> Data&amp; a, <span class="type">const</span> Data&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.value &lt; b.value; <span class="comment">// 按value升序，保持相等元素的原始id顺序</span></span><br><span class="line">    &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;stable_sort():\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; items.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; items[i].id &lt;&lt; <span class="string">&quot; Val:&quot;</span> &lt;&lt; items[i].value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is sorted? &quot;</span> &lt;&lt; <span class="built_in">is_sorted</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> Data&amp; a, <span class="type">const</span> Data&amp; b) &#123; <span class="keyword">return</span> a.value &lt; b.value; &#125;) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  partial_sort() 示例（堆排序，部分排序）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">partial_sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>()<span class="number">+3</span>, vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;partial_sort() (top3 descending): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;vec[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. is_sorted() 示例（检查排序状态）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; unsorted = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before sorting: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is sorted? &quot;</span> &lt;&lt; <span class="built_in">is_sorted</span>(unsorted.<span class="built_in">begin</span>(), unsorted.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">sort</span>(unsorted.<span class="built_in">begin</span>(), unsorted.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After sorting: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is sorted? &quot;</span> &lt;&lt; <span class="built_in">is_sorted</span>(unsorted.<span class="built_in">begin</span>(), unsorted.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>replace</code></td><td>将范围内<strong>所有等于指定值</strong>的元素替换为新值</td><td>O(n)</td><td>批量替换特定值的元素</td></tr><tr><td><code>replace_if</code></td><td>将范围内<strong>满足谓词条件</strong>的元素替换为新值</td><td>O(n)</td><td>条件替换（如替换负数、特殊字符等）</td></tr><tr><td><code>replace_copy</code></td><td>复制范围元素到新容器，并将<strong>所有等于指定值</strong>的元素替换为新值</td><td>O(n)</td><td>保留原数据并生成替换副本</td></tr><tr><td><code>replace_copy_if</code></td><td>复制范围元素到新容器，并将<strong>满足谓词条件</strong>的元素替换为新值</td><td>O(n)</td><td>保留原数据并生成条件替换副本</td></tr></tbody></table><table><thead><tr><th>特征</th><th>直接替换</th><th>条件替换</th><th>保留原数据</th></tr></thead><tbody><tr><td><code>replace</code></td><td>✔️ (值匹配)</td><td>❌</td><td>❌</td></tr><tr><td><code>replace_if</code></td><td>❌</td><td>✔️ (谓词判断)</td><td>❌</td></tr><tr><td><code>replace_copy</code></td><td>✔️ (值匹配)</td><td>❌</td><td>✔️</td></tr><tr><td><code>replace_copy_if</code></td><td>❌</td><td>✔️ (谓词判断)</td><td>✔️</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">-3</span>&#125;;</span><br><span class="line">    string str = <span class="string">&quot;Hello World! C++ STL&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//replace：原地替换所有等于 10 的元素为 99 */</span></span><br><span class="line">    <span class="built_in">replace</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">10</span>, <span class="number">99</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After replace(10→99): &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//replace_if：替换字符串中的空格为下划线</span></span><br><span class="line">    <span class="built_in">replace_if</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(),[](<span class="type">char</span> c) &#123; <span class="keyword">return</span> <span class="built_in">isspace</span>(c); &#125;, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After replace_if(space→_): &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出：Hello_World!_C++_STL</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//replace_copy：复制并替换负数为 0（原容器不变）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec_copy;</span><br><span class="line">    <span class="built_in">replace_copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(vec_copy), <span class="number">-3</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vec_copy after replace_copy(-3→0): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec_copy.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; vec_copy[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//replace_copy_if：复制并替换奇数为 100</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    <span class="built_in">replace_copy_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dq),</span><br><span class="line">        [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> != <span class="number">0</span>; &#125;, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dq after replace_copy_if(odd→100): &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dq.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; dq[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="C-remove-系列函数对比表"><a href="#C-remove-系列函数对比表" class="headerlink" title="C++ remove 系列函数对比表"></a>C++ remove 系列函数对比表</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>remove</code></td><td>通过覆盖方式逻辑删除指定值的元素，返回新序列终点迭代器</td><td>O(n)</td><td>需原地删除指定值元素（需配合<code>erase</code>物理删除）</td></tr><tr><td><code>remove_if</code></td><td>通过覆盖方式逻辑删除满足谓词条件的元素，返回新序列终点迭代器</td><td>O(n)</td><td>需按条件原地删除元素（配合<code>erase</code>使用）</td></tr><tr><td><code>remove_copy</code></td><td>复制源序列到目标容器时跳过指定值的元素，返回目标容器终点迭代器</td><td>O(n)</td><td>保留原数据同时生成过滤后的新序列</td></tr><tr><td><code>remove_copy_if</code></td><td>复制源序列到目标容器时跳过满足谓词条件的元素，返回目标容器终点迭代器</td><td>O(n)</td><td>按条件生成过滤副本且不修改原数据</td></tr></tbody></table><hr><h3 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h3><ol><li><p><strong>操作方式</strong>  </p><ul><li><code>remove</code>&#x2F;<code>remove_if</code>：原地操作（直接修改原容器）  </li><li><code>remove_copy</code>&#x2F;<code>remove_copy_if</code>：生成副本（保留原数据）</li></ul></li><li><p><strong>过滤条件</strong>  </p><ul><li>值匹配：<code>remove</code>、<code>remove_copy</code>  </li><li>谓词判断：<code>remove_if</code>、<code>remove_copy_if</code></li></ul></li><li><p><strong>性能</strong>  </p><ul><li>所有函数均为线性时间复杂度，需遍历全部元素</li></ul></li></ol><p><strong>提示</strong>：关联容器（如 <code>set/map</code>）请使用其自带的 <code>erase</code> 方法，而非标准算法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove 示例：删除所有值为 2 的元素</span></span><br><span class="line">    <span class="keyword">auto</span> new_end = <span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;remove 后逻辑范围: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=new_end;it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;实际容器内容: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(new_end, vec.<span class="built_in">end</span>()); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;物理删除后容器: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove_if 示例：删除所有偶数</span></span><br><span class="line">    vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;  <span class="comment">// 重置数据</span></span><br><span class="line">    new_end = <span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;remove_if 后逻辑范围: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=new_end;it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;物理删除后容器: &quot;</span>;</span><br><span class="line">    vec.<span class="built_in">erase</span>(new_end, vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove_copy 示例：复制时跳过 3</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dest1;</span><br><span class="line">    vec = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;  <span class="comment">// 重置数据</span></span><br><span class="line">    <span class="built_in">remove_copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest1), <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;remove_copy 结果（跳过3）: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = dest<span class="number">1.</span><span class="built_in">begin</span>();it!=dest<span class="number">1.</span><span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove_copy_if 示例：复制时跳过长度超过3的字符串</span></span><br><span class="line">    vector&lt;string&gt; str_vec = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;elephant&quot;</span>, <span class="string">&quot;bee&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; dest2;</span><br><span class="line">    <span class="built_in">remove_copy_if</span>(str_vec.<span class="built_in">begin</span>(), str_vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest2),</span><br><span class="line">        [](<span class="type">const</span> string&amp; s) &#123; <span class="keyword">return</span> s.<span class="built_in">length</span>() &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;remove_copy_if 结果（跳过长度&gt;3的字符串）: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = dest<span class="number">2.</span><span class="built_in">begin</span>();it!=dest<span class="number">2.</span><span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制和合并"><a href="#复制和合并" class="headerlink" title="复制和合并"></a>复制和合并</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>copy</code></td><td>复制源序列的全部元素到目标位置</td><td>O(n)</td><td>简单复制整个序列</td></tr><tr><td><code>copy_n</code></td><td>精确复制源序列的前 N 个元素</td><td>O(n)</td><td>复制固定数量元素</td></tr><tr><td><code>copy_if</code></td><td>仅复制满足谓词条件的元素</td><td>O(n)</td><td>筛选复制（如过滤偶数、特定类型数据）</td></tr><tr><td><code>copy_backward</code></td><td>从后向前复制元素到目标容器尾部</td><td>O(n)</td><td>覆盖操作避免元素冲突（需预分配空间）</td></tr><tr><td><code>reverse_copy</code></td><td>逆序复制源序列到目标位置</td><td>O(n)</td><td>生成反向副本（如回文处理、反向遍历）</td></tr><tr><td><code>merge</code></td><td>合并两个<strong>有序序列</strong>到新容器，保持整体有序</td><td>O(m+n)</td><td>合并有序数据集（如合并日志、有序流）</td></tr><tr><td><code>inplace_merge</code></td><td>原地合并同一容器中两个<strong>相邻有序子序列</strong></td><td>O(n)</td><td>归并排序实现&#x2F;合并分段排序结果</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. copy: 复制整个序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dest1;</span><br><span class="line">    <span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest1));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dest1) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. copy_n: 复制前5个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dest2;</span><br><span class="line">    <span class="built_in">copy_n</span>(src.<span class="built_in">begin</span>(), <span class="number">5</span>, <span class="built_in">back_inserter</span>(dest2));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy_n(5) 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dest2) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. copy_if: 复制偶数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dest3;</span><br><span class="line">    <span class="built_in">copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest3),</span><br><span class="line">                 [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy_if(偶数) 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dest3) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. copy_backward: 从后向前复制到目标容器末尾</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dest4</span><span class="params">(<span class="number">8</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 目标容器需预分配空间</span></span><br><span class="line">    <span class="built_in">copy_backward</span>(src.<span class="built_in">begin</span>() + <span class="number">2</span>, src.<span class="built_in">begin</span>() + <span class="number">6</span>, dest<span class="number">4.</span><span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy_backward 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dest4) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. reverse_copy: 逆序复制</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dest5;</span><br><span class="line">    <span class="built_in">reverse_copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest5));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;reverse_copy 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : dest5) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. merge: 合并两个有序序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sorted1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sorted2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; merged;</span><br><span class="line">    <span class="built_in">merge</span>(sorted<span class="number">1.</span><span class="built_in">begin</span>(), sorted<span class="number">1.</span><span class="built_in">end</span>(), </span><br><span class="line">              sorted<span class="number">2.</span><span class="built_in">begin</span>(), sorted<span class="number">2.</span><span class="built_in">end</span>(), </span><br><span class="line">              <span class="built_in">back_inserter</span>(merged));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;merge 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : merged) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. inplace_merge: 原地合并已排序的子序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 前半部分排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>() + <span class="number">3</span>, vec.<span class="built_in">end</span>());    <span class="comment">// 后半部分排序</span></span><br><span class="line">    <span class="built_in">inplace_merge</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>, vec.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;inplace_merge 结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换、反转、移动、旋转"><a href="#交换、反转、移动、旋转" class="headerlink" title="交换、反转、移动、旋转"></a>交换、反转、移动、旋转</h2><h3 id="C-容器操作算法对比表"><a href="#C-容器操作算法对比表" class="headerlink" title="C++ 容器操作算法对比表"></a>C++ 容器操作算法对比表</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>swap</code></td><td>交换两个变量&#x2F;容器的<strong>值</strong>（支持基本类型、容器、智能指针）</td><td>O(1)</td><td>变量交换&#x2F;容器快速内容交换</td></tr><tr><td><code>swap_ranges</code></td><td>交换两个范围（range）的<strong>元素</strong>（要求长度相同）</td><td>O(n)</td><td>容器部分元素交换</td></tr><tr><td><code>reverse</code></td><td><strong>反转</strong>指定范围内的元素顺序</td><td>O(n)</td><td>逆序输出&#x2F;回文处理</td></tr><tr><td><code>rotate</code></td><td><strong>循环移动</strong>元素，使中间元素成为新起始位置</td><td>O(n)</td><td>环形缓冲区&#x2F;循环队列</td></tr><tr><td><code>move</code></td><td>转移资源所有权（右值引用转换，避免拷贝）</td><td>O(1)</td><td>资源管理&#x2F;大对象转移</td></tr><tr><td><code>unique</code></td><td>去除<strong>相邻重复</strong>元素（需先排序才能完全去重）</td><td>O(n)</td><td>数据去重&#x2F;日志过滤</td></tr></tbody></table><hr><h3 id="关键特性说明"><a href="#关键特性说明" class="headerlink" title="关键特性说明"></a>关键特性说明</h3><ol><li><p><strong><code>swap</code></strong>  </p><ul><li>容器特化版本（如 <code>vector::swap</code>）直接交换内部指针，时间复杂度为 O(1)  </li><li>示例：<code>swap(a, b)</code> 或 <code>vec1.swap(vec2)</code></li></ul></li><li><p><strong><code>swap_ranges</code></strong>  </p><ul><li>需保证两个范围长度一致，否则行为未定义  </li><li>示例：<code>swap_ranges(vec1.begin(), vec1.end(), vec2.begin())</code></li></ul></li><li><p><strong><code>rotate</code></strong>  </p><ul><li>实际效果：<code>[first, middle) ∪ [middle, last) → [middle, last) + [first, middle)</code>  </li><li>示例：<code>rotate(vec.begin(), vec.begin()+2, vec.end())</code> 左移2位</li></ul></li><li><p><strong><code>unique</code></strong>  </p><ul><li>返回去重后的新逻辑终点（需配合 <code>erase</code> 物理删除）  </li><li>示例：<code>nums.erase(unique(nums.begin(), nums.end()), nums.end())</code></li></ul></li></ol><hr><h3 id="性能对比（n-元素数量）"><a href="#性能对比（n-元素数量）" class="headerlink" title="性能对比（n&#x3D;元素数量）"></a>性能对比（n&#x3D;元素数量）</h3><table><thead><tr><th>操作</th><th>性能影响因子</th><th>典型用例</th></tr></thead><tbody><tr><td><code>swap</code></td><td>容器内部指针交换成本</td><td>快速清空容器 <code>vector&lt;int&gt;().swap(v)</code></td></tr><tr><td><code>move</code></td><td>对象移动构造函数效率</td><td><code>unique_ptr</code>&#x2F;大型对象转移</td></tr><tr><td><code>rotate</code></td><td>元素移动次数</td><td>实现约瑟夫环问题（Josephus Problem）</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// for swap and move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// for unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. swap 交换两个变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap: a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// a=20, b=10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. swap_ranges 交换两个容器的部分元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec2&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">swap_ranges</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">3</span>, vec<span class="number">2.</span><span class="built_in">begin</span>());  <span class="comment">// 交换前3个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec1) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 10 20 30 4 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nvec2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec2) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3 40 50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. reverse 反转容器</span></span><br><span class="line">    <span class="built_in">reverse</span>(vec<span class="number">1.</span><span class="built_in">begin</span>(), vec<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nReversed vec1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec1) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 5 4 30 20 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. rotate 旋转元素（将中间元素移动到起始位置）</span></span><br><span class="line">    vector&lt;string&gt; words&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">rotate</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">begin</span>() + <span class="number">2</span>, words.<span class="built_in">end</span>());  <span class="comment">// 将C移到开头</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nRotated words: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : words) cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// C D E A B</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. move 转移资源所有权（结合智能指针）</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nptr2 value: &quot;</span> &lt;&lt; *ptr2 &lt;&lt; (ptr1 ? <span class="string">&quot; (ptr1 valid)&quot;</span> : <span class="string">&quot; (ptr1 empty)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. unique 去重（需先排序）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> last = <span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(last, nums.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nUnique nums: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 1 2 3 5</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="填充、遍历"><a href="#填充、遍历" class="headerlink" title="填充、遍历"></a>填充、遍历</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>for_each</code></td><td>对范围内的每个元素<strong>应用指定函数</strong></td><td>O(n)</td><td>遍历修改&#x2F;执行副作用操作</td></tr><tr><td><code>fill</code></td><td>将指定值<strong>填充整个范围</strong></td><td>O(n)</td><td>批量初始化&#x2F;重置容器</td></tr><tr><td><code>fill_n</code></td><td>将指定值<strong>填充前N个元素</strong></td><td>O(k) (k为填充数)</td><td>局部覆盖&#x2F;部分初始化</td></tr><tr><td><code>generate</code></td><td>用生成器函数<strong>生成值填充整个范围</strong></td><td>O(n)</td><td>动态值生成（如随机数）</td></tr><tr><td><code>generate_n</code></td><td>用生成器函数<strong>生成前N个元素</strong></td><td>O(k) (k为生成数)</td><td>局部动态生成</td></tr><tr><td><code>transform</code></td><td>对输入范围应用操作，将结果<strong>写入目标范围</strong></td><td>O(n)</td><td>数据转换（如数学运算）</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个包含5个元素的向量，默认值为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用fill将整个容器填充为5</span></span><br><span class="line">    <span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. fill结果: &quot;</span>;</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用fill_n修改前2个元素为10</span></span><br><span class="line">    <span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. fill_n结果: &quot;</span>;</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用generate生成随机数（0-99）</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    <span class="built_in">generate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), []() &#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">100</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3. generate结果: &quot;</span>;</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 使用generate_n生成等差数列（100, 200, 300...）</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 初始化5个0</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">generate_n</span>(vec<span class="number">2.</span><span class="built_in">begin</span>(), <span class="number">3</span>, [&amp;start]() &#123;</span><br><span class="line">        <span class="type">int</span> current = start;</span><br><span class="line">        start += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4. generate_n结果: &quot;</span>;</span><br><span class="line">    for_each(vec<span class="number">2.</span><span class="built_in">begin</span>(), vec<span class="number">2.</span><span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用transform计算平方并存储到新容器</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(vec.size())</span></span>;</span><br><span class="line">    <span class="built_in">transform</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec<span class="number">3.</span><span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5. transform结果: &quot;</span>;</span><br><span class="line">    for_each(vec<span class="number">3.</span><span class="built_in">begin</span>(), vec<span class="number">3.</span><span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数、比较、求和、数学"><a href="#计数、比较、求和、数学" class="headerlink" title="计数、比较、求和、数学"></a>计数、比较、求和、数学</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>count</code></td><td>统计范围内<strong>等于特定值</strong>的元素数量</td><td>O(n)</td><td>精确值统计</td></tr><tr><td><code>count_if</code></td><td>统计范围内<strong>满足谓词条件</strong>的元素数量</td><td>O(n)</td><td>条件计数&#x2F;过滤统计</td></tr><tr><td><code>all_of</code></td><td>检查范围内<strong>所有元素</strong>是否都满足谓词条件</td><td>O(n)</td><td>全局条件验证（如全为正数）</td></tr><tr><td><code>any_of</code></td><td>检查范围内<strong>至少有一个元素</strong>满足谓词条件</td><td>O(n)</td><td>存在性验证（如包含负数）</td></tr><tr><td><code>none_of</code></td><td>检查范围内<strong>没有元素</strong>满足谓词条件</td><td>O(n)</td><td>反向存在性验证</td></tr><tr><td><code>max</code></td><td>返回两个值中的<strong>较大值</strong></td><td>O(1)</td><td>简单值比较</td></tr><tr><td><code>min</code></td><td>返回两个值中的<strong>较小值</strong></td><td>O(1)</td><td>简单值比较</td></tr><tr><td><code>max_element</code></td><td>返回范围内<strong>最大元素</strong>的迭代器</td><td>O(n)</td><td>容器极值查找</td></tr><tr><td><code>min_element</code></td><td>返回范围内<strong>最小元素</strong>的迭代器</td><td>O(n)</td><td>容器极值查找</td></tr><tr><td><code>abs</code></td><td>返回数值的<strong>绝对值</strong></td><td>O(1)</td><td>数值符号处理</td></tr><tr><td><code>accumulate</code></td><td>计算范围内元素的<strong>累加和</strong>（或自定义二元操作的累积结果）</td><td>O(n)</td><td>求和&#x2F;累积运算</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// 包含算法库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>    <span class="comment">// 包含accumulate</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">-2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. count：统计值为3的元素个数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count(3): &quot;</span> &lt;&lt; cnt &lt;&lt; endl;  <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. count_if：统计偶数的个数</span></span><br><span class="line">    <span class="type">int</span> even_cnt = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count_if(even): &quot;</span> &lt;&lt; even_cnt &lt;&lt; endl;  <span class="comment">// 输出3（4, -2, 0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. all_of：是否所有元素都&gt;0？</span></span><br><span class="line">    <span class="type">bool</span> all_positive = <span class="built_in">all_of</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;all_of(&gt;0): &quot;</span> &lt;&lt; boolalpha &lt;&lt; all_positive &lt;&lt; endl;  <span class="comment">// false（存在-2和0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. any_of：是否存在负数？</span></span><br><span class="line">    <span class="type">bool</span> has_negative = <span class="built_in">any_of</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &lt; <span class="number">0</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;any_of(&lt;0): &quot;</span> &lt;&lt; has_negative &lt;&lt; endl;  <span class="comment">// true（-2）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. none_of：是否所有元素都不等于10？</span></span><br><span class="line">    <span class="type">bool</span> no_ten = <span class="built_in">none_of</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x == <span class="number">10</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;none_of(==10): &quot;</span> &lt;&lt; no_ten &lt;&lt; endl;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. max/min：比较两个值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max(5,3): &quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min(5,3): &quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. max_element/min_element：找容器中的极值</span></span><br><span class="line">    <span class="keyword">auto</span> max_it = <span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> min_it = <span class="built_in">min_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_element: &quot;</span> &lt;&lt; *max_it &lt;&lt; endl;  <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_element: &quot;</span> &lt;&lt; *min_it &lt;&lt; endl;   <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. abs：绝对值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;abs(-5): &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="number">-5</span>) &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. accumulate：求和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;accumulate(sum): &quot;</span> &lt;&lt; sum &lt;&lt; endl;  <span class="comment">// 3+1+4-2+5+3+0+7 = 21</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组、排列"><a href="#分组、排列" class="headerlink" title="分组、排列"></a>分组、排列</h2><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>partition</code></td><td>根据条件将元素分为两组（不保证相对顺序）</td><td>O(n)</td><td>快速分组&#x2F;条件筛选</td><td>非稳定操作</td></tr><tr><td><code>is_partitioned</code></td><td>验证范围是否按指定条件分区</td><td>O(n)</td><td>分区状态检查</td><td>需先执行分区操作</td></tr><tr><td><code>stable_partition</code></td><td>根据条件分组并保持元素相对顺序</td><td>O(n log n)</td><td>需要保留原始顺序的分组</td><td>内存充足时使用</td></tr><tr><td><code>partition_point</code></td><td>查找已分区序列的分界点</td><td>O(log n)</td><td>定位分区边界</td><td>必须在已分区序列使用</td></tr><tr><td><code>partition_copy</code></td><td>将分区结果复制到两个不同容器</td><td>O(n)</td><td>保留原始数据的分区操作</td><td>输出迭代器需要预分配空间</td></tr><tr><td><code>next_permutation</code></td><td>将序列转换为字典序更大的排列（返回是否成功）</td><td>O(n)</td><td>全排列生成&#x2F;组合优化</td><td>通常需要先排序</td></tr><tr><td><code>prev_permutation</code></td><td>将序列转换为字典序更小的排列（返回是否成功）</td><td>O(n)</td><td>逆序全排列生成</td><td>通常需要先降序排序</td></tr><tr><td><code>is_permutation</code></td><td>判断两个序列是否为同一组元素的排列</td><td>O(n²)</td><td>排列关系验证</td><td>允许不同容器的比较</td></tr></tbody></table><table><thead><tr><th>函数</th><th>稳定性</th><th>数据修改</th><th>排序关联</th></tr></thead><tbody><tr><td><code>partition</code></td><td>否</td><td>原地</td><td>常用于预处理</td></tr><tr><td><code>stable_partition</code></td><td>是</td><td>原地</td><td>类似stable_sort</td></tr><tr><td><code>nth_element</code></td><td>否</td><td>原地</td><td>与排序相关</td></tr><tr><td><code>next_permutation</code></td><td>保持</td><td>原地</td><td>依赖排序结果</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOdd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span>; &#125; <span class="comment">// 分区条件：奇数在前，偶数在后</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; copy1, copy2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. partition 基础分区</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">partition</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), isOdd);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After partition: &quot;</span>;</span><br><span class="line">    <span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nPartition point: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. is_partitioned 验证分区</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is partitioned? &quot;</span> </span><br><span class="line">              &lt;&lt; (<span class="built_in">is_partitioned</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), isOdd) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. stable_partition 稳定分区（保留原始顺序）</span></span><br><span class="line">    data = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>&#125;; <span class="comment">// 重置数据</span></span><br><span class="line">    <span class="keyword">auto</span> it_stable = <span class="built_in">stable_partition</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), isOdd);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After stable_partition: &quot;</span>;</span><br><span class="line">    <span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nStable partition point: &quot;</span> &lt;&lt; *it_stable &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. partition_point 查找分界点</span></span><br><span class="line">    <span class="keyword">auto</span> pp = <span class="built_in">partition_point</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), isOdd);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Partition point via partition_point: &quot;</span> &lt;&lt; *pp &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. partition_copy 分区复制</span></span><br><span class="line">    <span class="built_in">partition_copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(),</span><br><span class="line">                       <span class="built_in">back_inserter</span>(copy1), <span class="comment">// 奇数容器</span></span><br><span class="line">                       <span class="built_in">back_inserter</span>(copy2), <span class="comment">// 偶数容器</span></span><br><span class="line">                       isOdd);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Odd elements: &quot;</span>;</span><br><span class="line">    <span class="built_in">copy</span>(copy<span class="number">1.</span><span class="built_in">begin</span>(), copy<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nEven elements: &quot;</span>;</span><br><span class="line">    <span class="built_in">copy</span>(copy<span class="number">2.</span><span class="built_in">begin</span>(), copy<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. next_permutation 下一个排列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; perm&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;All permutations (ascending):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">copy</span>(perm.<span class="built_in">begin</span>(), perm.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; → &quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(perm.<span class="built_in">begin</span>(), perm.<span class="built_in">end</span>()));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. prev_permutation 上一个排列</span></span><br><span class="line">    <span class="built_in">sort</span>(perm.<span class="built_in">rbegin</span>(), perm.<span class="built_in">rend</span>()); <span class="comment">// 先降序排序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;All permutations (descending):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">copy</span>(perm.<span class="built_in">begin</span>(), perm.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; → &quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">prev_permutation</span>(perm.<span class="built_in">begin</span>(), perm.<span class="built_in">end</span>()));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. is_permutation 验证排列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; test1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, test2&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, test3&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is permutation (1-2-3 vs 3-2-1): &quot;</span> </span><br><span class="line">              &lt;&lt; boolalpha &lt;&lt; <span class="built_in">is_permutation</span>(test<span class="number">1.</span><span class="built_in">begin</span>(), test<span class="number">1.</span><span class="built_in">end</span>(), test<span class="number">2.</span><span class="built_in">begin</span>())</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\nIs permutation (1-2-3 vs 1-2-4): &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">is_permutation</span>(test<span class="number">1.</span><span class="built_in">begin</span>(), test<span class="number">1.</span><span class="built_in">end</span>(), test<span class="number">3.</span><span class="built_in">begin</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ socket</title>
      <link href="/2025/04/13/C++socket/"/>
      <url>/2025/04/13/C++socket/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Socket"><a href="#C-Socket" class="headerlink" title="C++Socket"></a>C++Socket</h1><p>学习资料：<a href="https://subingwen.cn/linux/socket/">https://subingwen.cn/linux/socket/</a></p><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将TCP&#x2F;IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件sys&#x2F;socket.h中。</p><p>通过上面的描述可以得知，套接字对应程序猿来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。网络通信的主体主要分为两部分：<strong>客户端和服务器端</strong>。在客户端和服务器通信的时候需要频繁提到三个概念：<strong>IP、端口、通信数据</strong></p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p><p>大端与小端</p><p><img src="/../0_images/C++socket/1_%E5%AD%97%E8%8A%82%E5%BA%8F.png" alt="alt text"></p><p>Little-Endian -&gt; 主机字节序 (小端)</p><ul><li>数据的 低位字节 存储到内存的 低地址位, 数据的 高位字节 存储到内存的 高地址位</li><li>我们使用的PC机，数据的存储默认使用的是小端</li></ul><p>Big-Endian -&gt; 网络字节序 (大端)</p><ul><li>数据的 低位字节 存储到内存的 高地址位, 数据的 高位字节 存储到内存的 低地址位</li><li>套接字通信过程中操作的数据都是大端存储的，包括：接收&#x2F;发送的数据、IP地址、端口。</li></ul><p><img src="/../0_images/C++socket/2_%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%BE%E4%BE%8B.png" alt="alt text"></p><p>函数：</p><p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// u:unsigned</span></span><br><span class="line"><span class="comment">// 16: 16位, 32:32位</span></span><br><span class="line"><span class="comment">// h: host, 主机字节序</span></span><br><span class="line"><span class="comment">// n: net, 网络字节序</span></span><br><span class="line"><span class="comment">// s: short</span></span><br><span class="line"><span class="comment">// l: int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换</span></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><p>虽然IP地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述，下面的函数描述了如何将一个字符串类型的IP地址进行大小端转换：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主机字节序的IP地址转换为网络字节序</span></span><br><span class="line"><span class="comment">// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>; </span><br><span class="line"></span><br><span class="line">af: 地址族(IP地址的家族包括ipv4和ipv6)协议</span><br><span class="line">    AF_INET: ipv4格式的ip地址</span><br><span class="line">    AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 对应要转换的点分十进制的ip地址: <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line">dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</span><br><span class="line">返回值：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>或者<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整形数, 转换为小端的点分十进制的IP地址        </span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">af: 地址族协议</span><br><span class="line">    AF_INET: ipv4格式的ip地址</span><br><span class="line">    AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</span><br><span class="line">dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</span><br><span class="line">size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</span><br><span class="line">返回值:成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串,失败: <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">还有一组函数也能进程IP地址大小端的转换，但是只能处理ipv4的ip地址（但是一般IPV4用的多一些）：</span><br><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="sockaddr-数据结构"><a href="#sockaddr-数据结构" class="headerlink" title="sockaddr 数据结构"></a>sockaddr 数据结构</h2><p><img src="/../0_images/C++socket/3_sockaddr%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在写数据的时候不好用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line"><span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, ipv4</span></span><br><span class="line"><span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="built_in">sizeof</span>(sin_family) -</span><br><span class="line">               <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h2 id="套接字函数-socket"><a href="#套接字函数-socket" class="headerlink" title="套接字函数 socket"></a>套接字函数 socket</h2><p>使用套接字通信函数需要包含头文件&lt;arpa&#x2F;inet.h&gt;，包含了这个头文件&lt;sys&#x2F;socket.h&gt;就不用在包含了。</p><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">domain: 使用的地址族协议</span><br><span class="line">    AF_INET: 使用IPv4格式的ip地址</span><br><span class="line">    AF_INET6: 使用IPv6格式的ip地址</span><br><span class="line">type:</span><br><span class="line">    SOCK_STREAM: 使用流式的传输协议</span><br><span class="line">    SOCK_DGRAM: 使用报式(报文)的传输协议</span><br><span class="line">protocol: 一般写<span class="number">0</span>即可, 使用默认的协议</span><br><span class="line">    SOCK_STREAM: 流式传输默认使用的是tcp</span><br><span class="line">    SOCK_DGRAM: 报式传输默认使用的udp</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">成功: 可用于套接字通信的文件描述符，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</p><h3 id="将文件描述符和本地的IP与端口进行绑定"><a href="#将文件描述符和本地的IP与端口进行绑定" class="headerlink" title="将文件描述符和本地的IP与端口进行绑定"></a>将文件描述符和本地的IP与端口进行绑定</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符和本地的IP与端口进行绑定   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    sockfd: 监听的文件描述符, 通过<span class="built_in">socket</span>()调用得到的返回值</span><br><span class="line">    addr: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</span><br><span class="line">    addrlen: 参数addr指向的内存大小, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)</span><br><span class="line">返回值：成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="给监听的套接字设置监听"><a href="#给监听的套接字设置监听" class="headerlink" title="给监听的套接字设置监听"></a>给监听的套接字设置监听</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给监听的套接字设置监听</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    sockfd: 文件描述符, 可以通过调用<span class="built_in">socket</span>()得到，在监听之前必须要绑定 <span class="built_in">bind</span>()</span><br><span class="line">    backlog: 同时能处理的最大连接要求，最大值为<span class="number">128</span></span><br><span class="line">返回值：</span><br><span class="line">    函数调用成功返回<span class="number">0</span>，调用失败返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="等待并接受客户端的连接请求-建立新的连接-会得到一个新的文件描述符-通信的"><a href="#等待并接受客户端的连接请求-建立新的连接-会得到一个新的文件描述符-通信的" class="headerlink" title="等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)"></a>等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    sockfd: 监听的文件描述符</span><br><span class="line">    addr: 传出参数, 里边存储了建立连接的客户端的地址信息</span><br><span class="line">    addrlen: 传入传出参数，用于存储addr指向的内存大小</span><br><span class="line">返回值：函数调用成功，得到一个文件描述符, 用于和建立连接的这个客户端通信，调用失败返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    sockfd: 用于通信的文件描述符, <span class="built_in">accept</span>() 函数的返回值</span><br><span class="line">    buf: 指向一块有效内存, 用于存储接收是数据</span><br><span class="line">    size: 参数buf指向的内存的容量</span><br><span class="line">    flags: 特殊的属性, 一般不使用, 指定为 <span class="number">0</span></span><br><span class="line">返回值:</span><br><span class="line">    大于<span class="number">0</span>：实际接收的字节数</span><br><span class="line">    等于<span class="number">0</span>：对方断开了连接</span><br><span class="line">    <span class="number">-1</span>：接收数据失败了</span><br></pre></td></tr></table></figure><p>如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据，当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。</p><h3 id="发送数据的函数"><a href="#发送数据的函数" class="headerlink" title="发送数据的函数"></a>发送数据的函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送数据的函数</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    fd: 通信的文件描述符, <span class="built_in">accept</span>() 函数的返回值</span><br><span class="line">    buf: 传入参数, 要发送的字符串</span><br><span class="line">    len: 要发送的字符串的长度</span><br><span class="line">    flags: 特殊的属性, 一般不使用, 指定为 <span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">    大于<span class="number">0</span>：实际发送的字节数，和参数len是相等的</span><br><span class="line">    <span class="number">-1</span>：发送数据失败了</span><br></pre></td></tr></table></figure><h3 id="客户端申请连接"><a href="#客户端申请连接" class="headerlink" title="客户端申请连接"></a>客户端申请连接</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功连接服务器之后, 客户端会自动随机绑定一个端口</span></span><br><span class="line"><span class="comment">// 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    sockfd: 通信的文件描述符, 通过调用<span class="built_in">socket</span>()函数就得到了</span><br><span class="line">    addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个IP和端口也需要转换为大端然后再赋值</span><br><span class="line">    addrlen: addr指针指向的内存的大小 <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)</span><br><span class="line">返回值：连接成功返回<span class="number">0</span>，连接失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><ul><li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li><li>安全：tcp通信过程中，会对发送的每一数据包都会进行校验, 如果发现数据丢失, 会自动重传</li><li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致</li></ul><p><img src="/../0_images/C++socket/4_TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png" alt="alt text"></p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建用于监听的套接字, 这个套接字是一个文件描述符</span></span><br><span class="line"><span class="type">int</span> lfd = <span class="built_in">socket</span>();</span><br><span class="line"><span class="comment">//2.将得到的监听的文件描述符和本地的IP 端口进行绑定</span></span><br><span class="line"><span class="built_in">bind</span>();</span><br><span class="line"><span class="comment">//3.设置监听(成功之后开始监听, 监听的是客户端的连接)</span></span><br><span class="line"><span class="built_in">listen</span>();</span><br><span class="line"><span class="comment">//4.等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)，没有新连接请求就阻塞</span></span><br><span class="line"><span class="type">int</span> cfd = <span class="built_in">accept</span>();</span><br><span class="line"><span class="comment">//5.通信，读写操作默认都是阻塞的</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="built_in">read</span>(); / <span class="built_in">recv</span>();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="built_in">write</span>(); / <span class="built_in">send</span>();</span><br><span class="line"><span class="comment">//6.断开连接, 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>在tcp的服务器端, 有两类文件描述符</p><p>监听的文件描述符 </p><ul><li>只需要有一个</li><li>不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接</li></ul><p>通信的文件描述符</p><ul><li>负责和建立连接的客户端通信</li><li>如果有N个客户端和服务器建立了新的连接, 通信的文件描述符就有N个，每个客户端和服务器都对应一个通信的文件描述符</li></ul><p><img src="/../0_images/C++socket/5_%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="alt text"></p><p>文件描述符对应的内存结构：</p><ul><li>一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</li><li>读数据: 通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</li><li>写数据: 通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</li></ul><p>监听的文件描述符:</p><ul><li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据, 说明有新的客户端连接</li><li>调用accept()函数, 这个函数会检测监听文件描述符的读缓冲区<ul><li>检测不到数据, 该函数阻塞</li><li>如果检测到数据, 解除阻塞, 新的连接建立</li></ul></li></ul><p>通信的文件描述符:</p><ul><li>客户端和服务器端都有通信的文件描述符</li><li>发送数据：调用函数 write() &#x2F; send()，数据进入到内核中<ul><li>数据并没有被发送出去, 而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据, 内核会将数据发送到网络中</li></ul></li><li>接收数据: 调用的函数 read() &#x2F; recv(), 从内核读数据<ul><li>数据如何进入到内核程序猿不需要处理, 数据进入到通信的文件描述符的读缓冲区中</li><li>数据进入到内核, 必须使用通信的文件描述符, 将数据从读缓冲区中读出即可</li></ul></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个通信的套接字</span></span><br><span class="line"><span class="type">int</span> cfd = <span class="built_in">socket</span>();</span><br><span class="line"><span class="comment">//2.连接服务器, 需要知道服务器绑定的IP和端口</span></span><br><span class="line"><span class="built_in">connect</span>();</span><br><span class="line"><span class="comment">//3.通信</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="built_in">read</span>(); / <span class="built_in">recv</span>();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="built_in">write</span>(); / <span class="built_in">send</span>();</span><br><span class="line"><span class="comment">//4.断开连接, 关闭文件描述符(套接字)</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h2 id="UDP通信流程"><a href="#UDP通信流程" class="headerlink" title="UDP通信流程"></a>UDP通信流程</h2><p><img src="/../0_images/C++socket/6_UDP%E9%80%9A%E4%BF%A1.png" alt="alt text"></p><p><del>这里就不过多介绍了，基本流程可以仿照上一节之中的TCP</del></p><p>这里找的资料好像主要介绍的是TCP的通信，UDP的通信好像没做介绍</p><p>但是其实都是差不多的，只不过发送和接收的函数不一样，因为毕竟是五连接的通信</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd: 套接字描述符。</span><br><span class="line">    buf: 待发送数据的缓冲区。</span><br><span class="line">    len: 数据长度。</span><br><span class="line">    flags: 控制标志（通常为<span class="number">0</span>）。</span><br><span class="line">    dest_addr: 目标地址结构体指针（如IPv4用sockaddr_in）。</span><br><span class="line">    addrlen: 目标地址结构体的长度。</span><br><span class="line">返回值：</span><br><span class="line">    大于<span class="number">0</span>：实际发送的字节数，和参数len是相等的</span><br><span class="line">    <span class="number">-1</span>：发送数据失败了</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    sockfd: 套接字描述符。</span><br><span class="line">    buf: 接收数据的缓冲区。</span><br><span class="line">    len: 缓冲区最大长度。</span><br><span class="line">    flags: 控制标志（通常为<span class="number">0</span>）。</span><br><span class="line">    src_addr: 来源地址结构体指针（用于保存发送方地址）。</span><br><span class="line">    addrlen: 输入时为地址结构体的最大长度，输出时为实际长度。</span><br><span class="line">返回值：</span><br><span class="line">    大于<span class="number">0</span>：实际发送的字节数，和参数len是相等的</span><br><span class="line">    <span class="number">-1</span>：发送数据失败了</span><br><span class="line">注意：这里的最后两个参数可以为<span class="literal">NULL</span>表示：函数正常接收数据，但不保存发送方的地址信息。适用于不需要知道数据来源的场景（如单向通信）。</span><br><span class="line"></span><br><span class="line">一般情况下：服务端会先调用recvfrom函数，获取客户端的src_addr以及addrlen，然后处理之后再调用sendto函数给客户端发送信息(sendto必须提供src_addr与addrlen参数)</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建用于监听的套接字, 这个套接字是一个文件描述符</span></span><br><span class="line"><span class="type">int</span> lfd = <span class="built_in">socket</span>();</span><br><span class="line"><span class="comment">//2.将得到的监听的文件描述符和本地的IP 端口进行绑定</span></span><br><span class="line"><span class="built_in">bind</span>();</span><br><span class="line"><span class="comment">//3.接收发送数据</span></span><br><span class="line">recvfrom / sendto</span><br><span class="line"><span class="comment">//4.断开连接, 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建用于监听的套接字, 这个套接字是一个文件描述符</span></span><br><span class="line"><span class="type">int</span> lfd = <span class="built_in">socket</span>();</span><br><span class="line"><span class="comment">//2.接收发送数据</span></span><br><span class="line">recvfrom / sendto</span><br><span class="line"><span class="comment">//3.断开连接, 关闭套接字</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>在Window中也提供了套接字通信的API，这些API函数与Linux平台的API函数几乎相同，以至于很多人认为套接字通信的API函数库只有一套，下面来看一下这些Windows平台的套接字函数：</p><h3 id="初始化套接字环境"><a href="#初始化套接字环境" class="headerlink" title="初始化套接字环境"></a>初始化套接字环境</h3><p>使用Windows中的套接字函数需要额外包含对应的头文件以及加载响应的动态库：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用包含的头文件 </span></span><br><span class="line">include &lt;winsock<span class="number">2.</span>h&gt;</span><br><span class="line"><span class="comment">// 使用的套接字库 </span></span><br><span class="line">ws2_<span class="number">32.</span>dll       </span><br></pre></td></tr></table></figure><p>在Windows中使用套接字需要先加载套接字库（套接字环境），最后需要释放套接字资源。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化Winsock库</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR。</span></span><br><span class="line"><span class="built_in">WSAStartup</span>(WORD wVersionRequested, LPWSADATA lpWSAData);</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">wVersionRequested: 使用的Windows Socket的版本, 一般使用的版本是 <span class="number">2.2</span></span><br><span class="line">    初始化这个 <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);参数</span><br><span class="line">lpWSAData：一个WSADATA结构指针, 这是一个传入参数</span><br><span class="line">    创建一个 WSADATA 类型的变量, 将地址传递给该函数的第二个参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注销Winsock相关库，函数调用成功返回<span class="number">0</span>，失败返回 SOCKET_ERROR。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span> <span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WSAData wsa;</span><br><span class="line"><span class="comment">// 初始化套接字库</span></span><br><span class="line"><span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注销Winsock相关库</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br></pre></td></tr></table></figure><h3 id="套接字通信函数"><a href="#套接字通信函数" class="headerlink" title="套接字通信函数"></a>套接字通信函数</h3><p>基于Linux的套接字通信流程是最全面的一套通信流程，如果是在某个框架中进行套接字通信，通信流程只会更简单，直接使用window的套接字api进行套接字通信，和Linux平台上的通信流程完全相同。</p><p>结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/////////////////////////////// Windows ///////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">　　<span class="keyword">union</span> &#123;</span><br><span class="line">　　<span class="keyword">struct</span>&#123; <span class="type">unsigned</span> <span class="type">char</span> s_b1,s_b2, s_b3,s_b4;&#125; S_un_b;</span><br><span class="line">　　<span class="keyword">struct</span>&#123; <span class="type">unsigned</span> <span class="type">short</span> s_w1, s_w2;&#125; S_un_w;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span> S_addr;<span class="comment">// 存储IP地址</span></span><br><span class="line">　　&#125; S_un;</span><br><span class="line">&#125;IN_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">　　<span class="type">short</span> <span class="type">int</span> sin_family; <span class="comment">/* Address family */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/* Port number */</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* Internet address */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* Same size as struct sockaddr */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////// Linux ////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;     <span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="built_in">sizeof</span>(sin_family) -</span><br><span class="line">                      <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>大小端转换函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="function">u_short <span class="title">htons</span> <span class="params">(u_short hostshort )</span></span>;</span><br><span class="line"><span class="function">u_long <span class="title">htonl</span> <span class="params">( u_long hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="function">u_short <span class="title">ntohs</span> <span class="params">(u_short netshort )</span></span>;</span><br><span class="line"><span class="function">u_long <span class="title">ntohl</span> <span class="params">( u_long netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux函数, window上没有这两个函数</span></span><br><span class="line"><span class="built_in">inet_ntop</span>(); </span><br><span class="line"><span class="built_in">inet_pton</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// windows 和 linux 都使用, 只能处理ipv4的ip地址</span></span><br><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> FAR * cp)</span></span>;<span class="comment">// windows</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span>     <span class="title">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;<span class="comment">// linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="comment">// window, linux相同</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>套接字函数</p><p>window的api中套接字对应的类型是 SOCKET 类型, linux中是 int 类型, 本质是一样的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回套接字, 失败返回INVALID_SOCKET</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af,<span class="type">int</span> type,<span class="type">int</span> protocal)</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    - af: 地址族协议</span><br><span class="line">        - ipv4: <span class="built_in">AF_INET</span> (windows/linux)</span><br><span class="line">        - <span class="built_in">PF_INET</span> (windows)</span><br><span class="line">        - AF_INET == PF_INET</span><br><span class="line">   - type: 和linux一样</span><br><span class="line">       - SOCK_STREAM</span><br><span class="line">        - SOCK_DGRAM</span><br><span class="line">   - protocal: 一般写<span class="number">0</span> 即可</span><br><span class="line">       - 在windows上的另一种写法</span><br><span class="line">           - IPPROTO_TCP, 使用指定的流式协议中的tcp协议</span><br><span class="line">           - IPPROTO_UDP, 使用指定的报式协议中的udp协议</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关键字: FAR NEAR, 这两个关键字在32/64位机上是没有意义的, 指定的内存的寻址方式</span></span><br><span class="line"><span class="comment">// 套接字绑定本地IP和端口</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">bind</span>(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name, <span class="type">int</span> namelen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(SOCKET s,<span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待并接受客户端连接</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回用于的套接字，失败返回INVALID_SOCKET。</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span> <span class="params">( SOCKET s, <span class="keyword">struct</span> sockaddr FAR* addr, <span class="type">int</span> FAR* addrlen )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR* name,<span class="type">int</span> namelen )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Qt中connect用户信号槽的连接, 如果要使用windows api 中的 connect 需要在函数名前加::</span></span><br><span class="line">::<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功时返回接收的字节数，收到EOF时为0，失败时返回SOCKET_ERROR。</span></span><br><span class="line"><span class="comment">//==0 代表对方已经断开了连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span> <span class="params">(SOCKET s,<span class="type">char</span> FAR* buf,<span class="type">int</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回传输字节数，失败返回SOCKET_ERROR。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span> <span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR * buf, <span class="type">int</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closesocket</span> <span class="params">(SOCKET s)</span></span>;<span class="comment">// 在linux中使用的函数是: int close(int fd);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------- udp 通信函数 -------------------------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recvfrom</span><span class="params">(SOCKET s,<span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">struct</span> sockaddr FAR *from,<span class="type">int</span> FAR *fromlen)</span></span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sendto</span><span class="params">(SOCKET s,<span class="type">const</span> <span class="type">char</span> FAR *buf,<span class="type">int</span> len,<span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR *to,<span class="type">int</span> tolen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="基础练习"><a href="#基础练习" class="headerlink" title="基础练习"></a>基础练习</h2><p>好了，你现在已经学会了基本的东西了，现在开始联系把</p><p>TCP练习</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serverFd,clientFd;                     <span class="comment">//定义服务端和客户端的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr,clientAddr;  <span class="comment">//定义服务端和客户端的地址</span></span><br><span class="line">    <span class="type">socklen_t</span> addrLength = <span class="built_in">sizeof</span>(clientAddr); <span class="comment">//serverAddr和clientAddr大小 后面传参要用</span></span><br><span class="line">    <span class="type">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;                   <span class="comment">//定义接受缓冲区的buf</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    serverFd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (serverFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建套接字失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化地址</span></span><br><span class="line">    serverAddr.sin_family = AF_INET; <span class="comment">//IPV4</span></span><br><span class="line">    serverAddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">//自动获取IP地址</span></span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);               <span class="comment">//设置端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址和端口号可以重复使用(非必须)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setsockopt</span>(serverFd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="built_in">sizeof</span>(optval)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;设置地址和端口号可以重复使用失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(serverFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serverFd,(<span class="keyword">struct</span> sockaddr*)&amp;serverAddr,addrLength) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绑定失败！返回的失败编号为: -2&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(serverFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听 //允许连接的最大值为10</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serverFd,<span class="number">10</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;监听失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(serverFd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;等待客户端连接 accept 会阻塞线程&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制while循环，如果要一直不停的监听就直接while(true)就行了，根据业务功能做复杂的控制</span></span><br><span class="line">    <span class="type">int</span> whileCotr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(whileCotr!=<span class="number">0</span>)&#123;</span><br><span class="line">        whileCotr--;</span><br><span class="line">        <span class="comment">//接受连接</span></span><br><span class="line">        clientFd = <span class="built_in">accept</span>(serverFd,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,&amp;addrLength);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;接受连接失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(serverFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受客户端的返回数据 也会阻塞</span></span><br><span class="line">        <span class="type">int</span> recv_len = <span class="built_in">recv</span>(clientFd,Buf,BUF_LEN,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(recv_len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;接受客户端的whileCotr数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(serverFd);</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;客户端发送过来的数据为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;Buf&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="type">int</span> send_len = <span class="built_in">send</span>(clientFd, Buf, recv_len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(send_len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发送数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(serverFd);</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭客户端套接字</span></span><br><span class="line">        <span class="built_in">close</span>(clientFd);</span><br><span class="line">        <span class="comment">//清空缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serverFd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientFd;</span><br><span class="line">    <span class="type">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;  <span class="comment">//总得知道自己要连接的目标吧</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建套接字</span></span><br><span class="line">    clientFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建套接字失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制while循环，如果要一直不停的监听就直接while(true)就行了，根据业务功能做复杂的控制</span></span><br><span class="line">    <span class="type">int</span> whileCotr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(whileCotr!=<span class="number">0</span>)&#123;</span><br><span class="line">        whileCotr--;</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">connect</span>(clientFd,(<span class="keyword">struct</span> sockaddr*) &amp;serverAddr,<span class="built_in">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;连接到服务器失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;Buf;</span><br><span class="line">        <span class="comment">//发送数据到服务端</span></span><br><span class="line">        <span class="type">int</span> send_len = <span class="built_in">send</span>(clientFd,Buf,<span class="built_in">strlen</span>(Buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(send_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发送数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> recv_len = <span class="built_in">recv</span>(clientFd, Buf, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(recv_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;接受数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;服务端发送过来的数据为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;Buf&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clientFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> serverFd;                     <span class="comment">//定义服务端和客户端的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr,clientAddr;  <span class="comment">//定义服务端和客户端的地址</span></span><br><span class="line">    <span class="type">socklen_t</span> addrLength = <span class="built_in">sizeof</span>(clientAddr); <span class="comment">//serverAddr和clientAddr大小 后面传参要用</span></span><br><span class="line">    <span class="type">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;                   <span class="comment">//定义接受缓冲区的buf</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    serverFd = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (serverFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建套接字失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化地址</span></span><br><span class="line">    serverAddr.sin_family = AF_INET; <span class="comment">//IPV4</span></span><br><span class="line">    serverAddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">//自动获取IP地址</span></span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);               <span class="comment">//设置端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址和端口号可以重复使用(非必须)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setsockopt</span>(serverFd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="built_in">sizeof</span>(optval)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;设置地址和端口号可以重复使用失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(serverFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serverFd,(<span class="keyword">struct</span> sockaddr*)&amp;serverAddr,addrLength) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;绑定失败！返回的失败编号为: -2&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(serverFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;服务器启动，等待客户端数据...&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> whileCotr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(whileCotr!=<span class="number">0</span>)&#123;</span><br><span class="line">        whileCotr--;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> recv_len = <span class="built_in">recvfrom</span>(serverFd,Buf,BUF_LEN,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,&amp;addrLength);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(recv_len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;接受客户端的数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(serverFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;客户端发送过来的数据为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;Buf&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> send_len = <span class="built_in">sendto</span>(serverFd, Buf, <span class="built_in">strlen</span>(Buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clientAddr, addrLength);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(send_len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发送数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(serverFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serverFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientFd;</span><br><span class="line">    <span class="type">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;  <span class="comment">//总得知道自己要连接的目标吧</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    clientFd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建套接字失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器地址</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制while循环，如果要一直不停的监听就直接while(true)就行了，根据业务功能做复杂的控制</span></span><br><span class="line">    <span class="type">int</span> whileCotr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(whileCotr!=<span class="number">0</span>)&#123;</span><br><span class="line">        whileCotr--;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;Buf;</span><br><span class="line">        <span class="comment">//发送数据到服务端</span></span><br><span class="line">        <span class="type">int</span> send_len = <span class="built_in">sendto</span>(clientFd,Buf,<span class="built_in">strlen</span>(Buf),<span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddr,<span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">        <span class="keyword">if</span>(send_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发送数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> recv_len = <span class="built_in">recvfrom</span>(clientFd, Buf, BUF_LEN, <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(recv_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;接受数据失败!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">close</span>(clientFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;服务端发送过来的数据为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;Buf&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(clientFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++polymorphism</title>
      <link href="/2025/04/13/C++polymorphism/"/>
      <url>/2025/04/13/C++polymorphism/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>允许一个接口被多种不同的实现使用</p><p>虚函数，实现多态。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;到 KTV 唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;一起打王者吧！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">party</span><span class="params">(Father **men, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        men[i]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Father father;</span><br><span class="line">    Son son1, son2;</span><br><span class="line">    Father* men[] = &#123; &amp;father, &amp;son1, &amp;son2 &#125;;</span><br><span class="line">    <span class="built_in">party</span>(men, <span class="built_in">sizeof</span>(men) / <span class="built_in">sizeof</span>(men[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现多态：虚函数"><a href="#实现多态：虚函数" class="headerlink" title="实现多态：虚函数"></a>实现多态：虚函数</h2><p>多态的本质：</p><ul><li><p>形式上，使用统一的父类指针做一般性处理，</p></li><li><p>但是实际执行时，这个指针可能指向子类对象，</p></li><li><p>形式上，原本调用父类的方法，但是实际上会调用子类的同名方法。</p></li></ul><p>程序执行时，父类指针指向父类对象，或子类对象时，在形式上是无法分辨的！只有通过多态机制，才能执行真正对应的方法。</p><p><strong>虚函数的使用</strong></p><p>虚函数的定义：</p><ul><li><p>在函数的返回类型之前使用 virtual</p></li><li><p>只在成员函数的声明中添加 virtual, 在成员函数的实现中不要加 virtual（声明的时候加就好，实现的时候不用加）</p></li></ul><p>虚函数的继承：</p><ul><li><p>如果某个成员函数被声明为虚函数，那么它的子类【派生类】，以及子类的子类中，所<br>继承的这个成员函数，也自动是虚函数。</p></li><li><p>如果在子类中重写这个虚函数，可以不用再写 virtual, 但是仍建议写 virtual！！！！</p></li></ul><h2 id="虚函数的原理-虚函数表"><a href="#虚函数的原理-虚函数表" class="headerlink" title="虚函数的原理-虚函数表"></a>虚函数的原理-虚函数表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//为了便于测试，特别该用 public</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">200</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;非虚函数：Father::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态数据初始化</span></span><br><span class="line"><span class="type">int</span> Father::z = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Father father;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地获取对象地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址：&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;father) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地获取虚函数表指针</span></span><br><span class="line">    <span class="type">void</span>** vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(&amp;father);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;虚函数表指针 vptr：&quot;</span> &lt;&lt; vptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用虚函数表中的函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用第 1 个虚函数: &quot;</span>;</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr[<span class="number">0</span>])();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用第 2 个虚函数：&quot;</span>;</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr[<span class="number">1</span>])();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用第 3 个虚函数: &quot;</span>;</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr[<span class="number">2</span>])();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地访问数据成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 1 个数据成员的地址: &quot;</span> &lt;&lt; &amp;father.x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 1 个数据成员的值：&quot;</span> &lt;&lt; father.x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 2 个数据成员的地址: &quot;</span> &lt;&lt; &amp;father.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 2 个数据成员的值：&quot;</span> &lt;&lt; father.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(father)==&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(father) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Father father2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;father 的虚函数表：&quot;</span> &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(&amp;father) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;father2 的虚函数表：&quot;</span> &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(&amp;father2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../0_images/C++polymorphism/1_%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png" alt="alt text"></p><p>对象内，首先存储的是“虚函数表指针”，又称“虚表指针”。</p><p>然后再存储非静态数据成员。</p><p>对象的非虚函数，保存在类的代码中！</p><p>对象的内存，只存储虚函数表和数据成员</p><p>（类的静态数据成员，保存在数据区中，和对象是分开存储的）</p><p>添加虚函数后，对象的内存空间不变！仅虚函数表中添加条目</p><p>多个对象，共享同一个虚函数表！</p><h2 id="使用继承的虚函数表"><a href="#使用继承的虚函数表" class="headerlink" title="使用继承的虚函数表"></a>使用继承的虚函数表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;非虚函数：Father::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//为了便于测试，特别该用 public</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son::func5&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Father father;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地获取对象地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;son 对象地址：&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;son) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地获取虚函数表指针</span></span><br><span class="line">    <span class="type">void</span>** vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(&amp;son);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;虚函数表指针 vptr：&quot;</span> &lt;&lt; vptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用虚函数表中的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vptr[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;调用第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个虚函数：&quot;</span>;</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr[i])();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 避免访问无效的函数指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全地访问数据成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 1 个数据成员的地址: &quot;</span> &lt;&lt; &amp;son.x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 1 个数据成员的值：&quot;</span> &lt;&lt; son.x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 2 个数据成员的地址: &quot;</span> &lt;&lt; &amp;son.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 2 个数据成员的值：&quot;</span> &lt;&lt; son.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(son)==&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(son) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分布：</p><p><img src="/../0_images/C++polymorphism/2_%E7%BB%A7%E6%89%BF%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png" alt="alt text"></p><p>补充：</p><p><img src="/../0_images/C++polymorphism/3_%E5%AD%90%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png" alt="alt text"></p><h2 id="多重继承-能不用尽量还是别用了"><a href="#多重继承-能不用尽量还是别用了" class="headerlink" title="多重继承(能不用尽量还是别用了)"></a>多重继承(能不用尽量还是别用了)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Father::func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;非虚函数：Father::func4&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//为了便于测试，特别该用 public</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Mother::handle1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Mother::handle2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Mother::handle3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//为了便于测试，使用 public 权限</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">400</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">500</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father, <span class="keyword">public</span> Mother &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son::func5&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son::handle1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出对象地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;son 对象地址：&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;son) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Father 的虚表指针</span></span><br><span class="line">    Father* fatherPtr = &amp;son;</span><br><span class="line">    <span class="type">void</span>** vptr_father = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(fatherPtr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Father 的虚表指针：&quot;</span> &lt;&lt; vptr_father &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Father 虚表中的函数（前 4 个：func1, func2, func3, func5）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vptr_father[i]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father 虚表第 &quot;</span> &lt;&lt; i<span class="number">+1</span> &lt;&lt; <span class="string">&quot; 个函数: &quot;</span>;</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr_father[i])();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Father 数据成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Father::x = &quot;</span> &lt;&lt; son.x &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;son.x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Father::y = &quot;</span> &lt;&lt; son.y &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;son.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Mother 的虚表指针</span></span><br><span class="line">    Mother* motherPtr = &amp;son;</span><br><span class="line">    <span class="type">void</span>** vptr_mother = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(motherPtr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mother 的虚表指针：&quot;</span> &lt;&lt; vptr_mother &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Mother 虚表中的函数（3 个）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vptr_mother[i]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Mother 虚表第 &quot;</span> &lt;&lt; i<span class="number">+1</span> &lt;&lt; <span class="string">&quot; 个函数: &quot;</span>;</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">func_t</span>&gt;(vptr_mother[i])();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Mother 数据成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mother::m = &quot;</span> &lt;&lt; son.m &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;son.m &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mother::n = &quot;</span> &lt;&lt; son.n &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; &amp;son.n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内存：</p><p><img src="/../0_images/C++polymorphism/4_%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98.png" alt="alt text"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>用来修饰类，让该类不能被继承</p><p>理解：使得该类终结！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">XiaoMi</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi2</span> <span class="keyword">final</span> : <span class="keyword">public</span> XiaoMi &#123;</span><br><span class="line">    <span class="built_in">XiaoMi2</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi3</span> : <span class="keyword">public</span> XiaoMi2 &#123; <span class="comment">//不能把 XiaoMi2 作为基类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用来修饰类的虚函数，使得该虚函数在子类中，不能被重写</p><p>理解：使得该功能终结！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XiaoMi::func</span><span class="params">()</span> </span>&#123; <span class="comment">//不需要再写 final</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XiaoMi::func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi2</span> : <span class="keyword">public</span> XiaoMi &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">// 错误！不能重写 func 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>override 仅能用于修饰虚函数。</p><p>作用：</p><ul><li>提示程序的阅读者，这个函数是重写父类的功能。</li><li>防止程序员在重写父类的函数时，把函数名写错。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XiaoMi::func&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi2</span> : <span class="keyword">public</span> XiaoMi &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//void func() override; 告诉程序员 func 是重写父类的虚函数</span></span><br><span class="line">    <span class="comment">//void func1() override&#123;&#125; 错误！因为父类没有 func1 这个虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    XiaoMi2 xiaomi;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遗失的子类析构函数"><a href="#遗失的子类析构函数" class="headerlink" title="遗失的子类析构函数"></a>遗失的子类析构函数</h2><p>为了防止内存泄露，最好是在基类析构函数上添加 virtual 关键字，使基类析构函数为虚函数</p><p>目的在于，当使用 delete 释放基类指针时，会实现动态的析构：</p><p>如果基类指针指向的是基类对象，那么只调用基类的析构函数</p><p><strong>如果基类指针指向的是子类对象，那么先调用子类的析构函数，再调用父类的析构函数</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>(<span class="type">const</span> <span class="type">char</span>* addr =<span class="string">&quot;中国&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行了 Father 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(addr) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;addr = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;addr, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 Father 类的析构函数定义为 virtual 函数时，</span></span><br><span class="line">    <span class="comment">// 如果对 Father 类的指针使用 delete 操作时，</span></span><br><span class="line">    <span class="comment">// 就会对该指针使用“动态析构”：</span></span><br><span class="line">    <span class="comment">// 如果这个指针，指向的是子类对象，</span></span><br><span class="line">    <span class="comment">// 那么会先调用该子类的析构函数，再调用自己类的析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Father</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行了 Father 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">            <span class="keyword">delete</span> addr;</span><br><span class="line">            addr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *game=<span class="string">&quot;吃鸡&quot;</span>, <span class="type">const</span> <span class="type">char</span> *addr=<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">    :<span class="built_in">Father</span>(addr)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行了 Son 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(game) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;game = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;game, game);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">~<span class="built_in">Son</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;执行了 Son 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (game) &#123;</span><br><span class="line">        <span class="keyword">delete</span> game;</span><br><span class="line">        game = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* game;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----- case 1 -----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Father* father = <span class="keyword">new</span> <span class="built_in">Father</span>();</span><br><span class="line">    <span class="keyword">delete</span> father;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----- case 2 -----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son* son = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> son;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----- case 3 -----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    father = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> father;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h2><p>什么时候使用纯虚函数</p><p>某些类，在现实角度和项目实现角度，都<strong>不需要实例化</strong>（不需要创建它的对象），这个类中定义的某些成员函数，只是为了提供一个形式上的接口，准备让子类来做具体的实现。</p><p>此时，这个方法，就可以定义为“纯虚函数”， 包含纯虚函数的类，就称为抽象类。</p><p>纯虚函数的使用方法</p><p><strong>用法：纯虚函数，使用 virtual 和 &#x3D;0</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> string&amp; color = <span class="string">&quot;white&quot;</span>) &#123; <span class="keyword">this</span>-&gt;color = color; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//不用做具体的实现</span></span><br><span class="line">    <span class="function">string <span class="title">getColor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> color; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string color;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> radius = <span class="number">0</span>, <span class="type">const</span> string&amp; color=<span class="string">&quot;White&quot;</span>):<span class="built_in">Shape</span>(color), <span class="built_in">r</span>(radius)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> r; <span class="comment">//半径</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Circle::area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用抽象类创建对象非法！</span></span><br><span class="line"><span class="comment">//Shape s;</span></span><br><span class="line">    <span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; c<span class="number">1.</span><span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    Shape* p = &amp;c1;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类声明某纯虚函数后，那么它的子类</p><ul><li><p>要么实现这个纯虚函数 （最常见）</p></li><li><p>要么继续把这个纯虚函数声明为纯虚函数，这个子类也成为抽象类</p></li><li><p>要么不对这个纯虚函数做任何处理，等效于上一种情况（该方式不推荐）</p></li></ul><p>常见错误：</p><ol><li><p>虚函数的函数原型</p><p> 子类在重新实现继承的虚函数时，要和主要函数的原型一致</p><p> 如果已经继承虚函数：</p><p> bool heartBeat();</p><p> 那么重写虚函数时，函数原型必须保持完全一致：</p><p> bool heartBeat();</p><p> 而且子类不能添加：</p><p> int heartBeat();</p><p> &#x2F;&#x2F;因为仅函数的返回类型不同时，不能区别两个函数。</p><p> 但是可以添加：</p><p> int heartBeat(int);</p></li><li><p>析构函数是否使用虚函数</p><p> 有子类时，析构函数就应该使用虚函数</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ reference</title>
      <link href="/2025/04/13/C++reference/"/>
      <url>/2025/04/13/C++reference/</url>
      
        <content type="html"><![CDATA[<h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>在 C++ base 之中已经介绍了一些 引用的基本概念，本来我以为引用就是我想象的那样(就是最为基础的用法&amp;)但是今天做线程池的项目的时候涉及到了左值引用和右值引用的概念</p><p>这个概念不是很懂，因此拿出来学一学 说一说</p><h2 id="引用的基础用法"><a href="#引用的基础用法" class="headerlink" title="引用的基础用法"></a>引用的基础用法</h2><p>就是咱们平时用的那种,这种其实是一种左值引用，这个概念下面再说</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i的地址为 &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;j的地址为 &quot;</span> &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用如何实现"><a href="#引用如何实现" class="headerlink" title="引用如何实现"></a>引用如何实现</h3><p>我们先来看一下一个最为基础的赋值语句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">//其实A就是地址的别名</span></span><br></pre></td></tr></table></figure><p>我们把他进行反汇编</p><p><img src="/../0_images/C++reference/1_%E8%B5%8B%E5%80%BC%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="alt text"></p><p>可以看到：返回汇编之后就是一个简单的mv语句，把10 放到 地址[a]之中</p><p><img src="/../0_images/C++reference/2_%E5%9C%B0%E5%9D%80%E8%A1%A8.png" alt="alt text"></p><p>那么我们后面修改值的话就会修改(a)地址里面所存的值</p><p>现在我们要为这个变量添加引用，相当于为地址a取一个别名</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;   <span class="comment">//引用是变量的别名，是通过指针实现的</span></span><br></pre></td></tr></table></figure><p>我们把他进行反汇编</p><p><img src="/../0_images/C++reference/3_%E5%BC%95%E7%94%A8%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="alt text"></p><p>我们可以看到 int&amp; b &#x3D; a; 对应两条指令 ，这两句话的意思是将[a]存储到rex之中，然后在将rex存储到[b]之中</p><p>最后的意思是：</p><p><img src="/../0_images/C++reference/4_%E5%9C%B0%E5%9D%80%E8%A1%A8.png" alt="alt text"></p><p>然后我们再用引用来修改值试试</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;   <span class="comment">//引用是变量的别名，是通过指针实现的</span></span><br><span class="line">b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/../0_images/C++reference/5_%E5%BC%95%E7%94%A8%E4%BF%AE%E6%94%B9%E5%80%BC%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="alt text"></p><p>我们可以看到，分成了两步，第一步：先拿到[b]之中存储的值(也就是地址a)，第二步：赋值</p><p>以上就是咱们最常见的引用的实现！！！</p><h2 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h2><p>首先理解一下什么是左值和右值</p><p>对于一个语句 int a &#x3D; 10;</p><p>我们可以看到，将10放入变量a之中，a是有地址的，也可以说a就是地址的别名，10是没有地址的。左值就是那些有地址的量，比如：有名字的变量 右值就是那些临时的没有地址的量 比如：临时对象或者字面量</p><p>或者换一种解释：</p><p><img src="/../0_images/C++reference/2_%E5%9C%B0%E5%9D%80%E8%A1%A8.png" alt="alt text"></p><p>对左边的引用是左值引用 对右边的引用是右值引用  ： )</p><p>咱们上面说的 <strong>引用的基础用法</strong> 其实就是左值引用，下面就介绍一下 右值引用</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>Type &amp;&amp;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rref = <span class="number">10</span>; <span class="comment">// 右值引用绑定到字面量10</span></span><br><span class="line"><span class="comment">//rref = 20; // 错误，不能修改右值</span></span><br></pre></td></tr></table></figure><p>其实就这么简单，就是对一些临时的量的引用，不可以修改右值</p><p>这看上去好像有点鸡肋，没啥用，但是用处确实不小</p><h4 id="右值引用的用处"><a href="#右值引用的用处" class="headerlink" title="右值引用的用处"></a>右值引用的用处</h4><p><strong>移动语义（Move Semantics）</strong></p><p>这个很重要！它允许资源的“转移”，从而避免不必要的拷贝，显著提高程序的性能。</p><p>当一个对象被赋值给另一个对象时，通常会调用拷贝构造函数或拷贝赋值运算符，这可能导致不必要的资源拷贝，尤其是对于大型对象(比如很大的vector，或者是string)</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">createVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1000000</span>); <span class="comment">// 创建一个包含1000000个元素的向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下怎么返回值，在返回的时候返回一个1000000的vector (假设名字为A)，我们通常会使用一个vector (假设名字为B)来接收，那么过程通常是 B &#x3D; A 使用拷贝来构造B，然后A再销毁，那么有了右值引用的话就可以临时接管A，然后再将控制权转给B，这样就是移动构造</p><p><strong>完美转发（Perfect Forwarding）</strong></p><p>它允许函数将参数原样传递给另一个函数，保留其左值或右值的性质。</p><p>一个函数要接收 左值或右值 可能得需要对函数进行重载</p><p>通过：forward实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完美转发arg到另一个函数</span></span><br><span class="line">    <span class="built_in">wrappedFunction</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line">std::forward&lt;T&gt;(arg)：根据T的类型（左值或右值），将arg原样转发到wrappedFunction。</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);       <span class="comment">// 输出 &quot;lvalue: 10&quot;</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>);      <span class="comment">// 输出 &quot;rvalue: 20&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1wvX7YtEk3/?spm_id_from=333.337.search-card.all.click&vd_source=28887ecca1f25a715214067a2b3b58ac">https://www.bilibili.com/video/BV1wvX7YtEk3/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ pointer</title>
      <link href="/2025/04/13/C++pointer/"/>
      <url>/2025/04/13/C++pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>主要介绍一些C++指针的一些知识，基础的就不做介绍了</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>参考：<a href="https://blog.csdn.net/weixin_43908419/article/details/131060402">https://blog.csdn.net/weixin_43908419/article/details/131060402</a></p><h3 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针"></a>什么是智能指针</h3><p>智能指针RAII(Resource Acquisition Is Initialization)，是一种利用对象的生命周期来管理资源的技术。如果我们采用传统的new&#x2F;delete来申请和释放资源，如果忘记调用delete，或者在调用delete之前程序抛出异常，都会导致内存泄漏问题</p><p>最简单的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这里Div函数会抛异常，main函数会捕获异常，delete[]没有执行，引发内存泄漏</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">Div</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span>[] p1;</span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Func函数中的new p2和Div都可能抛异常，导致后面的delete没有执行从而引发内存泄漏，采用智能指针对资源进行管理，能够杜绝这类问题。</p><p>智能指针是一个类，在对象构造时调用构造函数获取资源，在对象生命周期内，保证资源不被释放，在对象生命周期结束时，编译器自动调用析构函数来释放资源。这就相当于，将管理资源的责任移交给了对象，这样即使程序抛出异常也不存在内存泄漏，因为捕获异常往往跳出函数体，执行流会离开对象的作用域，对象生命周期结束，编译器自动调用析构函数释放了资源。</p><p>采用智能指针管理资源，有如下优点：</p><ul><li><p>将资源管理的责任转移给智能指针对象，不用显示地释放资源，杜绝了异常安全问题。</p></li><li><p>保证对象管理的资源在其生命周期内有效。</p></li></ul><p>简单定义：</p><p>定义了一种简易的智能指针SmartPtr，在其析构函数中会对资源进行释放。因为申请的资源可能是通过new T、new T[n]、malloc(…)这几种方法的任意之一来申请的，每种方式申请的资源需要不同的关键字&#x2F;函数来释放资源，否则程序可能会崩溃。</p><p>因此，需要一个模板参数Del，这个模板参数用于接收仿函数，以匹配不同的资源释放方式。我们默认采用delete的方式释放资源，C++标准库中提供的智能指针，如果不显示给定仿函数来定义释放资源的方式，也是默认delete释放资源。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Free</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Del = Delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> SmartPtr&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T* ptr=<span class="literal">nullptr</span>):_ptr(ptr)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">SmartPtr</span>()&#123;</span><br><span class="line">        Del del;</span><br><span class="line">        <span class="built_in">del</span>(_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基础访问功能</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 单个对象</span></span><br><span class="line">    <span class="function">SmartPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    cout&lt;&lt;*p<span class="number">1.</span><span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态数组（需配套删除器）</span></span><br><span class="line">    SmartPtr&lt;<span class="type">int</span>, DeleteArray&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">p2</span>( <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>] );</span><br><span class="line">    cout&lt;&lt;*p<span class="number">2.</span><span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C语言内存分配（需配套删除器）</span></span><br><span class="line">    SmartPtr&lt;<span class="type">int</span>, Free&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">p3</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>))));</span><br><span class="line">    cout&lt;&lt;*p<span class="number">3.</span><span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h3><p>智能指针，顾名思义，不能仅仅是用于资源管理，还应当具有指针的一般功能。因此，需要重载operator*、operator-&gt;函数（见代码1.3），用于访问指针指向的资源。注意：C++标准库中的智能指针均不重载operator[]函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个简单的结构体用于测试operator-&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Free</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Del = Delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> SmartPtr&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T* ptr=<span class="literal">nullptr</span>):_ptr(ptr)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">SmartPtr</span>()&#123;</span><br><span class="line">        Del del;</span><br><span class="line">        <span class="built_in">del</span>(_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基础访问功能</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试默认删除器（Delete&lt;T&gt;）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Default Deleter Test: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; endl;  <span class="comment">// 输出10</span></span><br><span class="line">        *ptr1 = <span class="number">20</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Modified Value: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; endl;         <span class="comment">// 输出20</span></span><br><span class="line">    &#125; <span class="comment">// 此处自动调用delete</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试数组删除器（DeleteArray&lt;T&gt;）</span></span><br><span class="line">    &#123;</span><br><span class="line">        SmartPtr&lt;<span class="type">int</span>, DeleteArray&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr2</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array Test: &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ptr<span class="number">2.</span><span class="built_in">get</span>()[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">get</span>()[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">get</span>()[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 输出1,2,3</span></span><br><span class="line">    &#125; <span class="comment">// 此处自动调用delete[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试C风格内存释放（Free&lt;T&gt;）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* raw_ptr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">        *raw_ptr = <span class="number">30</span>;</span><br><span class="line">        SmartPtr&lt;<span class="type">int</span>, Free&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr3</span>(raw_ptr);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Free Test: &quot;</span> &lt;&lt; *ptr3 &lt;&lt; endl; <span class="comment">// 输出30</span></span><br><span class="line">    &#125; <span class="comment">// 此处自动调用free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试结构体与operator-&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SmartPtr&lt;Point&gt; <span class="title">ptr4</span><span class="params">(<span class="keyword">new</span> Point)</span></span>;</span><br><span class="line">        ptr4-&gt;x = <span class="number">100</span>;    <span class="comment">// 通过operator-&gt;修改成员</span></span><br><span class="line">        ptr4-&gt;y = <span class="number">200</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Struct Test: &quot;</span> &lt;&lt; ptr4-&gt;x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ptr4-&gt;y &lt;&lt; endl; <span class="comment">// 输出100,200</span></span><br><span class="line">    &#125; <span class="comment">// 此处自动调用delete</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">//对结构体使用operator*</span></span><br><span class="line">        <span class="function">SmartPtr&lt;Point&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> Point&#123;<span class="number">300</span>, <span class="number">400</span>&#125;)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Struct Dereference Test:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过operator*访问结构体</span></span><br><span class="line">        (*ptr6).x = <span class="number">500</span>;  <span class="comment">// 等价于ptr6-&gt;x = 500</span></span><br><span class="line">        (*ptr6).y = <span class="number">600</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混合使用两种访问方式</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Modified values: &quot;</span> </span><br><span class="line">             &lt;&lt; (*ptr6).x &lt;&lt; <span class="string">&quot;, &quot;</span>    <span class="comment">// 500</span></span><br><span class="line">             &lt;&lt; ptr6-&gt;y &lt;&lt; endl;      <span class="comment">// 600</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针的拷贝问题"><a href="#智能指针的拷贝问题" class="headerlink" title="智能指针的拷贝问题"></a>智能指针的拷贝问题</h3><p>我们要求智能指针具有一般的指针行为，因此，我们也就需要智能指针支持拷贝。但是，智能指针中的成员涉及到执行动态申请资源的指针，按照一般要求，应当进行深拷贝。</p><p>但是如果我们进行深拷贝，就会让两个智能指针指向不同的空间，但是我们所希望的是两个指针共同管理一块资源，因此我们就是要浅拷贝（值拷贝）。</p><p>但是值拷贝会存在对同一块空间多次释放的问题，对此，C++标准库中的智能指针auto_ptr和shared_ptr分别采用了管理权转移和引用计数的方法来解决问题，但一般会通过引用计数解决多次释放的问题</p><ul><li><p>即使涉及到动态申请内存，智能指针的拷贝也不应为深拷贝，应当是浅拷贝。</p></li><li><p>采用管理权转移（auto_ptr）或引用计数（shared_ptr）来解决同一块空间多次释放的问题。</p></li><li><p>一般都使用引用计数来解决多次释放问题，auto_ptr大部分情况下不使用。</p></li></ul><p><img src="/../0_images/C++pointer/1_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0.png" alt="alt text"></p><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><h4 id="auto-ptr的拷贝构造和赋值问题"><a href="#auto-ptr的拷贝构造和赋值问题" class="headerlink" title="auto_ptr的拷贝构造和赋值问题"></a>auto_ptr的拷贝构造和赋值问题</h4><p>auto_ptr采用管理权转移的方法进行赋值和拷贝构造，假设原先有一个auto_ptr对象p1，要通过p1构造p2，当拷贝构造完成后，用于拷贝构造传参的对象p1中管理资源的指针会被更改为nullptr，赋值也一样，假设p2&#x3D;p1，p1中资源的管理权会转移给p2，p2原本的资源会被释放。</p><p>采用管理权转移的方法进行智能指针拷贝是一种极不负责任的行为，auto_ptr已经被很多公司明令禁止使用，一般项目中也极少使用auto_ptr。</p><p><img src="/../0_images/C++pointer/2_auto_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98.png" alt="alt text"></p><h4 id="auto-ptr的模拟实现"><a href="#auto-ptr的模拟实现" class="headerlink" title="auto_ptr的模拟实现"></a>auto_ptr的模拟实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">autoPtr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">autoPtr</span>(T* ptr = <span class="literal">nullptr</span>):_ptr(ptr)&#123;&#125;;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">autoPtr</span>(autoPtr&lt;T&gt; &amp; ap):_ptr(ap._ptr)&#123;</span><br><span class="line">        ap._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值构造</span></span><br><span class="line">    autoPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(autoPtr&lt;T&gt; &amp; ap)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != ap._ptr)&#123;  <span class="comment">//自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ap._ptr;</span><br><span class="line">            ap._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">autoPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：检查指针是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr == <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test destroyed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试1: 基础构造和析构</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;--- Test 1: Basic ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    &#125; <span class="comment">// 此处应输出&quot;Test destroyed: 1&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试2: 拷贝构造所有权转移</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n--- Test 2: Copy Constructor ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap2</span><span class="params">(ap1)</span></span>;  <span class="comment">// 所有权转移</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ap1.isNull(): &quot;</span> &lt;&lt; ap<span class="number">1.</span><span class="built_in">isNull</span>() &lt;&lt; std::endl;  <span class="comment">// 应输出1</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ap2-&gt;value: &quot;</span> &lt;&lt; ap2-&gt;value &lt;&lt; std::endl;     <span class="comment">// 应输出2</span></span><br><span class="line">    &#125; <span class="comment">// 此处应输出&quot;Test destroyed: 2&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试3: 赋值运算符所有权转移</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n--- Test 3: Assignment Operator ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">3</span>))</span></span>;</span><br><span class="line">        autoPtr&lt;Test&gt; ap4;</span><br><span class="line">        ap4 = ap3;  <span class="comment">// 所有权转移</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ap3.isNull(): &quot;</span> &lt;&lt; ap<span class="number">3.</span><span class="built_in">isNull</span>() &lt;&lt; std::endl; <span class="comment">// 应输出1</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ap4-&gt;value: &quot;</span> &lt;&lt; ap4-&gt;value &lt;&lt; std::endl;     <span class="comment">// 应输出3</span></span><br><span class="line">    &#125; <span class="comment">// 此处应输出&quot;Test destroyed: 3&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试4: 操作符功能</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n--- Test 4: Operators ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap5</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">5</span>))</span></span>;</span><br><span class="line">        (*ap5).value = <span class="number">6</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Modified value via *: &quot;</span> &lt;&lt; ap5-&gt;value &lt;&lt; std::endl;  <span class="comment">// 应输出6</span></span><br><span class="line">        </span><br><span class="line">        ap5-&gt;value = <span class="number">7</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Modified value via -&gt;: &quot;</span> &lt;&lt; (*ap5).value &lt;&lt; std::endl; <span class="comment">// 应输出7</span></span><br><span class="line">    &#125; <span class="comment">// 此处应输出&quot;Test destroyed: 7&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试5: 自赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n--- Test 5: Self-Assignment ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">autoPtr&lt;Test&gt; <span class="title">ap6</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">6</span>))</span></span>;</span><br><span class="line">        ap6 = ap6;  <span class="comment">// 自赋值应安全处理</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ap6-&gt;value: &quot;</span> &lt;&lt; ap6-&gt;value &lt;&lt; std::endl;  <span class="comment">// 应输出6</span></span><br><span class="line">    &#125; <span class="comment">// 此处应输出&quot;Test destroyed: 6&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr 直接将拷贝构造和赋值禁止，也就不存在浅拷贝的多次释放同一块空间的问题。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">uniquePtr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">uniquePtr</span>(T* ptr):_ptr(ptr)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">uniquePtr</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uniquePtr</span>(<span class="type">const</span> uniquePtr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line">    uniquePtr&lt;T&gt; &amp; <span class="keyword">operator</span>=(<span class="type">const</span> uniquePtr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">TestStruct</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">// 基础功能测试</span></span><br><span class="line">        <span class="function">uniquePtr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">        cout &lt;&lt; *up1 &lt;&lt; endl; <span class="comment">// 输出: 42</span></span><br><span class="line"></span><br><span class="line">        <span class="function">uniquePtr&lt;TestStruct&gt; <span class="title">up2</span><span class="params">(<span class="keyword">new</span> TestStruct&#123;<span class="number">99</span>&#125;)</span></span>;</span><br><span class="line">        cout &lt;&lt; up2-&gt;val &lt;&lt; endl; <span class="comment">// 输出: 99</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    // 以下代码取消注释会编译错误（测试拷贝禁止）</span></span><br><span class="line">    <span class="comment">//    uniquePtr&lt;int&gt; up3(new int(42));</span></span><br><span class="line">    <span class="comment">//    uniquePtr&lt;int&gt; up4(up3);</span></span><br><span class="line">    <span class="comment">//    uniquePtr&lt;int&gt; up5 = up3;          // 错误：拷贝构造被删除</span></span><br><span class="line">    <span class="comment">//    uniquePtr&lt;int&gt; up6; up6 = up4;     // 错误：拷贝赋值被删除</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><table><thead><tr><th>接口函数</th><th>功能</th></tr></thead><tbody><tr><td><code>shared_ptr(T* ptr = nullptr, Del del = Delete&lt;T&gt;())</code></td><td>构造函数，del为定制删除器（仿函数对象），用于不同情况下的资源释放操作</td></tr><tr><td><code>shared_ptr(shared_ptr&lt;T&gt;&amp; sp)</code></td><td>拷贝构造函数</td></tr><tr><td><code>shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; sp)</code></td><td>赋值运算符重载函数</td></tr><tr><td><code>T&amp; operator*()</code></td><td>解引用操作符重载函数</td></tr><tr><td><code>T* operator-&gt;()</code></td><td>成员访问操作符重载函数</td></tr><tr><td><code>T* get()</code></td><td>获取<code>shared_ptr</code>内部管理资源的指针</td></tr><tr><td><code>long int use_count()</code></td><td>获取引用计数（当前智能指针管理的资源被多少智能指针共同管理）</td></tr><tr><td><code>bool unique()</code></td><td>判断当前智能指针管理的资源是否只有它本身在管理（引用计数是否为1）</td></tr></tbody></table><h4 id="shared-ptr的拷贝构造和赋值问题"><a href="#shared-ptr的拷贝构造和赋值问题" class="headerlink" title="shared_ptr的拷贝构造和赋值问题"></a>shared_ptr的拷贝构造和赋值问题</h4><ul><li><p>shared内部有一个成员变量long int* _pcount，它指向一块存储引用计数的空间，当进行拷贝构造时，引用计数+1，即：++(*_pcount)。</p></li><li><p>进行赋值操作（sp2 &#x3D; sp1）时，首先应当检查自赋值，如果是自赋值直接返回*this即可。如果不是自赋值，那么首先将sp2的引用计数-1，如果sp2的引用计数-1后变为了0，那么就释放sp2的资源，然后赋予sp2管理sp1管理的资源的权限，sp2和sp1共用一个引用计数，引用计数+1。</p></li><li><p>调用析构函数时，先让引用计数-1，如果此时引用计数变为0，就释放资源。</p></li></ul><p><img src="/../0_images/C++pointer/3_shared_ptr%E7%9A%84%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98.png" alt="alt text"></p><h4 id="shared-ptr的模拟实现"><a href="#shared-ptr的模拟实现" class="headerlink" title="shared_ptr的模拟实现"></a>shared_ptr的模拟实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Delete</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Free</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T * ptr)</span></span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Del = Delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> sharedPtr&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span>* _pcount;   <span class="comment">//引用计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sharedPtr</span>(T* ptr):_ptr(ptr),_pcount(<span class="keyword">new</span> <span class="type">long</span> <span class="built_in">int</span>(<span class="number">1</span>))&#123;&#125;;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">sharedPtr</span>(sharedPtr&lt;T,Del&gt; &amp; sp):_ptr(sp._ptr),_pcount(sp._pcount)&#123;</span><br><span class="line">        ++(*_pcount); <span class="comment">//计数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值函数</span></span><br><span class="line">    sharedPtr&lt;T,Del&gt;&amp; <span class="keyword">operator</span>=(sharedPtr&lt;T,Del&gt; &amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr == sp._ptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//this的引用计数-1，并判断是否需要释放资源</span></span><br><span class="line">        (*_pcount)--; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>((*_pcount)==<span class="number">0</span>)&#123;</span><br><span class="line">            Del del;</span><br><span class="line">            <span class="built_in">del</span>(_ptr); _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> _pcount; _pcount = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        _ptr = sp._ptr;</span><br><span class="line">        _pcount = sp._pcount;</span><br><span class="line">        (*_pcount)++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针获取函数</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用计数获取函数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">use_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_pcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *_pcount == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">sharedPtr</span>()&#123;</span><br><span class="line">        (*_pcount)--; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>((*_pcount)==<span class="number">0</span>)&#123;</span><br><span class="line">            Del del;</span><br><span class="line">            <span class="built_in">del</span>(_ptr); _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> _pcount; _pcount = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试基础类型和引用计数</span></span><br><span class="line">    <span class="function">sharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use count: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        sharedPtr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 use count after copy: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p2 use count: &quot;</span> &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;             <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use count after p2销毁: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试赋值运算符</span></span><br><span class="line">    <span class="function">sharedPtr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    p1 = p3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use count after assignment: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3 use count: &quot;</span> &lt;&lt; p<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;                  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试自赋值</span></span><br><span class="line">    p1 = p1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use count after self-assignment: &quot;</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试数组类型</span></span><br><span class="line">    sharedPtr&lt;<span class="type">int</span>, DeleteArray&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// 此处arr析构时会调用delete[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试malloc/free</span></span><br><span class="line">    sharedPtr&lt;<span class="type">int</span>, Free&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">malloc_ptr</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>))));</span><br><span class="line">    <span class="comment">// 此处malloc_ptr析构时会调用free</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shared-ptr的循环引用问题"><a href="#shared-ptr的循环引用问题" class="headerlink" title="shared_ptr的循环引用问题"></a>shared_ptr的循环引用问题</h4><p>在绝大部分情况下，shared_ptr能够解决智能指针赋值造成的多次析构问题，也不会引发内存泄漏。但是，代码4.1展现了一种特殊情况，定义一个Node节点，其中包含两个shared_ptr成员_prev和_next。在主函数中实例化出两个shared_ptr&lt;Node&gt;对象n1和n2，n1的_next指向n2，n2的_prev指向n1，n1和n2相互指向对方，这样就属于循环引用，会造成n1和n2的资源释放失败，引发内存泄漏问题</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">std::shared_ptr&lt;Node&gt; _prev;</span><br><span class="line">std::shared_ptr&lt;Node&gt; _next;</span><br><span class="line"> </span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"> </span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_prev = n1;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造对象n1和n2，引用计数为1，然后n1-&gt;_next &#x3D; n2、n2-&gt;_prev &#x3D; n1后，引用计数变为2。</p></li><li><p>先后由n2和n1调用析构函数，引用计数变为1。</p></li><li><p>此时，n1和n2的资源还都没有释放，n1的_next依旧指向n2，n2的_prev依旧指向n1。</p></li><li><p>n1释放，就需要n2的_prev成员释放，n1释放，就需要n1的_next成员释放。但是，只有对象本身析构，它的成员才会析构，因此n1和n2彼此制约对方的析构，最终n1和n2的资源都无法释放，造成了内存泄漏。</p></li></ul><p><img src="/../0_images/C++pointer/4_%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="alt text"></p><p>为了避免循环引用，可以把Node节点中的_next和_prev成员变量的类型改为weak_ptr&lt;Node&gt;，weak_ptr是C++标准库中的比较特殊的一个“智能指针”，允许使用shared_ptr对象来构造weak_ptr对象，但是，<strong>weak_ptr不增加引用计数，不参与资源的申请和释放</strong>，从严格意义上讲，weak_ptr不算是智能指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">std::weak_ptr&lt;Node&gt; _prev;</span><br><span class="line">std::weak_ptr&lt;Node&gt; _next;</span><br><span class="line"> </span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"> </span><br><span class="line">n1-&gt;_next = n2;</span><br><span class="line">n2-&gt;_prev = n1;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr不参与资源的管理和释放，可以使用shared_ptr对象来构造weak_ptr对象，但是不能直接使用指针来构造weak_ptr对象，在weak_ptr中，也没有operator*函数和operator-&gt;成员函数，不具有一般指针的行为，因此，weak_ptr严格意义上并不是智能指针，weak_ptr的出现，就是为了解决shared_ptr的循环引用问题。</p><p>weak_ptr在进行拷贝构造和赋值时，不增加引用计数，由于weak_ptr不参与资源管理，也不需要显示定义析构函数来释放资源。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weakPtr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">weakPtr</span>():_ptr(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">weakPtr</span>(weakPtr&lt;T&gt;&amp; wp):_ptr(wp._ptr)&#123;&#125;</span><br><span class="line">    <span class="comment">//share_prt 构造</span></span><br><span class="line">    <span class="built_in">weakPtr</span>(shared_ptr&lt;T&gt;&amp; sp):_ptr(sp.<span class="built_in">get</span>())&#123;&#125;</span><br><span class="line">    <span class="comment">//赋值函数</span></span><br><span class="line">weakPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(weakPtr&lt;T&gt;&amp; wp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr == wp._ptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">_ptr = wp._ptr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过shared_ptr对象赋值</span></span><br><span class="line">weakPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">_ptr = sp.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加get方法用于测试</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个shared_ptr并初始化</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.get() = &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, *sp1 = &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试从shared_ptr构造weakPtr</span></span><br><span class="line">    <span class="function">weakPtr&lt;<span class="type">int</span>&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp1.get() = &quot;</span> &lt;&lt; wp<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试拷贝构造</span></span><br><span class="line">    <span class="function">weakPtr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp2.get() = &quot;</span> &lt;&lt; wp<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试赋值运算符（weakPtr赋值给weakPtr）</span></span><br><span class="line">    weakPtr&lt;<span class="type">int</span>&gt; wp3;</span><br><span class="line">    wp3 = wp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp3.get() = &quot;</span> &lt;&lt; wp<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试从新的shared_ptr赋值</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line">    wp3 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp2.get() = &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;, *sp2 = &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp3.get() after sp2 assignment = &quot;</span> &lt;&lt; wp<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证所有weakPtr的指针值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nFinal pointers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp1 (from sp1): &quot;</span> &lt;&lt; wp<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp2 (copy of wp1): &quot;</span> &lt;&lt; wp<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp3 (assigned sp2): &quot;</span> &lt;&lt; wp<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>智能指针是用来对资源进行管理的类，在对象创建时动态申请内存资源，在对象生命周期结束时由编译器自动调用析构函数完成资源的释放，智能指针除了用来管理资源外，还应当具有指针的一般行为（operator*函数和operator-&gt;函数）。</p></li><li><p>使用智能指针，相当于把资源管理的责任转交给智能指针对象。这样能够有效避免因为忘记delete或者程序抛出异常而引起的内存泄漏。</p></li><li><p>智能指针应支持浅拷贝，但是浅拷贝存在同一块空间被多次释放的问题，为此，C++标准库中的三种智能指针auto_ptr、unique_ptr和shared_ptr分别采用了不同的方法来解决这一问题。</p><ul><li><p>auto_ptr支持拷贝的方式是进行管理权转移，这是一种不负责任的处理方式，auto_ptr因此被许多公司禁止使用。</p></li><li><p>unique_ptr直接强行禁止拷贝构造和赋值。</p></li><li><p>shared_ptr通过引用计数的方式来进行浅拷贝，当引用计数为0时析构函数才释放资源，这样既支持了浅拷贝，也保证一块空间仅被析构一次。但是shared_ptr存在循环引用这一隐患，会造成内存泄漏。</p></li></ul></li><li><p>使用weak_ptr可以避免shared_ptr的循环引用问题，weak_ptr可以通shared_ptr对象来构造而不增加引用计数，weak_ptr不参与资源的管理，不支持operator*和operator-&gt;。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ operaOvlod</title>
      <link href="/2025/04/13/C++operaOvlod/"/>
      <url>/2025/04/13/C++operaOvlod/</url>
      
        <content type="html"><![CDATA[<h1 id="C-运算法重载"><a href="#C-运算法重载" class="headerlink" title="C++运算法重载"></a>C++运算法重载</h1><p>C&#x2F;C++的运算符，支持的数据类型，仅限于基本数据类型。</p><p>问题：</p><ul><li><p>一头牛+一头马 &#x3D; ？（牛马神兽？）</p></li><li><p>一个圆 +一个圆 &#x3D; ？ （想要变成一个更大的圆）</p></li><li><p>一头牛 – 一只羊 &#x3D; ？ (想要变成 4 只羊，原始的以物易物：1 头牛价值 5 只羊)</p></li></ul><p>解决方案：使用运算符重载</p><p>那些可以重载</p><ul><li><p>为了防止对标准类型进行运算符重载，</p><pre><code>  C++规定重载运算符的操作对象至少有一个不是标准类型，而是用户自定义的类型比如不能重载 1+2 但是可以重载           cow + 2 和 2 + cow    // cow 是自定义的对象</code></pre></li><li><p>不能改变原运算符的语法规则， 比如不能把双目运算符重载为单目运算</p></li><li><p>不能改变原运算符的优先级</p></li><li><p>不能创建新的运算符，比如 operator*<em>就是非法的, operator</em>是可以的</p></li><li><p>不能对以下这四种运算符，使用友元函数进行重载&#x3D; 赋值运算符，（）函数调用运算符，[ ]下标运算符，-&gt;通过指针访问类成员</p></li><li><p>不能对禁止重载的运算符进行重载</p></li></ul><table><thead><tr><th align="left"><strong>运算符</strong></th><th align="left"><strong>是否可重载</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">不可重载</td><td align="left">成员访问运算符</td></tr><tr><td align="left"><code>::</code></td><td align="left">不可重载</td><td align="left">作用域解析运算符</td></tr><tr><td align="left"><code>.*</code></td><td align="left">不可重载</td><td align="left">成员指针访问运算符</td></tr><tr><td align="left"><code>-&gt;*</code></td><td align="left">不可重载</td><td align="left">成员指针访问运算符</td></tr><tr><td align="left"><code>?:</code></td><td align="left">不可重载</td><td align="left">条件运算符</td></tr><tr><td align="left"><code>sizeof</code></td><td align="left">不可重载</td><td align="left">大小查询运算符</td></tr><tr><td align="left"><code>typeid</code></td><td align="left">不可重载</td><td align="left">类型信息运算符</td></tr><tr><td align="left"><code>=</code></td><td align="left">可重载</td><td align="left">赋值运算符</td></tr><tr><td align="left"><code>()</code></td><td align="left">可重载</td><td align="left">函数调用运算符</td></tr><tr><td align="left"><code>[]</code></td><td align="left">可重载</td><td align="left">下标运算符</td></tr><tr><td align="left"><code>-&gt;</code></td><td align="left">可重载</td><td align="left">成员访问运算符</td></tr><tr><td align="left"><code>new</code></td><td align="left">可重载</td><td align="left">动态内存分配运算符</td></tr><tr><td align="left"><code>delete</code></td><td align="left">可重载</td><td align="left">动态内存释放运算符</td></tr><tr><td align="left"><code>+</code></td><td align="left">可重载</td><td align="left">加法运算符</td></tr><tr><td align="left"><code>-</code></td><td align="left">可重载</td><td align="left">减法运算符</td></tr><tr><td align="left"><code>*</code></td><td align="left">可重载</td><td align="left">乘法运算符</td></tr><tr><td align="left"><code>/</code></td><td align="left">可重载</td><td align="left">除法运算符</td></tr><tr><td align="left"><code>%</code></td><td align="left">可重载</td><td align="left">取模运算符</td></tr><tr><td align="left"><code>++</code></td><td align="left">可重载</td><td align="left">自增运算符</td></tr><tr><td align="left"><code>--</code></td><td align="left">可重载</td><td align="left">自减运算符</td></tr><tr><td align="left"><code>==</code></td><td align="left">可重载</td><td align="left">等于运算符</td></tr><tr><td align="left"><code>!=</code></td><td align="left">可重载</td><td align="left">不等于运算符</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">可重载</td><td align="left">大于运算符</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">可重载</td><td align="left">小于运算符</td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">可重载</td><td align="left">大于等于运算符</td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">可重载</td><td align="left">小于等于运算符</td></tr><tr><td align="left"><code>&amp;&amp;</code></td><td align="left">可重载</td><td align="left">逻辑与运算符</td></tr><tr><td align="left"><code>||</code></td><td align="left">可重载</td><td align="left">逻辑或运算符</td></tr><tr><td align="left"><code>!</code></td><td align="left">可重载</td><td align="left">逻辑非运算符</td></tr><tr><td align="left"><code>~</code></td><td align="left">可重载</td><td align="left">按位取反运算符</td></tr><tr><td align="left"><code>&amp;</code></td><td align="left">可重载</td><td align="left">按位与运算符</td></tr><tr><td align="left"><code>|</code></td><td align="left">可重载</td><td align="left">按位或运算符</td></tr><tr><td align="left"><code>^</code></td><td align="left">可重载</td><td align="left">按位异或运算符</td></tr><tr><td align="left"><code>&lt;&lt;</code></td><td align="left">可重载</td><td align="left">左移运算符</td></tr><tr><td align="left"><code>&gt;&gt;</code></td><td align="left">可重载</td><td align="left">右移运算符</td></tr><tr><td align="left"><code>,</code></td><td align="left">可重载</td><td align="left">逗号运算符</td></tr></tbody></table><h2 id="加减重载（顺便介绍以下重载的基本实现）"><a href="#加减重载（顺便介绍以下重载的基本实现）" class="headerlink" title="加减重载（顺便介绍以下重载的基本实现）"></a>加减重载（顺便介绍以下重载的基本实现）</h2><p><strong>使用成员函数重载运算符</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则：</span></span><br><span class="line"><span class="comment">// 一斤牛肉：2斤猪肉</span></span><br><span class="line"><span class="comment">// 一斤羊肉：3斤猪肉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//羊</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goat</span>&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goat</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//猪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pork</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pork</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        stringstream ret;</span><br><span class="line">        ret &lt;&lt; weight &lt;&lt; <span class="string">&quot;斤猪肉&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cow</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 参数此时定义为引用类型，更合适，避免拷贝</span></span><br><span class="line">    Pork <span class="keyword">operator</span>+(<span class="type">const</span> Cow&amp; cow)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = (<span class="keyword">this</span>-&gt;weight + cow.weight) * <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Pork</span>(tmp);</span><br><span class="line">    &#125;; <span class="comment">//同类型进行运算，很频繁</span></span><br><span class="line"></span><br><span class="line">    Pork <span class="keyword">operator</span>+(<span class="type">const</span> Goat&amp; goat)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="keyword">this</span>-&gt;weight * <span class="number">2</span> + goat.<span class="built_in">getWeight</span>() * <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Pork</span>(tmp);</span><br><span class="line">    &#125;; <span class="comment">//不同类型进行运算，比较少见 </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">c1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Cow <span class="title">c2</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调用c1.operator+(c2);</span></span><br><span class="line">    <span class="comment">//相当于：Pork p = c1.operator+(c2); </span></span><br><span class="line">    Pork p = c1 + c2;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Goat <span class="title">g1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    p = c1 + g1;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用友元函数重载运算符</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则：</span></span><br><span class="line"><span class="comment">// 一斤牛肉：2斤猪肉</span></span><br><span class="line"><span class="comment">// 一斤羊肉：3斤猪肉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//羊</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goat</span>&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goat</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWeight</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//猪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pork</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pork</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        stringstream ret;</span><br><span class="line">        ret &lt;&lt; weight &lt;&lt; <span class="string">&quot;斤猪肉&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cow</span>(<span class="type">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Pork <span class="keyword">operator</span>+(<span class="type">const</span> Cow&amp; cow1, <span class="type">const</span> Cow&amp; cow2); </span><br><span class="line">    <span class="keyword">friend</span> Pork <span class="keyword">operator</span>+(<span class="type">const</span> Cow&amp; cow1, <span class="type">const</span> Goat&amp; goat);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pork <span class="keyword">operator</span>+(<span class="type">const</span> Cow &amp;cow1, <span class="type">const</span> Cow &amp;cow2)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> tmp = (cow<span class="number">1.</span>weight + cow<span class="number">2.</span>weight) * <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pork</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Pork <span class="keyword">operator</span>+(<span class="type">const</span> Cow&amp; cow1, <span class="type">const</span> Goat&amp; goat)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> tmp = cow<span class="number">1.</span>weight * <span class="number">2</span> + goat.<span class="built_in">getWeight</span>() * <span class="number">3</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Pork</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Cow <span class="title">c1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Cow <span class="title">c2</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调用c1.operator+(c2);</span></span><br><span class="line">    <span class="comment">//相当于：Pork p = c1.operator+(c2); </span></span><br><span class="line">    Pork p = c1 + c2;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Goat <span class="title">g1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    p = c1 + g1;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别：</p><p>1.使用成员函数来实现运算符重载时，少写一个参数，因为第一个参数就是 this 指针。</p><p>两种方式的选择：</p><ul><li><p>一般情况下，单目运算符重载，使用成员函数进行重载更方便（不用写参数）</p></li><li><p>一般情况下，双目运算符重载，使用友元函数更直观</p><pre><code>  方便实现 a+b 和 b+a 相同的效果，成员函数方式无法实现。  例如： 100 + cow;          只能通过友元函数来实现        cow +100;           友元函数和成员函数都可以实现特殊情况：</code></pre></li><li><p>&#x3D; （） [ ]  -&gt; 不能重载为类的友元函数！！！（否则可能和 C++的其他规则矛盾），只能使用成员函数形式进行重载。</p></li><li><p>如果运算符的第一个操作数要求使用隐式类型转换，则必须为友元函数（成员函数方式的第一个参数是 this 指针）</p></li><li><p>注意： 同一个运算符重载， 不能同时使用两种方式来重载，会导致编译器不知道选择哪一个（二义性）</p></li></ul><h2 id="重载复制运算符"><a href="#重载复制运算符" class="headerlink" title="重载复制运算符&#x3D;"></a>重载复制运算符&#x3D;</h2><p>注意：</p><ul><li><p>注意赋值运算符重载的返回类型 和参数类型。</p></li><li><p>返回引用类型，便于连续赋值（链式 a &#x3D; b &#x3D; c）</p></li><li><p>参数使用引用类型， 可以省去一次拷贝</p></li><li><p>参数使用const, 便于保护实参不被破坏。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="type">int</span> darkHorse; <span class="comment">//黑马值，潜力系数 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id; <span class="comment">// 编号 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> LAST_ID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name=<span class="literal">NULL</span>, <span class="type">int</span> age=<span class="number">0</span>, <span class="type">int</span> salary=<span class="number">0</span>, <span class="type">int</span> darkHorse=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!name) &#123; </span><br><span class="line">            name = <span class="string">&quot;未命名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age; </span><br><span class="line">        <span class="keyword">this</span>-&gt;salary = salary; </span><br><span class="line">        <span class="keyword">this</span>-&gt;darkHorse = darkHorse; </span><br><span class="line">        <span class="keyword">this</span>-&gt;id = ++LAST_ID;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Boy</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (name) &#123; </span><br><span class="line">            <span class="keyword">delete</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Boy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Boy&amp; boy)&#123;</span><br><span class="line">        <span class="keyword">if</span> (name) &#123; </span><br><span class="line">            <span class="keyword">delete</span> name; <span class="comment">//释放原来的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(boy.name) + <span class="number">1</span>]; <span class="comment">//分配新的内存 </span></span><br><span class="line">        <span class="built_in">strcpy</span>(name,boy.name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = boy.age; </span><br><span class="line">        <span class="keyword">this</span>-&gt;salary = boy.salary; </span><br><span class="line">        <span class="keyword">this</span>-&gt;darkHorse = boy.darkHorse;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = boy.id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        std::stringstream ret;</span><br><span class="line"> </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\t姓名:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\t薪资:&quot;</span></span><br><span class="line">            &lt;&lt; salary &lt;&lt; <span class="string">&quot;\t黑马系数:&quot;</span> &lt;&lt; darkHorse;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// static只能在外面初始化 const才能在里面初始化</span></span><br><span class="line"><span class="type">int</span> Boy::LAST_ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Boy <span class="title">boy1</span><span class="params">(<span class="string">&quot;hacker&quot;</span>, <span class="number">38</span>, <span class="number">58000</span>, <span class="number">10</span>)</span></span>; </span><br><span class="line">    Boy boy2, boy3;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; boy<span class="number">1.</span><span class="built_in">description</span>() &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; boy<span class="number">2.</span><span class="built_in">description</span>() &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; boy<span class="number">3.</span><span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链式</span></span><br><span class="line">    boy3 = boy2 = boy1; </span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; boy<span class="number">2.</span><span class="built_in">description</span>() &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; boy<span class="number">3.</span><span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载复制运算符-1"><a href="#重载复制运算符-1" class="headerlink" title="重载复制运算符&#x3D;"></a>重载复制运算符&#x3D;</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="type">int</span> darkHorse; <span class="comment">//黑马值，潜力系数 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id; <span class="comment">// 编号 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> LAST_ID;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">// 薪资* 黑马系数 + (100 - 年龄） * 1000</span></span><br><span class="line">        <span class="type">int</span> value = salary * darkHorse + (<span class="number">100</span> - age) * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name=<span class="literal">NULL</span>, <span class="type">int</span> age=<span class="number">0</span>, <span class="type">int</span> salary=<span class="number">0</span>, <span class="type">int</span> darkHorse=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!name) &#123; </span><br><span class="line">            name = <span class="string">&quot;未命名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age; </span><br><span class="line">        <span class="keyword">this</span>-&gt;salary = salary; </span><br><span class="line">        <span class="keyword">this</span>-&gt;darkHorse = darkHorse; </span><br><span class="line">        <span class="keyword">this</span>-&gt;id = ++LAST_ID;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Boy</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (name) &#123; </span><br><span class="line">            <span class="keyword">delete</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        std::stringstream ret;</span><br><span class="line"> </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\t姓名:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\t薪资:&quot;</span></span><br><span class="line">            &lt;&lt; salary &lt;&lt; <span class="string">&quot;\t黑马系数:&quot;</span> &lt;&lt; darkHorse;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Boy&amp; boy)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">power</span>() &gt; boy.<span class="built_in">power</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Boy&amp; boy)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">power</span>() &lt; boy.<span class="built_in">power</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Boy&amp; boy)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">power</span>() == boy.<span class="built_in">power</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// static只能在外面初始化 const才能在里面初始化</span></span><br><span class="line"><span class="type">int</span> Boy::LAST_ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Boy <span class="title">boy1</span><span class="params">(<span class="string">&quot;hacker&quot;</span>, <span class="number">38</span>, <span class="number">58000</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="function">Boy <span class="title">boy2</span><span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">25</span>, <span class="number">50000</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boy1 &gt; boy2) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;选择boy1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (boy1 == boy2) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;难以选择&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;选择boy2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符[ ]"></a>重载运算符[ ]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* name; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line">    <span class="type">int</span> darkHorse; <span class="comment">//黑马值，潜力系数 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id; <span class="comment">// 编号 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> LAST_ID;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">// 薪资* 黑马系数 + (100 - 年龄） * 1000</span></span><br><span class="line">        <span class="type">int</span> value = salary * darkHorse + (<span class="number">100</span> - age) * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name=<span class="literal">NULL</span>, <span class="type">int</span> age=<span class="number">0</span>, <span class="type">int</span> salary=<span class="number">0</span>, <span class="type">int</span> darkHorse=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!name) &#123; </span><br><span class="line">            name = <span class="string">&quot;未命名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age; </span><br><span class="line">        <span class="keyword">this</span>-&gt;salary = salary; </span><br><span class="line">        <span class="keyword">this</span>-&gt;darkHorse = darkHorse; </span><br><span class="line">        <span class="keyword">this</span>-&gt;id = ++LAST_ID;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Boy</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (name) &#123; </span><br><span class="line">            <span class="keyword">delete</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        stringstream ret;</span><br><span class="line"> </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\t姓名:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\t薪资:&quot;</span></span><br><span class="line">            &lt;&lt; salary &lt;&lt; <span class="string">&quot;\t黑马系数:&quot;</span> &lt;&lt; darkHorse;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](string index)&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="string">&quot;age&quot;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="string">&quot;salary&quot;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> salary;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="string">&quot;darkHorse&quot;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> darkHorse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="string">&quot;power&quot;</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">power</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> salary;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> darkHorse;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">3</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">power</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// static只能在外面初始化 const才能在里面初始化</span></span><br><span class="line"><span class="type">int</span> Boy::LAST_ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Boy <span class="title">boy1</span><span class="params">(<span class="string">&quot;hacker&quot;</span>, <span class="number">38</span>, <span class="number">58000</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="function">Boy <span class="title">boy2</span><span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">25</span>, <span class="number">50000</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; boy1[<span class="string">&quot;age&quot;</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;salary:&quot;</span> &lt;&lt; boy1[<span class="string">&quot;salary&quot;</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;darkHorse:&quot;</span> &lt;&lt; boy1[<span class="string">&quot;darkHorse&quot;</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;power:&quot;</span> &lt;&lt; boy1[<span class="string">&quot;power&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[0]:&quot;</span> &lt;&lt; boy1[<span class="number">0</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[1]:&quot;</span> &lt;&lt; boy1[<span class="number">1</span>] &lt;&lt; endl; cout &lt;&lt; <span class="string">&quot;[2]:&quot;</span> &lt;&lt; boy1[<span class="number">2</span>] &lt;&lt;     endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[3]:&quot;</span> &lt;&lt; boy1[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-了解"><a href="#重载-了解" class="headerlink" title="重载&lt;&lt;和&gt;&gt; 了解"></a>重载&lt;&lt;和&gt;&gt; 了解</h2><p>为了更方便的实现复杂对象的输入和输出。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//友元</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Boy&amp; boy);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Boy&amp; boy);</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Boy&amp; boy) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; boy.id &lt;&lt; <span class="string">&quot;\t姓名:&quot;</span> &lt;&lt; boy.name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; boy.age &lt;&lt; <span class="string">&quot;\t薪资:&quot;</span></span><br><span class="line">                &lt;&lt; boy.salary &lt;&lt; <span class="string">&quot;\t黑马系数:&quot;</span> &lt;&lt; boy.darkHorse;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Boy&amp; boy)</span><br><span class="line">&#123;</span><br><span class="line">    string name2;</span><br><span class="line"> </span><br><span class="line">    is &gt;&gt; name2 &gt;&gt; boy.age &gt;&gt; boy.salary &gt;&gt; boy.darkHorse;</span><br><span class="line">    boy.name = (<span class="type">char</span>*)<span class="built_in">malloc</span>((name<span class="number">2.l</span>ength()<span class="number">+1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strcpy_s</span>(boy.name, name<span class="number">2.l</span>ength() + <span class="number">1</span>, name<span class="number">2.</span><span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通类型-类类型-了解"><a href="#普通类型-类类型-了解" class="headerlink" title="普通类型 &#x3D;&gt; 类类型 了解"></a>普通类型 &#x3D;&gt; 类类型 了解</h2><p>调用对应的只有一个参数【参数的类型就是这个普通类型】的构造函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Boy boy1 = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 薪资</span></span><br><span class="line">构造函数<span class="built_in">Boy</span>(<span class="type">int</span>);</span><br><span class="line">Boy boy2 = <span class="string">&quot;hacker&quot;</span></span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line">构造函数 <span class="built_in">Boy</span>(<span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age, <span class="type">int</span> salary, <span class="type">int</span> darkHorse);</span><br><span class="line">~<span class="built_in">Boy</span>();</span><br><span class="line"><span class="built_in">Boy</span>(<span class="type">int</span> salary);</span><br><span class="line"><span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp文件</span></span><br><span class="line">Boy::<span class="built_in">Boy</span>(<span class="type">int</span> salary)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *defaultName = <span class="string">&quot;未命名&quot;</span>;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(defaultName) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(name, <span class="built_in">strlen</span>(defaultName) + <span class="number">1</span>, defaultName);</span><br><span class="line">    age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">    darkHorse = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;id = ++LAST_ID;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Boy::<span class="built_in">Boy</span>(<span class="type">const</span> <span class="type">char</span>* name) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;name, <span class="built_in">strlen</span>(name) + <span class="number">1</span>, name);</span><br><span class="line">    age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;salary = <span class="number">0</span>;</span><br><span class="line">    darkHorse = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;id = ++LAST_ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类类型-普通类型-了解"><a href="#类类型-普通类型-了解" class="headerlink" title="类类型 &#x3D;&gt; 普通类型 了解"></a>类类型 &#x3D;&gt; 普通类型 了解</h2><p>调用特殊的运算符重载函数，类型转换函数，不需要写返回类型</p><p>类型转换函数：operator 普通类型 ( )</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Boy <span class="title">boy1</span><span class="params">(“hacker”, <span class="number">28</span>, <span class="number">10000</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> power = boy1; <span class="comment">// power();</span></span><br><span class="line"><span class="type">char</span> *name = boy1; <span class="comment">// “hacker</span></span><br><span class="line"></span><br><span class="line"><span class="function">Boy::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">power</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Boy::<span class="keyword">operator</span> <span class="type">char</span>* () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头</span></span><br><span class="line"><span class="comment">// 特殊的运算符重载：类型转换函数，不需要写返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">operator</span> <span class="type">char</span>* () <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line"><span class="function">Boy::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">power</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Boy::<span class="keyword">operator</span> <span class="type">char</span>* () <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ friend</title>
      <link href="/2025/04/13/C++friend/"/>
      <url>/2025/04/13/C++friend/</url>
      
        <content type="html"><![CDATA[<h1 id="C-友元"><a href="#C-友元" class="headerlink" title="C++友元"></a>C++友元</h1><p>使用前提：某个类需要实现某种功能，但是这个类自身，因为各种原因，无法自己实现。</p><p>需要借助于“外力”才能实现。</p><p>友元的两种使用形式：友元函数、友元类。</p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><h3 id="使用全局函数作为友元函数"><a href="#使用全局函数作为友元函数" class="headerlink" title="使用全局函数作为友元函数"></a>使用全局函数作为友元函数</h3><p>全局函数可以直接访问类内的私有成员！！！！！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>()&#123;</span><br><span class="line">        cpu = <span class="string">&quot;i7&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用全局函数作为友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringstream ret; </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;CPU:&quot;</span> &lt;&lt; cpu; </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string cpu; <span class="comment">//CPU芯片</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接访问对象的私有数据成员！！！! ! ! ! !</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span> </span>&#123;</span><br><span class="line">    computer-&gt;cpu = <span class="string">&quot;i9&quot;</span>; <span class="comment">//直接访问对象的私有数据成员！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer shanxing; </span><br><span class="line">    cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">upgrade</span>(&amp;shanxing);</span><br><span class="line">    cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用类的成员函数作为友元函数"><a href="#使用类的成员函数作为友元函数" class="headerlink" title="使用类的成员函数作为友元函数"></a>使用类的成员函数作为友元函数</h3><p>和使用全局函数差不多，但是这里要注意声明和实现的顺序！！！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerService</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>()&#123;</span><br><span class="line">        cpu = <span class="string">&quot;i7&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用全局函数作为友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">ComputerService::upgrade</span><span class="params">(Computer* computer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringstream ret; </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;CPU:&quot;</span> &lt;&lt; cpu; </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string cpu; <span class="comment">//CPU 芯片</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComputerService成员函数的实现（此时Computer已定义，可访问私有成员）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputerService::upgrade</span><span class="params">(Computer* computer)</span> </span>&#123;</span><br><span class="line">    computer-&gt;cpu = <span class="string">&quot;i9&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接访问对象的私有数据成员！！！! ! ! ! !</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span> </span>&#123;</span><br><span class="line">    computer-&gt;cpu = <span class="string">&quot;i9&quot;</span>; <span class="comment">//直接访问对象的私有数据成员！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer shanxing; </span><br><span class="line">    ComputerService service;</span><br><span class="line">    std::cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line">    service.<span class="built_in">upgrade</span>(&amp;shanxing);</span><br><span class="line">    std::cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能上，这两种形式，都是相同，应用场合不同。</p><p>一个是，使用普通的全局函数，作为自己的朋友，实现特殊功能。</p><p>一个是，使用其他类的成员函数，作为自己的朋友，实现特殊功能。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p><strong>为什么要使用友元类</strong></p><p>一个独立的咨询师， 给其他企业做服务时，这个咨询师作为企业的“友元函数”即可。</p><p>一个大型的咨询服务公司，比如 IBM（IT 事务）, 普华永道（会计事务），给其他企业做服务时，使用友元函数就不是很方便了，因为需要设计很多友元函数，不方便。</p><p>解决方案：使用“友元类”</p><p><strong>友元类的作用</strong></p><p>如果把 A 类作为 B 类的友元类，那么 A 类的所有成员函数【在 A 类的成员函数内】，就可以直接访问【使用】B 类的私有成员。</p><p>即，友元类可以直接访问对应类的所有成员！！！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComComputerServiceputer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>()&#123;</span><br><span class="line">        cpu = <span class="string">&quot;i7&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringstream ret; </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;CPU:&quot;</span> &lt;&lt; cpu; </span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string cpu; <span class="comment">//CPU 芯片</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ComputerService</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元类可以直接访问声明类之中的所有的参数，包括私有参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerService</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upgrade</span><span class="params">(Computer* computer)</span></span>&#123;</span><br><span class="line">        computer-&gt;cpu = <span class="string">&quot;i9&quot;</span>;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(Computer* computer)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;正在对电脑执行清理[CPU:&quot;</span></span><br><span class="line">        &lt;&lt; computer-&gt;cpu &lt;&lt; <span class="string">&quot;]...&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    &#125;; <span class="comment">//计算机清理 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">kill</span><span class="params">(Computer* computer)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;正在对电脑执行杀毒[CPU:&quot;</span></span><br><span class="line">        &lt;&lt; computer-&gt;cpu &lt;&lt; <span class="string">&quot;]...&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    &#125;; <span class="comment">//杀毒</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer shanxing; </span><br><span class="line">    ComputerService service;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line">    service.<span class="built_in">upgrade</span>(&amp;shanxing); </span><br><span class="line">    service.<span class="built_in">clean</span>(&amp;shanxing); </span><br><span class="line">    service.<span class="built_in">kill</span>(&amp;shanxing);</span><br><span class="line">    std::cout &lt;&lt; shanxing.<span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：友元类，和友元函数，使用 friend 关键字进行声明即可，与访问权限无关，所以，可以放在 private&#x2F;pulic&#x2F;protected 任意区域内</p><p>说实话，这有点破坏class良好的封装性了，如果是我的话，除非必须要用，否则尽量不用</p>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ exception</title>
      <link href="/2025/04/13/C++exception/"/>
      <url>/2025/04/13/C++exception/</url>
      
        <content type="html"><![CDATA[<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h1><p>异常无处不在，程序随时可能误入歧途！C++ 提出了新的异常处理机制！</p><p>异常是一种程序控制机制，与函数机制互补</p><p>函数是一种以栈结构展开的上下函数衔接的程序控制系统,异常是另一种控制结构,它可以在出现“意外”时中断当前函数,并以某种机制（类型匹配）回馈给隔代的调用者相关的信息.</p><h2 id="传统错误处理机制"><a href="#传统错误处理机制" class="headerlink" title="传统错误处理机制"></a>传统错误处理机制</h2><p>通过函数返回值来处理错误</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//实现文件的二进制拷贝</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">copyfile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest,<span class="type">const</span> <span class="type">char</span> *src)</span></span>&#123;</span><br><span class="line">FILE *fp1 = <span class="literal">NULL</span>, *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//rb 只读方式打开一个二进制文件，只允许读取数据</span></span><br><span class="line"><span class="built_in">fopen_s</span>(&amp;fp1, src, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(fp1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//wb 以只写的方式打开或新建一个二进制文件，只允许写数据。</span></span><br><span class="line"><span class="built_in">fopen_s</span>(&amp;fp2, dest, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> buffer[BUFSIZE];</span><br><span class="line"><span class="type">int</span> readlen, writelen;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果读到数据，则大于0</span></span><br><span class="line"><span class="keyword">while</span>( (readlen = <span class="built_in">fread</span>(buffer, <span class="number">1</span>, BUFSIZE, fp1)) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">writelen = <span class="built_in">fwrite</span>(buffer, <span class="number">1</span>, readlen, fp2);</span><br><span class="line"><span class="keyword">if</span>(readlen != writelen)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fclose</span>(fp1);</span><br><span class="line"><span class="built_in">fclose</span>(fp2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = <span class="built_in">copyfile</span>(<span class="string">&quot;c:/test/dest.txt&quot;</span>, <span class="string">&quot;c:/test/src.txt&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">switch</span>(ret)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开源文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开目标文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;拷贝文件时失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出现未知的情况!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-异常处理基本语法"><a href="#C-异常处理基本语法" class="headerlink" title="C++异常处理基本语法"></a>C++异常处理基本语法</h2><p>异常发生第一现场，抛出异常</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">function</span><span class="params">( )</span></span>&#123;</span><br><span class="line"><span class="comment">//... ...</span></span><br><span class="line">  <span class="keyword">throw</span> 表达式;</span><br><span class="line"><span class="comment">//... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要关注异常的地方，捕捉异常</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//程序</span></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"><span class="comment">//程序</span></span><br><span class="line"> </span><br><span class="line">&#125;<span class="built_in">catch</span>(异常类型声明)&#123;</span><br><span class="line"><span class="comment">//... 异常处理代码 ...</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(异常类型 形参)&#123;</span><br><span class="line"><span class="comment">//... 异常处理代码 ...</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)&#123; <span class="comment">//其它异常类型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++之中有一些已经定义好的异常类型</p><p><img src="/../0_images/C++exception/1_%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B.png" alt="alt text"></p><ul><li><code>std::exception</code>：该异常是所有标准 C++ 异常的父类。</li><li><code>std::bad_alloc</code>：该异常可以通过 <code>new</code> 抛出。</li><li><code>std::bad_cast</code>：该异常可以通过 <code>dynamic_cast</code> 抛出。</li><li><code>std::bad_typeid</code>：该异常可以通过 <code>typeid</code> 抛出。</li><li><code>std::bad_exception</code>：这在处理 C++ 程序中无法预期的异常时非常有用。</li><li><code>std::logic_error</code>：理论上可以通过读取代码来检测到的异常。</li><li><code>std::domain_error</code>：当使用了一个无效的数学域时，会抛出该异常。</li><li><code>std::invalid_argument</code>：当使用了无效的参数时，会抛出该异常。</li><li><code>std::length_error</code>：当创建了太长的 <code>std::string</code> 时，会抛出该异常。</li><li><code>std::out_of_range</code>：该异常可以通过方法抛出，例如 <code>std::vector</code> 和 <code>std::bitset&lt;&gt;::operator</code>。</li><li><code>std::runtime_error</code>：理论上不可以通过读取代码来检测到的异常。</li><li><code>std::overflow_error</code>：当发生数学上溢时，会抛出该异常。</li><li><code>std::range_error</code>：当尝试存储超出范围的值时，会抛出该异常。</li><li><code>std::underflow_error</code>：当发生数学下溢时，会抛出该异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ class</title>
      <link href="/2025/04/13/C++class/"/>
      <url>/2025/04/13/C++class/</url>
      
        <content type="html"><![CDATA[<h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><p><strong>资料</strong></p><p><a href="https://blog.csdn.net/m0_65635427/article/details/132167140">https://blog.csdn.net/m0_65635427/article/details/132167140</a></p><h2 id="基本的小概念"><a href="#基本的小概念" class="headerlink" title="基本的小概念"></a>基本的小概念</h2><p><strong>面向过程</strong>：根据程序的执行过程，来设计软件的所有细节。开发大型项目时，越来越难以把控，甚至失去控制。后期维护、更新成本很大。</p><p><strong>类的使用</strong></p><p>面向对象编程，最重要的第一个概念：类</p><p>“人类”是一个抽象的概念，不是具体的某个人。</p><p>“类”，是看不见，摸不着的，是一个纯粹的概念.</p><p>“类”，是一种特殊的“数据类型”，不是一个具体的数据。</p><p>注意：类， 和基本数据类型（char&#x2F;int&#x2F;short&#x2F;long&#x2F;long long&#x2F;float&#x2F;double）不同类的构成：方法和数据</p><p>类是由：方法 + 数据 构成的</p><p><strong>对象</strong></p><p>对象，是一个特定“类”的具体实例。</p><p>一般地，一个对象，就是一个特殊的变量，但是有跟丰富的功能和用法。</p><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>在创建一个新的对象时，自动调用的函数，用来进行“初始化”工作：对这个对象内部的数据成员进行初始化</p><p>构造函数的特点：</p><ol><li><p>自动调用（在创建新对象时，自动调用）</p></li><li><p>构造函数的函数名，和类名相同</p></li><li><p>构造函数没有返回类型</p></li><li><p>可以有多个构造函数（即函数重载形式）</p></li><li><p>没有参数的构造函数为默认构造函数</p></li></ol><p><strong>默认构造函数</strong></p><p>注意：没有手动定义默认构造函数时，编译器自动为这个类定义一个构造函数。</p><p>如果数据成员使用了“类内初始值”，就使用这个值来初始化数据成员。【C++11】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age = <span class="number">18</span>; <span class="comment">//在定义类的属性的时候就直接初始化，就是类内初始值</span></span><br></pre></td></tr></table></figure><p>否则，就使用默认初始化（实际上，不做任何初始化）</p><p>只要手动定义了任何一个构造函数，编译器就不会生成“合成的默认构造函数” 一般情况下，都应该定义自己的构造函数，不要使用“合成的默认构造函数”【仅当数据成员全部使用了“类内初始值”，才宜使用“合成的默认构造函数”</p><p>一个典型案例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>(); <span class="comment">//构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//方法， “成员函数”</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSalary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Human::<span class="built_in">Human</span>() &#123; </span><br><span class="line">    name = <span class="string">&quot;无名氏&quot;</span>; </span><br><span class="line">    age = <span class="number">18</span>; </span><br><span class="line">    salary = <span class="number">30000</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;吃炸鸡，喝啤酒！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::sleep</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我正在睡觉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::play</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我在唱歌! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::work</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我在工作...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">Human::getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getAge</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getSalary</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Humanh1;<span class="comment">// 使用自定义的默认构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; h<span class="number">1.</span><span class="built_in">getName</span>() &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; h<span class="number">1.</span><span class="built_in">getAge</span>() &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;薪资：&quot;</span> &lt;&lt; h<span class="number">1.</span><span class="built_in">getSalary</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重载构造函数</strong></p><p>对构造函数进行重载(传入的参数的数量和类型不同等)</p><p>对上面案例进行修改：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Human</span>(<span class="type">int</span> age, <span class="type">int</span> salary); <span class="comment">//重载构造函数</span></span><br><span class="line"></span><br><span class="line">Human::<span class="built_in">Human</span>(<span class="type">int</span> age, <span class="type">int</span> salary) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用自定义的构造函数&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;<span class="comment">//this 是一个特殊的指针，指向这个对象本身 </span></span><br><span class="line">    <span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">    name = <span class="string">&quot;无名&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果某数据成员使用类内初始值，同时又在构造函数中进行了初始化，那么以构造函数中的初始化为准。相当于构造函数中的初始化，会覆盖对应的类内初始值。</p><p><strong>拷贝构造函数</strong></p><p><strong>浅拷贝</strong>:简单的赋值拷贝操作</p><ol><li><p>浅拷贝指的是对象的逐位复制：</p></li><li><p>当一个对象被浅拷贝时，所有的成员变量都会直接复制其值，包括指针类型的成员变量。</p></li><li><p>对于指针成员，浅拷贝只复制指针的值（即内存地址），而不复制指针所指向的数据。这意味着原对象和拷贝对象的指针成员将指向同一块内存地址。</p></li></ol><p><strong>第二点和第三点尤其要注意</strong>，这是浅拷贝的重大隐患，也就是说，指针数据 浅拷贝 只会简单的拷贝指针所指向的地址，而不是指针内部所存储的地址的内容，如果，因此就会出现修改两个不同的对象的属性，反而是的修改之后的属性相同（也就是说两个或者多个对象共享了同一个地址），这样也会出现另外一个重要的问题，就是说，在析构函数的时候如果要释放掉这些指针，就会导致<strong>多重释放</strong>。会出现异常！！！！！</p><p>简单样例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这代码是有问题的，没做析构，没释放内存！！！</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义一个“人类”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>();</span><br><span class="line">    <span class="built_in">Human</span>(<span class="type">int</span> age, <span class="type">int</span> salary);</span><br><span class="line"><span class="comment">//Human(const Human&amp;);//不定义拷贝构造函数，编译器会生成“合成的拷贝构造函数”</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSalary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *newAddr)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getAddr</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;Unknown&quot;</span>; </span><br><span class="line">    <span class="type">int</span> age = <span class="number">28</span>;</span><br><span class="line">    <span class="type">int</span> salary; </span><br><span class="line">    <span class="type">char</span> *addr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Human::<span class="built_in">Human</span>() &#123; </span><br><span class="line">    name = <span class="string">&quot;无名氏&quot;</span>; </span><br><span class="line">    age = <span class="number">18</span>; </span><br><span class="line">    salary = <span class="number">30000</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Human::<span class="built_in">Human</span>(<span class="type">int</span> age, <span class="type">int</span> salary) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用自定义的构造函数&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;<span class="comment">//this 是一个特殊的指针，指向这个对象本身 </span></span><br><span class="line">    <span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">    name = <span class="string">&quot;无名&quot;</span>;</span><br><span class="line">    addr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">64</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(addr, <span class="string">&quot;China&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;吃炸鸡，喝啤酒！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::sleep</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我正在睡觉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::play</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我在唱歌! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::work</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我在工作...&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">Human::getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getAge</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getSalary</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::setAddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *newAddr)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!newAddr) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr,newAddr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Human::getAddr</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Human<span class="title">h1</span><span class="params">(<span class="number">25</span>, <span class="number">35000</span>)</span></span>;<span class="comment">// 使用自定义的默认构造函数 </span></span><br><span class="line">    <span class="function">Human<span class="title">h2</span><span class="params">(h1)</span></span>;<span class="comment">// 使用自定义的拷贝构造函数</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;h1 addr:&quot;</span> &lt;&lt; h<span class="number">1.</span><span class="built_in">getAddr</span>() &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;h2 addr:&quot;</span> &lt;&lt; h<span class="number">2.</span><span class="built_in">getAddr</span>() &lt;&lt; endl; </span><br><span class="line">    h<span class="number">1.</span><span class="built_in">setAddr</span>(<span class="string">&quot;长沙&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;h1 addr:&quot;</span> &lt;&lt; h<span class="number">1.</span><span class="built_in">getAddr</span>() &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;h2 addr:&quot;</span> &lt;&lt; h<span class="number">2.</span><span class="built_in">getAddr</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">调用自定义的构造函数</span><br><span class="line">h1 addr:China</span><br><span class="line">h2 addr:China</span><br><span class="line">h1 addr:长沙</span><br><span class="line">h2 addr:长沙</span><br></pre></td></tr></table></figure><p><strong>深拷贝</strong>:在堆区重新申请空间，进行拷贝操作</p><ol><li><p>深拷贝不仅复制对象的值，还复制指针指向的数据：</p></li><li><p>当进行深拷贝时，不仅对象的基本成员变量被复制，对于指针类型的成员变量，还会动态分配一块新的内存，复制原对象指针指向的内容到新分配的内存中。</p></li><li><p>这样，原对象和拷贝对象的指针成员就分别指向不同的内存地址，互不干扰。这避免了浅拷贝中的资源竞争或双重释放等问题。</p></li></ol><p>样例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Human</span>(<span class="type">const</span> Human&amp;); <span class="comment">//声明</span></span><br><span class="line">    <span class="comment">//实现</span></span><br><span class="line">    Human::<span class="built_in">Human</span>(<span class="type">const</span> Human &amp;man) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用自定义的拷贝构造函数&quot;</span> &lt;&lt; endl; </span><br><span class="line">        age = man.age;<span class="comment">//this 是一个特殊的指针，指向这个对象本身 </span></span><br><span class="line">        salary = man.salary; </span><br><span class="line">        name = man.name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深度拷贝</span></span><br><span class="line">        addr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">64</span>]; </span><br><span class="line">        <span class="built_in">strcpy</span>(addr,man.addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">调用自定义的构造函数</span><br><span class="line">调用自定义的拷贝构造函数</span><br><span class="line">h1 addr:China</span><br><span class="line">h2 addr:China</span><br><span class="line">h1 addr:长沙</span><br><span class="line">h2 addr:China</span><br></pre></td></tr></table></figure><p><strong>赋值构造函数</strong> 对&#x3D;进行重载</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Human&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Human &amp;);</span><br><span class="line">Human&amp; Human::<span class="keyword">operator</span>=(<span class="type">const</span> Human &amp;man) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用&quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;man) &#123; </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//检测是不是对自己赋值：比如 h1 = h1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="built_in">strcpy</span>(addr, man.addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他数据成员</span></span><br><span class="line">    name = man.name; </span><br><span class="line">    age = man.age; </span><br><span class="line">    salary = man.salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回该对象本身的引用， 以便做链式连续处理，比如 a = b = c; </span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有定义赋值构造函数，编译器会自动定义“合成的赋值构造函数”，与其他合成的构造函数，是“浅拷贝”（又称为“位拷贝”）。</p><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>作用：对象销毁前，做清理工作。</p><ol><li><p>具体的清理工作，一般和构造函数对应</p></li><li><p>比如：如果在构造函数中，使用 new 分配了内存，就需在析构函数中用 delete 释放。</p></li><li><p>如果构造函数中没有申请资源（主要是内存资源），那么很少使用析构函数。<br>如果不定义，编译器会自动生成一个析构函数（什么也不做）</p></li><li><p>没有返回值，没有参数，最多只能有一个析构函数（<strong>析构函数不能重载</strong>）</p></li><li><p>访问权限一般是public，并且不可以主动调用，一般是对象销毁时，自动调用。</p></li><li><p>如果不定义，编译器会自动生成一个析构函数（什么也不做）</p></li></ol><p>类的构造函数中的那几个例子，就需要我们手动创建析构函数对申请的内存空间进行释放</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Human::~<span class="built_in">Human</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用了析构函数！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> [] addr;   <span class="comment">//释放调内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ol><li><p>定义：this 是一个指向类实例本身的指针，它在成员函数内部自动定义并可用。</p></li><li><p>类型：this 的类型是指向当前类类型的指针。例如，在类 MyClass 的成员函数内部，this 的类型是 MyClass*。</p></li><li><p>访问：虽然不需要显式地传递 this 指针给成员函数，但可以在函数体内通过 this 来访问类的成员。</p></li><li><p>自动传递：当调用一个对象的成员函数时，不需要显式地传递 this 指针。编译器会自动处理它。this 指针作为隐藏参数传递给成员函数，使得成员函数能够知道它属于哪个对象。</p></li><li><p>用途：this 指针主要用于以下几种情况：</p><ul><li><p>访问调用对象的成员变量和成员函数。</p></li><li><p>返回当前对象的引用或指针（如链式调用）。</p></li><li><p>在成员函数内部，区分成员变量和局部变量（如果它们同名）。</p></li></ul></li><li><p>特性：</p><ul><li><p>this指针只能在成员函数的内部使用，且由编译器自动传递，用户无需显式传递。</p></li><li><p>this指针不是对象的一部分，不影响对象的大小（即不影响sizeof运算符的结果）。</p></li><li><p>this指针在成员函数的调用期间始终有效，指向调用该函数的对象。</p></li></ul></li><li><p>在类的静态成员函数中，不能使用this指针！(静态成员不属于任何一个对象)</p></li><li><p>this 不能指向其他对象，只能指向本身</p></li></ol><p>例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="type">double</span> width;  </span><br><span class="line">        <span class="type">double</span> height;  </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 构造函数  </span></span><br><span class="line">        <span class="built_in">Box</span>(<span class="type">double</span> width, <span class="type">double</span> height) &#123;</span><br><span class="line">            <span class="comment">//区分局部变量和成员变量</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;width = width;</span><br><span class="line">            <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 成员函数，用于计算盒子的体积  </span></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> width * height;  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 成员函数，使用 this 指针返回指向当前对象的指针  </span></span><br><span class="line">        <span class="function">Box* <span class="title">getBiggerBox</span><span class="params">(<span class="type">double</span> extraWidth, <span class="type">double</span> extraHeight)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>-&gt;width += extraWidth; <span class="comment">// 使用 this 指针访问成员变量  </span></span><br><span class="line">            <span class="keyword">this</span>-&gt;height += extraHeight;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回当前对象的指针  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(Box* obj)</span></span>&#123;  </span><br><span class="line">    cout&lt;&lt;obj-&gt;<span class="built_in">getVolume</span>()&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">Box <span class="title">myBox</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original Volume: &quot;</span> &lt;&lt; myBox.<span class="built_in">getVolume</span>() &lt;&lt; endl;  </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用 getBiggerBox 成员函数改变 myBox 的尺寸，并返回 myBox 的引用  链式调用</span></span><br><span class="line">    Box* biggerBox = myBox.<span class="built_in">getBiggerBox</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)-&gt;<span class="built_in">getBiggerBox</span>(<span class="number">1.0</span>,<span class="number">1.0</span>);  </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 输出改变后的体积  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bigger Volume: &quot;</span> &lt;&lt; biggerBox-&gt;<span class="built_in">getVolume</span>() &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">processObject</span>(myBox.<span class="built_in">getBiggerBox</span>(<span class="number">1.0</span>, <span class="number">1.0</span>));</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态数据-与-静态函数"><a href="#静态数据-与-静态函数" class="headerlink" title="静态数据 与 静态函数"></a>静态数据 与 静态函数</h2><p><strong>静态数据</strong></p><p>需求分析：需要获取总的实例的个数，如何实现？</p><p>只能使用一个全局变量，然后在构造函数中对这个全局变量进行修改（加 1）缺点：使用全局变量不方便，破坏程序的封装性。</p><p>因此便引入了静态数据</p><p><strong>注意点：</strong></p><ul><li><p>对于非 const 的类静态成员，只能在类的实现文件中初始化。</p></li><li><p>const 类静态成员，可以在类内设置初始值，也可以在类的实现文件中设置初始值。（但是不要同时在这两个地方初始化，只能初始化 1 次）</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">Human</span>();</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于非 const 的类静态成员，只能在类的实现文件中初始化。</span></span><br><span class="line"><span class="type">int</span> Human::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Human::<span class="built_in">Human</span>()&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human::~<span class="built_in">Human</span>()&#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Human h1;</span><br><span class="line">    cout &lt;&lt; h<span class="number">1.</span><span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Human h2; </span><br><span class="line">    cout &lt;&lt; h<span class="number">1.</span><span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Human h3; </span><br><span class="line">        cout &lt;&lt; h<span class="number">1.</span><span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; h<span class="number">1.</span><span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态函数</strong></p><p>需求：</p><p>当需要获取总的人数时，还必须通过一个对象来访问，比如 h1.getCount().</p><p>如果当前没有可用的对象时，就非常尴尬，不能访问 getCount()!</p><p>如果为了访问总的人数，而特意去创建一个对象，就很不方便，而且得到的总人数还不真实（包含了一个没有实际用处的人）</p><p>解决方法：把 getCount()方法定义为类的静态方法！</p><p>注意点：</p><ul><li><p>可以直接通过类来访问【更常用】，也可以通过对象（实例）来访问。</p></li><li><p>在类的静态方法中，不能访问普通数据成员和普通成员函数（对象的数据成员和成员函数）</p></li></ul><p>样例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>();</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">Human</span>();</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于非 const 的类静态成员，只能在类的实现文件中初始化。</span></span><br><span class="line"><span class="type">int</span> Human::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Human::<span class="built_in">Human</span>()&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现的时候不用家static！！！</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Human::getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human::~<span class="built_in">Human</span>()&#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Human::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Human h1;</span><br><span class="line">    cout &lt;&lt; Human::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Human h2; </span><br><span class="line">    cout &lt;&lt; Human::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Human h3; </span><br><span class="line">        cout &lt;&lt; Human::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Human::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.静态数据成员对象的成员函数（没有 static 的成员函数）内部，可以直接访问“静态数据成员” </p><p>类的静态成员函数（有 static 的成员函数）内部，可以直接访问“静态数据成员” </p><p>即：所有的成员函数，都可以访问静态数据成员。</p><p>类可以直接访问public静态数据成员（Human::humanCount 非法）</p><p>2.静态成员函数</p><p>对象可以直接访问静态成员函数</p><p>类可以直接访问静态成员函数（Human::getHumanCount()）在类的静态成员函数（类的静态方法）内部，不能直接访问 this 指针和对象的数据成员！在类的静态成员函数（类的静态方法）内部，只能访问类的数据成员</p><h2 id="常成员（常成员数据和常成员函数）"><a href="#常成员（常成员数据和常成员函数）" class="headerlink" title="常成员（常成员数据和常成员函数）"></a>常成员（常成员数据和常成员函数）</h2><p><strong>常成员数据</strong></p><p>需求：怎样表示人的“血型”？血型可以修改吗？</p><p>把血型定义为 const 数据类型（常量数据成员）</p><p>const 数据成员的初始化方式：</p><ul><li><p>使用类内值（C++11 支持）</p></li><li><p>使用构造函数的初始化列表</p></li></ul><p><strong>常成员函数</strong></p><p>const 的 Human 对象，不能调用普通的成员函数。</p><p><strong>原因</strong>： C++认为，const(常量)对象，如果允许去调用普通的成员函数，而这个成员函数内部可能会修改这个对象的数据成员！而这讲导致 const 对象不再是 const 对象！</p><p>如果一个成员函数内部，不会修改任何数据成员，就把它定义为 const 成员函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">description</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//注意，const的位置</span></span><br><span class="line">    ~<span class="built_in">Human</span>();</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string bloodType;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Human::count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//使用初始化列表，对const数据成员初始化</span></span><br><span class="line">Human::<span class="built_in">Human</span>():<span class="built_in">bloodType</span>(<span class="string">&quot;A&quot;</span>)&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，const的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Human::description</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; bloodType:&quot;</span> &lt;&lt; bloodType &lt;&lt; endl; <span class="comment">//其他成员函数可以“读”const变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human::~<span class="built_in">Human</span>()&#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Human h1;</span><br><span class="line"> </span><br><span class="line">    h<span class="number">1.</span><span class="built_in">description</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const 成员函数内，不能修改任何数据成员！</p><p>C++的成员函数设置建议：如果一个对象的成员函数，不会修改任何数据成员，那么就强烈：把这个成员函数，定义为 const 成员函数！</p><h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><p><strong>基础定义</strong></p><p><img src="/../0_images/C++class/1_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F.png" alt="alt text"></p><p>除了“构造函数”和“析构函数”，</p><p>父类的所有成员函数，以及数据成员，都会被子类继承！</p><p>简单案例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>(<span class="type">const</span> <span class="type">char</span>*name, <span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Father</span>()&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringstream ret; </span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; age;</span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public继承 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">const</span> <span class="type">char</span> *game):<span class="built_in">Father</span>(name, age),<span class="built_in">game</span>(game)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Son</span>()&#123;&#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">getGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> game;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">description</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringstream ret;</span><br><span class="line">        <span class="comment">// 子类的成员函数中, 不能访问从父类继承的private成员</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="built_in">getAge</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; game:&quot;</span> &lt;&lt; game; <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Father <span class="title">wjl</span><span class="params">(<span class="string">&quot;王健林&quot;</span>, <span class="number">68</span>)</span></span>;</span><br><span class="line">    <span class="function">Son <span class="title">wsc</span><span class="params">(<span class="string">&quot;王思聪&quot;</span>, <span class="number">32</span>, <span class="string">&quot;电竞&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; wjl.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 子类对象调用方法时, 先在自己定义的方法中去寻找, 如果有, 就调用自己定义的方法</span></span><br><span class="line">    <span class="comment">// 如果找不到, 就到父类的方法中去找, 如果有, 就调用父类的这个同名方法 // 如果还是找不到, 就是发生错误!</span></span><br><span class="line">    cout &lt;&lt; wsc.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存分布</strong></p><p>先分配父类的数据成员，再分配子类的数据成员</p><p>说明：成员函数，不占用对象的内存空间，但是也被子类继承了！！！</p><p><img src="/../0_images/C++class/2_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png" alt="alt text"></p><p><strong>protected权限保护</strong></p><p>为什么要使用 protected 访问权限？</p><ul><li><p>子类的成员函数中，不能直接访问父类的 private 成员，已经这些成员已经被继承下来了，但是却不能访问。</p></li><li><p>只有通过父类的 public 函数来间接访问，不是很方便。比如，刚才 Demo 中 Father 类中的 name 和 age 成员。</p></li></ul><p>把name和age定义为protected 就可以了</p><ul><li><p>Son 类的成员函数中，可以直接访问它的父类的 protected 成员。</p></li><li><p>但是在外部，别人又不能直接通过 Son 对象来访问这些成员。</p></li><li><p>一个类, 如果希望, 它的成员, 可以被自己的子类(派生类)直接访问, 但是, 又不想被外部访问那么就可以把这些成员, 定义为 protected访问权限!!!</p></li></ul><p><strong>访问权限：！！！</strong></p><ol><li><p>public 外部可以直接访问.</p></li><li><p>protecte: 子类的成员函数中可以直接访问，外部不可以访问</p></li><li><p>private:  子类的成员函数中不可以访问</p></li></ol><p><strong>派生和继承的各种方式</strong></p><ol><li>public（公有）继承</li></ol><ul><li>父类中定义的成员（数据成员和函数成员）被继承后，访问权限不变！ <ul><li>public –&gt; public</li><li>protected –&gt;protected </li><li>private –&gt; private</li></ul></li></ul><ol start="2"><li>private（私有）继承</li></ol><ul><li>父类中定义的成员（数据成员和函数成员）被继承后，访问权限都变成 private<ul><li>public –&gt; private</li><li>protected –&gt;private </li><li>private –&gt; private</li></ul></li></ul><ol start="3"><li>protected（保护）继承</li></ol><ul><li>类中定义的成员（数据成员和函数成员）被继承后，访问权限底的都变成都变成 protected，其余不变<ul><li>public –&gt; protected</li><li>protected –&gt;private </li><li>private –&gt; private</li></ul></li></ul><ol start="4"><li>总结：</li></ol><ul><li>public 继承全不变 private 继承全变私</li><li>protected 继承只把 public 降级为 protected</li><li>如果不标注继承方式则默认为private</li></ul><p><strong>子类对父类成员的访问权限</strong></p><ul><li><p>无论通过什么方式（public、protected、private）继承，在子类内部均可访问父类中的 public、protected 成员，</p></li><li><p>private 成员不可访问（如果想要子类能够访问，就定义为 protected）</p></li><li><p>继承方式只影响外界通过子类对父类成员的访问权限。</p><ul><li><p>public 继承，父类成员的访问权限全部保留至子类；</p></li><li><p>protected 继承，父类 public 成员的访问权限在子类中降至 protected；</p></li><li><p>private 继承，父类 public、protected 成员的访问权限在子类中均降至 private。</p></li></ul></li></ul><p><strong>父类与子类的构造函数与析构函数</strong></p><p>子类最好要显式调用一下父类的构造函数，如果没有显式的调用父类的构造函数，那么会自动调用父类的默认构造函数（就是那个没有参数并且啥也不干的那个构造函数）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在子类的构造函数中，显式调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">const</span> <span class="type">char</span> *game):<span class="built_in">Father</span>(name, age) &#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;game = game;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有显式的调用父类的构造函数，那么会自动调用父类的默认构造函数</span></span><br><span class="line"><span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *game)&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;game = game;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>子类和父类的构造函数的调用顺序!!!!</strong></p><p>当创建子类对象时, 构造函数的调用顺序：</p><pre><code>静态数据成员的构造函数 -&gt; 父类的构造函数 -&gt; 非静态的数据成员的构造函数 -&gt; 自己的构造函数无论创建几个对象, 该类的静态成员只构建一次, 所以静态成员的构造函数只调用 1 次!!!</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">M</span>() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">N</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">N</span>() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    M m1; </span><br><span class="line">    M m2; </span><br><span class="line">    <span class="type">static</span> N ms;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">N B::ms; <span class="comment">//静态成员</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">    B b;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">N <span class="comment">//静态成员的</span></span><br><span class="line">A <span class="comment">//父类的</span></span><br><span class="line">M <span class="comment">//非静态成员的</span></span><br><span class="line">M <span class="comment">//非静态成员的</span></span><br><span class="line">B <span class="comment">//自己的</span></span><br></pre></td></tr></table></figure><p>析构函数与构造函数的顺序是相反的</p><pre><code>自己的构造函数  -&gt;  非静态的数据成员的构造函数 -&gt; 父类的构造函数 -&gt; 静态数据成员的构造函数</code></pre><p>样例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">M</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">M</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">N</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">N</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">N</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; </span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mm1; </span><br><span class="line">    M m2; </span><br><span class="line">    <span class="type">static</span> N ms;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">NB::ms; <span class="comment">//静态成员</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        B b; </span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">N <span class="comment">//静态成员的</span></span><br><span class="line">A <span class="comment">//父类的</span></span><br><span class="line">M <span class="comment">//非静态成员的</span></span><br><span class="line">M <span class="comment">//非静态成员的</span></span><br><span class="line">B <span class="comment">//自己的</span></span><br><span class="line"></span><br><span class="line">~B <span class="comment">//自己的析构</span></span><br><span class="line">~M <span class="comment">//非静态成员的析构</span></span><br><span class="line">~M <span class="comment">//非静态成员的析构</span></span><br><span class="line">~A <span class="comment">//父类的析构</span></span><br><span class="line">~N <span class="comment">//程序结束的时候才会调用的 静态成员的析构</span></span><br></pre></td></tr></table></figure><p><strong>子类型</strong></p><p>公有继承时，派生类的对象可以作为基类的对象处理，派生类是基类的子类型！！！！。</p><p><img src="/../0_images/C++class/3_%E5%AD%90%E7%B1%BB%E5%9E%8B.png" alt="alt text"></p><p>在需要父类对象的任何地方， 可以使用”公有派生”的子类的对象来替代，从而可以使用相同的函数统一处理基类对象和公有派生类对象即：形参为基类对象时，实参可以是派生类对象</p><p>基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string lastName; <span class="comment">//姓 </span></span><br><span class="line">    string firstName; <span class="comment">//名</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>(<span class="type">const</span> <span class="type">char</span> *lastName=<span class="string">&quot;无姓&quot;</span>, <span class="type">const</span> <span class="type">char</span> *firstName=<span class="string">&quot;无名&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lastName = lastName; </span><br><span class="line">        <span class="keyword">this</span>-&gt;firstName = firstName;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playBasketball</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;呦呦, 我要三步上篮了!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Father</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string lastName; <span class="comment">//姓 </span></span><br><span class="line">    string firstName; <span class="comment">//名 </span></span><br><span class="line">    string food; <span class="comment">//喜欢的食物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mother</span>(<span class="type">const</span> <span class="type">char</span> * food, <span class="type">const</span> <span class="type">char</span> *lastName = <span class="string">&quot;无姓&quot;</span>, <span class="type">const</span> <span class="type">char</span> *firstName = <span class="string">&quot;无名&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;food = food; </span><br><span class="line">        <span class="keyword">this</span>-&gt;lastName = lastName; </span><br><span class="line">        <span class="keyword">this</span>-&gt;firstName = firstName;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mother&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;一起跳舞吧, 一二三四, 二二三四...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Mother</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father, <span class="keyword">public</span> Mother &#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string game;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *lastName, <span class="type">const</span> <span class="type">char</span> *firstName, <span class="type">const</span> <span class="type">char</span> *food, <span class="type">const</span> <span class="type">char</span> *game):<span class="built_in">Father</span>(lastName, firstName),<span class="built_in">Mother</span>(food)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;game = game;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Son</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;一起玩&quot;</span> &lt;&lt; game &lt;&lt; <span class="string">&quot;吧...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Son <span class="title">wsc</span><span class="params">(<span class="string">&quot;川菜&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;思聪&quot;</span>, <span class="string">&quot;电竞&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    wsc.<span class="built_in">playBasketball</span>(); </span><br><span class="line">    wsc.<span class="built_in">dance</span>(); </span><br><span class="line">    wsc.<span class="built_in">playGame</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多重继承的二义性</strong></p><p>比如上面的例子：</p><p>如果 father 和 mother 都有dance这个方法，那么调用的时候就不知道方法是谁的了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string lastName; <span class="comment">//姓 </span></span><br><span class="line">    string firstName; <span class="comment">//名</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>(<span class="type">const</span> <span class="type">char</span> *lastName=<span class="string">&quot;无姓&quot;</span>, <span class="type">const</span> <span class="type">char</span> *firstName=<span class="string">&quot;无名&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lastName = lastName; </span><br><span class="line">        <span class="keyword">this</span>-&gt;firstName = firstName;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playBasketball</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;呦呦, 我要三步上篮了!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;嘿嘿, 我要跳霹雳舞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Father</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mother</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string lastName; <span class="comment">//姓 </span></span><br><span class="line">    string firstName; <span class="comment">//名 </span></span><br><span class="line">    string food; <span class="comment">//喜欢的食物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mother</span>(<span class="type">const</span> <span class="type">char</span> * food, <span class="type">const</span> <span class="type">char</span> *lastName = <span class="string">&quot;无姓&quot;</span>, <span class="type">const</span> <span class="type">char</span> *firstName = <span class="string">&quot;无名&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;food = food; </span><br><span class="line">        <span class="keyword">this</span>-&gt;lastName = lastName; </span><br><span class="line">        <span class="keyword">this</span>-&gt;firstName = firstName;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mother&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;一起跳舞吧, 一二三四, 二二三四...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Mother</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father, <span class="keyword">public</span> Mother &#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string game;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>(<span class="type">const</span> <span class="type">char</span> *lastName, <span class="type">const</span> <span class="type">char</span> *firstName, <span class="type">const</span> <span class="type">char</span> *food, <span class="type">const</span> <span class="type">char</span> *game):<span class="built_in">Father</span>(lastName, firstName),<span class="built_in">Mother</span>(food)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;game = game;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Son</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;一起玩&quot;</span> &lt;&lt; game &lt;&lt; <span class="string">&quot;吧...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Father::<span class="built_in">dance</span>();</span><br><span class="line">        Mother::<span class="built_in">dance</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;霍霍, 我们来跳街舞吧! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Son <span class="title">wsc</span><span class="params">(<span class="string">&quot;川菜&quot;</span>, <span class="string">&quot;王&quot;</span>, <span class="string">&quot;思聪&quot;</span>, <span class="string">&quot;电竞&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 解决多重继承的二义性的方法1:</span></span><br><span class="line">    <span class="comment">// 使用 &quot;类名::&quot; 进行指定, 指定调用从哪个基类继承的方法! </span></span><br><span class="line">    wsc.Father::<span class="built_in">dance</span>();         </span><br><span class="line">    wsc.Mother::<span class="built_in">dance</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决多重继承的二义性的方法2:</span></span><br><span class="line">    <span class="comment">// 在子类中重新实现这个同名方法, 并在这个方法内部, 使用基类名进行限定,</span></span><br><span class="line">    <span class="comment">// 来调用对应的基类方法 </span></span><br><span class="line">    wsc.<span class="built_in">dance</span>(); </span><br><span class="line">    wsc.<span class="built_in">playGame</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：</p><ol><li><p>使用 “类名::” 进行指定, 指定调用从哪个基类继承的方法! </p></li><li><p>在子类中重新实现这个同名方法, 并在这个方法内部, 使用基类名进行限定,</p></li></ol><p><strong>虚类(这个很重要，后面多态的时候会详细来学习)</strong></p><p>解决菱形继承的问题</p><p><img src="/../0_images/C++class/4_%E8%99%9A%E7%B1%BB.png" alt="alt text"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 电话类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tel</span> &#123; <span class="comment">//虚基类 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tel</span>() &#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;number = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string number; <span class="comment">//电话号码;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 座机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedLine</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Tel &#123; <span class="comment">//虚继承</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 手机类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobilePhone</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Tel &#123; <span class="comment">//虚继承</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 无线座机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WirelessTel</span> :<span class="keyword">public</span> FixedLine, <span class="keyword">public</span> MobilePhone &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *number)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;number = number; <span class="comment">//直接访问number</span></span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function">string <span class="title">getNumber</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;number; <span class="comment">//直接访问number</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">    WirelessTel phone; </span><br><span class="line"> </span><br><span class="line">    phone.<span class="built_in">setNumber</span>(<span class="string">&quot;123456789&quot;</span>); </span><br><span class="line">    cout &lt;&lt; phone.<span class="built_in">getNumber</span>() &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ base</title>
      <link href="/2025/04/13/C++base/"/>
      <url>/2025/04/13/C++base/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><p><strong>资料</strong>：<a href="https://blog.csdn.net/weixin_44368437/article/details/117563488">https://blog.csdn.net/weixin_44368437/article/details/117563488</a></p><h2 id="C-与-C-的区别（来自CSDN）"><a href="#C-与-C-的区别（来自CSDN）" class="headerlink" title="C++与 C 的区别（来自CSDN）"></a>C++与 C 的区别（来自CSDN）</h2><p>1.编程范式</p><p>C语言：C是一种过程式编程语言，主要关注函数和过程。程序是通过一系列函数调用来执行任务的。</p><p>C++：C++支持多种编程范式，最主要的是面向对象编程（OOP），同时也支持过程式编程。C++引入了类、对象、继承、多态、封装和抽象等OOP概念，使得代码可以更具模块化和可重用性。</p><p>2.类和对象</p><p>C语言：C不支持面向对象编程，没有类和对象的概念。</p><p>C++：C++支持类和对象，允许开发者创建自定义的数据类型，进行更高级别的抽象和封装。</p><p>3.函数重载和运算符重载</p><p>C语言：C不支持函数重载或运算符重载，函数名必须是唯一的，运算符功能是固定的。</p><p>C++：C++允许函数重载（同名函数可以有不同的参数）和运算符重载（例如，可以定义“+”来用于两个自定义对象之间的加法操作）。</p><p>4.标准库</p><p>C语言：C的标准库较为基础，主要提供了一些与输入输出、字符串处理、数学计算等相关的函数（如stdio.h，stdlib.h等）。</p><p>C++：C++有更丰富的标准库，除了C语言的标准库外，还引入了STL（标准模板库），提供了常用的数据结构（如vector，list，map等）和算法。</p><p>5.内存管理</p><p>C语言：C的内存管理主要通过malloc，calloc，realloc和free来进行手动内存分配和释放。</p><p>C++：C++除了可以使用C的内存管理函数外，还引入了new和delete运算符，用于动态内存分配和释放，这些运算符具有构造和析构对象的功能。</p><p>6.构造函数和析构函数</p><p>C语言：C不支持构造函数和析构函数，结构体的初始化需要手动完成。</p><p>C++：C++中的类可以有构造函数（对象创建时自动调用）和析构函数（对象销毁时自动调用），用于对象的初始化和清理工作。</p><p>7.命名空间（namespace）</p><p>C语言：C不支持命名空间，多个全局变量和函数可能会发生命名冲突。</p><p>C++：C++引入了命名空间，通过namespace可以将函数和变量组织在一起，避免命名冲突。</p><p>8.模板编程</p><p>C语言：C不支持模板编程。</p><p>C++：C++引入了模板，可以编写泛型函数和类，支持代码重用和类型安全。例如，模板可以实现类型无关的函数和容器。</p><p>9.异常处理</p><p>C语言：C没有内置的异常处理机制。错误处理通常通过返回错误码或者设置全局变量来完成。</p><p>C++：C++支持异常处理机制，通过try，throw，catch块来处理运行时错误，使得代码更加清晰和健壮。</p><p>10.引用（reference）</p><p>C语言：C只支持指针，不支持引用。</p><p>C++：C++引入了引用类型（reference），是一种更安全且更简洁的传递对象的方式，可以避免指针的一些常见错误（如空指针或指针操作中的内存泄漏问题）。</p><p>11.兼容性</p><p>C语言：C是C++的子集，大部分C语言代码可以直接在C++中运行。</p><p>C++：C++是C的超集，但C++的一些特性（如类、模板等）在C中不可用。</p><p>12.代码复杂性与应用领域</p><p>C语言：C的语法较为简单直接，适用于系统级编程，如操作系统开发、嵌入式系统、驱动程序等领域。</p><p>C++：C++功能更为复杂，适用于大型软件开发、游戏开发、高性能应用、GUI应用程序等。</p><h2 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h2><p><strong>面向对象程序设计</strong>（Object-Oriented Programming，OOP）是一种新的程序设计范型。程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。</p><p><strong>面向过程程序设计范型</strong>是使用较广泛的面向过程性语言，其主要特征是：程序由过程定义和过程调用组成（简单地说，过程就是程序执行某项操作的一段代码，函数就是最常用的过程）。</p><p>面向对象程序的基本元素是对象，面向对象程序的主要结构特点是：第一，程序一般由类的定义和类的使用两部分组成；第二，程序中的一切操作都是通过向对象发送消息来实现的，对象接收到消息后，启动有关方法完成相应的操作。</p><p><img src="/../0_images/C++base/1_C++%E5%9F%BA%E7%A1%80_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.png" alt="alt text"></p><h2 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h2><h3 id="sizeof-大小"><a href="#sizeof-大小" class="headerlink" title="sizeof 大小"></a>sizeof 大小</h3><p><img src="/../0_images/C++base/2_C++%E5%9F%BA%E7%A1%80_sizeof.png" alt="alt text"></p><p>C++涉及强制转化，一般是转化的时候是需要一些低位向高位进行转换</p><h3 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h3><p>在C语言中，习惯使用#define来定义常量，例如#define PI 3.14，C++提供了一种更灵活、更安全的方式来定义常量，即使用const修饰符来定义常量。例如const float PI &#x3D; 3.14</p><p>这里要特别注意两个概念 常量指针和指针常量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量指针：（指向常量的指针，指针指的是一个常量，但是指针自己不是一个常量）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pc = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">// 指针所指的地址里面的内容无法改变</span></span><br><span class="line"><span class="comment">// pc[3] = &#x27;a&#x27;; 这是错误的</span></span><br><span class="line"><span class="comment">// 指针所指的内容可以改变</span></span><br><span class="line">pc = <span class="string">&quot;ervfs&quot;</span>;  <span class="comment">//该语句付给了指针另一个字符串的地址，改变了pc的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针常量：（指针本身是一个常量，也就是说，指针所指向的地址是无法改变的，但是地址内部的值是可以改变的）</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> pc = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">//指针所指的地址无法改变</span></span><br><span class="line"><span class="comment">//pc = &#x27;dsff&#x27;;  //该语句付给了指针另一个字符串的地址，改变了pc的值,这是不可以的</span></span><br><span class="line"><span class="comment">//地址内部的值是可以改变的</span></span><br><span class="line">pc[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">//仅改变地址内容是可以的</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两者一起用 内容和地址均不能改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> pc = <span class="string">&quot;abcd&quot;</span>;的</span><br></pre></td></tr></table></figure><h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h3><p>void通常表示无值，但将void作为指针的类型时，它却表示不确定的类型。这种void型指针是一种通用型指针，也就是说任何类型的指针值都可以赋给void类型的指针变量。</p><p>需要指出的是，这里说void型指针是通用指针，是指它可以接受任何类型的指针的赋值，但对已获值的void型指针，对它进行再处理，如输出或者传递指针值时，则必须再进行<strong>显式类型转换</strong>，否则会出错。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void指针</span></span><br><span class="line"><span class="type">void</span> * pc;</span><br><span class="line"><span class="comment">// int型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"><span class="comment">// char型</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int * 赋值给 void * 使用的时候需要进行强制转化</span></span><br><span class="line">pc = &amp;i;</span><br><span class="line">cout&lt;&lt; *(<span class="type">int</span> *)pc &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int * 赋值给 void * 使用的时候需要进行强制转化</span></span><br><span class="line">pc = &amp;c;</span><br><span class="line">cout&lt;&lt; *(<span class="type">char</span> *)pc &lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="內联函数"><a href="#內联函数" class="headerlink" title="內联函数"></a>內联函数</h3><p>在函数名前冠以关键字inline，该函数就被声明为内联函数。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数的语句之处，同时使用实参代替形参，以便在程序运行时不再进行函数调用。引入内联函数主要是为了消除调用函数时的系统开销，以提高运行速度</p><p>内联函数在第一次被调用之前必须进行完整的定义，否则编译器将无法知道应该插入什么代码</p><p>在内联函数体内一般不能含有复杂的控制语句，如for语句和switch语句等</p><p>使用内联函数是一种空间换时间的措施，若内联函数较长，较复杂且调用较为频繁时不建议使用</p><p><strong>注意內联函数与宏定义的区别</strong></p><p>实现机制上：（內联函数是在编译阶段，编译器处理的，宏定义是在编译之前，预处理器来处理的，简单的文本替换不）</p><p>内联函数：是C++中的一种函数定义方式，使用inline关键字修饰。在编译阶段，编译器会根据一定的规则（如函数体较小、调用频繁等）将内联函数的代码直接插入到每个调用点，从而避免函数调用的开销。内联函数的实现依赖于编译器的优化机制，编译器有权决定是否将某个函数内联。</p><p>宏定义：是C语言中的一种预处理指令，使用#define关键字定义。在预处理阶段，预处理器会将宏定义的代码直接替换到每个宏调用点，不涉及编译器的优化决策。宏定义的替换是简单的文本替换，不进行语法检查和类型检查。</p><p>安全性上：（宏定义只是简简单单的文本替换，不涉及一些语法检查）</p><p>内联函数：具有函数的所有特性，如类型检查、作用域规则等，能够保证代码的安全性和正确性。编译器会对内联函数的参数和返回值进行严格的类型检查，避免类型不匹配等问题。</p><p>宏定义：由于是简单的文本替换，不进行类型检查和语法检查，容易引发类型不匹配、运算符优先级错误等问题。例如，#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))，如果调用MAX(x++, y++)，可能会导致意外的结果，因为宏会将代码展开为((x++) &gt; (y++) ? (x++) : (y++))，导致x和y被多次自增。</p><p>调试难度上：</p><p>内联函数：与普通函数类似，调试工具可以像调试普通函数一样调试内联函数，能够设置断点、查看变量值等，调试过程相对容易。</p><p>宏定义：由于宏定义的代码在预处理阶段被替换，调试工具无法直接调试宏定义的代码，只能看到替换后的代码，这增加了调试的难度</p><p>适用场景上：</p><p>内联函数：适用于函数体较小、调用频繁且需要类型安全的场景。例如，简单的数学计算函数、获取数组元素等。内联函数可以提高代码的可读性和可维护性，同时减少函数调用的开销。</p><p>宏定义：适用于需要快速替换文本、生成代码模板的场景。例如，定义常量、简单的代码片段等。宏定义可以提高代码的灵活性，但需要谨慎使用，避免引入错误。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">circle</span><span class="params">(<span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> PI * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;r = &quot;</span>&lt;&lt; i &lt;&lt;<span class="string">&quot; area = &quot;</span> &lt;&lt; <span class="built_in">circle</span>(i) &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有默认参数值的函数"><a href="#带有默认参数值的函数" class="headerlink" title="带有默认参数值的函数"></a>带有默认参数值的函数</h3><p>当进行函数调用时，编译器按<strong>从左到右</strong>的顺序将实参与形参结合，若未指定足够的实参，则编译器按顺序用函数原型中的默认值来补足所缺少的实参。</p><p>所以如果要使用默认值的话，一定要注意，从左到右只有最右边的形参可以家默认值，不可以左边的加上了默认值，但是右边的没加（在函数原型中，所有取默认值的参数都必须出现在不取默认值的参数的右边。）</p><p>在函数调用时，若某个参数省略，则其后的参数皆应省略而采取默认值。不允许某个参数省略后，再给其后的参数指定参数值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">defaultParaFunc</span><span class="params">(<span class="type">int</span> a = <span class="number">5</span>,<span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">defaultParaFunc</span>();   <span class="comment">//默认 a=5 b=10</span></span><br><span class="line">    <span class="built_in">defaultParaFunc</span>(<span class="number">25</span>); <span class="comment">//a=25 默认 b=10</span></span><br><span class="line">    <span class="built_in">defaultParaFunc</span>(<span class="number">25</span>,<span class="number">30</span>); <span class="comment">// a=25 b=30</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>在C++中，用户可以重载函数。这意味着，在同一作用域内，只要<strong>函数参数的类型不同，或者参数的个数不同，或者二者兼而有之</strong>，两个或者两个以上的函数可以使用相同的函数名。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">7</span>;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">10.334</span>, y = <span class="number">8.9003</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(a, b, c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：返回值类型不同不算重载（调用重载函数时，函数返回值类型不在参数匹配检查之列。因此，若两个函数的参数个数和类型都相同，而只有返回值类型不同，则不允许重载。）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：重载和带默认值的函数容易造成二义性</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Drawcircle</span><span class="params">(<span class="type">int</span> r = <span class="number">0</span>, <span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Drawcircle</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"><span class="built_in">Drawcircle</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>注意：C++可能会做强制类型转换</p><p>在调用函数时，如果给出的实参和形参类型不相符，C++的编译器会自动地做类型转换工作。如果转换成功，则程序继续执行，在这种情况下，有可能产生不可识别的错误。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_a</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_a</span><span class="params">(<span class="type">long</span> x)</span></span>;</span><br><span class="line"><span class="built_in">f_a</span>(<span class="number">20.83</span>);</span><br></pre></td></tr></table></figure><h3 id="作用域标识符：："><a href="#作用域标识符：：" class="headerlink" title="作用域标识符：："></a>作用域标识符：：</h3><p>通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p><p>如果希望在局部变量的作用域内使用同名的全局变量，可以在该变量前加上“::”，此时::value代表全局变量value，“::”称为作用域标识符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value;   <span class="comment">//定义全局变量value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">//定义局部变量value</span></span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    ::value = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local value : &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global value : &quot;</span> &lt;&lt; ::value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>可用强制类型转换将不同类型的数据进行转换。例如，要把一个整型数（int）转换为双精度型数（double），可使用如下的格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> x = (<span class="type">double</span>)i;</span><br><span class="line">或</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> x = <span class="built_in">double</span>(i);</span><br></pre></td></tr></table></figure><h3 id="new和delete运算符"><a href="#new和delete运算符" class="headerlink" title="new和delete运算符"></a>new和delete运算符</h3><p>程序运行时，计算机的内存被分为4个区：程序代码区、全局数据区、堆和栈。其中，堆可由用户分配和释放。C语言中使用函数malloc()和free()来进行动态内存管理。C++则提供了运算符new和delete来做同样的工作，而且后者比前者性能更优越，使用更灵活方便。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">指针变量名 = <span class="keyword">new</span> 类型</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> 指针变量名</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>下面对new和delete的使用再做一下几点说明：</p><p>申请后的释放工作：用运算符new分配的空间，使用结束后应该用也只能用delete显式地释放，否则这部分空间将不能回收而变成死空间。</p><p>异常处理工作：在使用运算符new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。</p><p>使用运算符new可以为数组动态分配内存空间，这时需要在类型后面加上数组大小。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">指针变量名 = <span class="keyword">new</span> 类型名[下标表达式];</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []指针变量名;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>new 可在为简单变量分配空间的同时，进行初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">指针变量名 = <span class="keyword">new</span> 类型名(初值);</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">99</span>);</span><br><span class="line">···</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>异常处理要注意：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，一定要注意</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Memory allocation failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）是C++对C的一个重要扩充。变量的引用就是变量的别名，因此引用又称别名。</p><p>类型 &amp;引用名 &#x3D; 已定义的变量名</p><p>引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储空间。实际上，编译系统使引用和其代表的变量具有相同的地址。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;j = i;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i的地址为 &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;j的地址为 &quot;</span> &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出的结果是一样的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用并不是一种独立的数据类型，它必须与某一种类型的变量相联系。在声明引用时，必须立即对它进行初始化，不能声明完成后再赋值。</p><p>为引用提供的初始值，可以是一个变量或者另一个引用。</p><p>指针是通过地址间接访问某个变量，而引用则是通过别名直接访问某个变量。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">index</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//交换数字a和b</span></span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">index</span>(<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">//等价于输出元素a[2]的值</span></span><br><span class="line">    <span class="built_in">index</span>(<span class="number">2</span>) = <span class="number">100</span>;             <span class="comment">//等价于将a[2]的值赋为100;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">index</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进一步说明：</p><p>不允许建立void类型的引用</p><p>不能建立引用的数组</p><p>不能建立引用的引用。不能建立指向引用的指针。引用本身不是一种数据类型，所以没有引用的引用，也没有引用的指针。</p><p>可以将引用的地址赋值给一个指针，此时指针指向的是原来的变量。</p><p>可以用const对引用加以限定，不允许改变该引用的值，但是它不阻止引用所代表的变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPool</title>
      <link href="/2025/04/13/ThreadPool/"/>
      <url>/2025/04/13/ThreadPool/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池项目"><a href="#线程池项目" class="headerlink" title="线程池项目"></a>线程池项目</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>线程池的概念：</p><p>线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。</p><p>说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程</p><p>那么我们就可以想到一个线程池的最基础的构造</p><p>变量：</p><ul><li>一个vector 用来存储构造好的线程</li><li>一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 )</li><li>mutex  有了queue自然得考虑到互斥的问题</li><li>condition_variable 条件变量 同mutex理</li><li>flag   停止标识</li></ul><p>函数：</p><ul><li>首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数)</li><li>其次得有线程的释放join 的函数  （此处可以使用类的析构函数）</li><li>还有得有添加任务的函数</li></ul><h2 id="ThreadPool声明"><a href="#ThreadPool声明" class="headerlink" title="ThreadPool声明"></a>ThreadPool声明</h2><p>通过前面描述来声明一下CLASS</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;        <span class="comment">// 工作线程集合</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列（存储无参void函数）</span></span><br><span class="line">    std::mutex queue_mutex;                  <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    std::condition_variable condition;       <span class="comment">// 线程间通信的条件变量</span></span><br><span class="line">    <span class="type">bool</span> stop;                               <span class="comment">// 停止标志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>); <span class="comment">// 构造函数，参数为线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>; <span class="comment">// 任务入队方法</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>(); <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里其他的都比较好理解，主要是enqueue函数难以理解，这个先放一放，后面再详细解释</p><h2 id="ThreadPool构造函数，初始化函数的实现"><a href="#ThreadPool构造函数，初始化函数的实现" class="headerlink" title="ThreadPool构造函数，初始化函数的实现"></a>ThreadPool构造函数，初始化函数的实现</h2><p>这个其实没啥说的，很常规的东西</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threadsNum)</span>:stop(false)&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;threadsNum; i++)&#123;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>( <span class="comment">// 创建线程并绑定到Lambda</span></span><br><span class="line">            [<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;      <span class="comment">// 无限循环，直到线程池停止</span></span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop||!<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();</span><br><span class="line">                        &#125;);<span class="comment">// 等待任务或停止信号（如果任务列表为空或者是stop为true的话，就会一直等待）</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                           <span class="keyword">return</span>;   <span class="comment">// 停止且无任务时退出线程</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());  <span class="comment">//取任务</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125; <span class="comment">//这里会自动释放锁</span></span><br><span class="line">                    <span class="built_in">task</span>(); <span class="comment">//执行任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPool析构函数，函数的释放"><a href="#ThreadPool析构函数，函数的释放" class="headerlink" title="~ThreadPool析构函数，函数的释放"></a>~ThreadPool析构函数，函数的释放</h2><p>emmm 这个也常规</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;stop = <span class="literal">true</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="keyword">for</span>(std::thread&amp; worker:<span class="keyword">this</span>-&gt;workers)&#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();      <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="enqueue-添加任务功能的实现"><a href="#enqueue-添加任务功能的实现" class="headerlink" title="enqueue 添加任务功能的实现"></a>enqueue 添加任务功能的实现</h2><p>这里就是最为复杂的地方，本来也是挺常规的，正常的传入（无参void函数）就行了，但是确实会出现问题，这样的话就只能处理 无参void函数 这一种类型了，这显然很有局限性。因此便有了这样一种书写方式</p><p>基本思想：将一个带参数的有返回值的函数，转化一下，转化为 无参void函数 就行了</p><p>先把代码发放上来，稍后一句一句分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下函数的声明</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure><p>定义的是一个模板，template &lt;class F, class… Args&gt;  两个参数</p><ul><li>class F：接受任意类型的可调用对象（函数、Lambda、函数对象等）。</li><li>class… Args：接受任意数量和类型的参数包。</li></ul><p>函数参数</p><ul><li>F&amp;&amp; f：万能引用（不是右值引用！），可以绑定到任意类型的可调用对象（左值或右值）。</li><li>Args&amp;&amp;… args：参数包的万能引用，保留参数的原始值类别（左值&#x2F;右值）。</li></ul><p>注意：这里的返回值是auto 是根据箭头后面的来推理出来的</p><ul><li>-&gt; std::future&lt;typename std::result_of&lt;F(Args…)&gt;::type&gt;</li><li>future用于异步获取进程的返回值</li><li>result_of获取函数 F(Args…) 的返回值</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>packaged_task包装，这个下面解释，先解释一下bind函数</p><p>bind函数，这里使用的很巧妙</p><p>这里可以看一下bind的用法，这个挺重要的 <a href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p><p>这里就介绍一下bind在这里的用法</p><p>对于一个函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print: x = &quot;</span> &lt;&lt; x </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, z = &quot;</span> &lt;&lt; z </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是有三个参数的，x y z ，我们通过 bind 来做处理</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f2 的第一，二个参数指定</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(fun_1, std::placeholders::_1, std::placeholders::_2, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样的话：绑定函数 fun 的第一，二，三个参数值为： 1 2 3</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(fun_1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f2</span>();     <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br></pre></td></tr></table></figure><p>这里的用法是一样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br></pre></td></tr></table></figure><p>实现了从有参到无参数的转化</p><p>继续:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p>这里解释一下上面说的 packaged_task </p><p>std::packaged_task&lt;return_type()&gt; 的核心目的是将任意函数 ​​包装成异步任务​​，并自动关联一个 std::future 用于获取结果。</p><ul><li>std::packaged_task&lt;return_type()&gt; task(func); &#x2F;&#x2F; 包装为 packaged_task<ul><li>此时，task 的签名是 return_type()，即调用 task() 会执行 func 并返回结果。</li><li>packaged_task 内部维护一个 ​​共享状态​​（shared state），当调用 task() 执行函数时：<ul><li>执行绑定的函数 func</li><li>将函数返回值存入共享状态</li><li>唤醒通过 future 等待该结果的线程</li></ul></li></ul></li></ul><p>为什么上面的语句 未执行就能获取 future</p><p>std::future<return_type> res &#x3D; task-&gt;get_future();</p><ul><li>future 是一个 ​​结果的占位符​​，它的有效性从 packaged_task 创建时就开始，与任务执行时机无关。调用 res.get() 时：<ul><li>若任务已执行：立即返回结果</li><li>若任务未执行：阻塞等待结果</li></ul></li></ul><p>为什么要用make_shared管理</p><p>auto task &#x3D; std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(…);</p><ul><li>确保 packaged_task 存活至任务被执行</li><li>不用手动释放(只能指针的妙用嘛)</li></ul><p>继续：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面不用多说，主要是最后一行</p><p>task经过之前的处理，已经相当于一个 函数指针 了，这里直接调用 (*task)() 他的返回值由 packaged_task 管理</p><p>我们整体来看：Lambda  表达式 <a href="">task</a> { (*task)(); } 就是一个无参数，无返回值的函数 因此 可以正常的 放到 this-&gt;tasks里面</p><p>继续：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>没啥好说的</p><p>我们最后再整体看一下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理流程：</p><ul><li>用户调用 enqueue​<ul><li>提交函数 f 和参数 args，要求返回 future。</li></ul></li><li>创建 packaged_task​<ul><li>将 f(args…) 绑定为 return_type() 类型的任务。</li></ul></li><li>获取 future​<ul><li>立即通过 task-&gt;get_future() 获取结果占位符。</li></ul></li><li>​​封装为 void() 任务​<ul><li>将任务包装为 <a href="">task</a>{ (*task)(); }，符合队列类型。</li></ul></li><li>​​任务入队与通知​<ul><li>唤醒线程池中的工作线程。</li></ul></li><li>​​任务执行​<ul><li>工作线程调用 (*task)()，执行用户函数并存储结果到共享状态。</li></ul></li><li>​​用户获取结果​<ul><li>用户通过 future.get() 等待或获取结果。</li></ul></li></ul><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="language-cpp">#include &lt;iostream&gt;#include &quot;include/threadPool.h&quot;using namespace std;int main()&#123;    // 测试1：基本任务执行和返回值    &#123;        ThreadPool pool(2);        auto future_add = pool.enqueue([](int a, int b) &#123;            return a + b;        &#125;, 2, 3);        int result = future_add.get();        std::cout &lt;&lt; &quot;Test 1: 2 + 3 = &quot; &lt;&lt; result &lt;&lt; std::endl;  // 预期输出5    &#125;    // 测试2：并行执行多个任务    &#123;        const int num_tasks = 8;        ThreadPool pool(4);        std::vector&lt;std::future&lt;int&gt;&gt; futures;                for (int i = 0; i &lt; num_tasks; ++i) &#123;            futures.emplace_back(pool.enqueue([i] &#123;                std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟耗时操作                return i * i;            &#125;));        &#125;        std::cout &lt;&lt; &quot;Test 2: Results: &quot;;        for (auto&amp; fut : futures) &#123;            std::cout &lt;&lt; fut.get() &lt;&lt; &quot; &quot;;  // 预期输出0 1 4 9 16 25 36 49（顺序可能不同）        &#125;        std::cout &lt;&lt; &quot;\n&quot;;    &#125;    // 测试3：异常传播    &#123;        ThreadPool pool(2);        auto future_exception = pool.enqueue([] &#123;            throw std::runtime_error(&quot;Intentional exception&quot;);            return 0;        &#125;);        try &#123;            future_exception.get();        &#125; catch (const std::exception&amp; e) &#123;            std::cout &lt;&lt; &quot;Test 3: Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        &#125;    &#125;    // 测试4：线程池自动回收（通过作用域生命周期）    &#123;        std::cout &lt;&lt; &quot;Test 4: Creating nested thread pool...&quot; &lt;&lt; std::endl;        &#123;            ThreadPool inner_pool(2);            inner_pool.enqueue([] &#123;                std::cout &lt;&lt; &quot;Task executed in inner pool&quot; &lt;&lt; std::endl;            &#125;);        &#125;  // 此处inner_pool析构，自动等待任务完成        std::cout &lt;&lt; &quot;Inner pool destroyed&quot; &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;All tests completed successfully.&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>cd build</p><p>cmake .. </p><p>make</p><p>.&#x2F;threadPool</p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tinyhttpd</title>
      <link href="/2025/04/13/tinyhttpd/"/>
      <url>/2025/04/13/tinyhttpd/</url>
      
        <content type="html"><![CDATA[<h1 id="tinyhttpd-项目"><a href="#tinyhttpd-项目" class="headerlink" title="tinyhttpd 项目"></a>tinyhttpd 项目</h1><p>写在前面：这个项目是  J. David 大佬 在1999年做出来的，虽然很老旧, 而且手打一遍之后也感觉有些地方可能不适合这么写，但是做完这个项目之后学到的东西有很多很多，如果大家有时间的话，不妨跟着做一做，相信一定会有很大的收获</p><p>膜拜大佬！！！</p><p>GIT 原始项目地址：<a href="https://github.com/EZLippi/Tinyhttpd">https://github.com/EZLippi/Tinyhttpd</a></p><p>我这边加上注释的代码：</p><h1 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h1><p>做之前需要先确定自己的环境能够正常把项目运行起来，要不然做的过程之中不知道是自己代码的问题还是环境的问题</p><p>我用的Linux ubuntu 提前安装了perl 地址在 &#x2F;usr&#x2F;bin&#x2F;perl(这个可以通过 which perl 命令得到)</p><p>GIT 原始项目地址：<a href="https://github.com/EZLippi/Tinyhttpd">https://github.com/EZLippi/Tinyhttpd</a></p><p>1.克隆下来，解压 这个不必对多说</p><p>2.执行make命令</p><ul><li>会生成 httpd 与 client (会有一些警告，不必在意)</li></ul><p>3.执行httpd(.&#x2F;httpd)</p><ul><li>这个时候浏览器输入 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 会发现 没有东西</li><li>这需要修改资源文件(htdocs里面的CGI文件)</li></ul><p>4.修改资源文件</p><ul><li>两个CGI文件的路径 perl <ul><li>两个文件的第一行都有 #!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;perl -Tw 把这改成咱们自己的，我的是 &#x2F;usr&#x2F;bin&#x2F;perl</li></ul></li><li>修改资源文件权限<ul><li>修改一下 index.html 的权限</li><li>sudo chmod 600 index.html</li><li>要为 check.cgi color.cgi 添加可执行的权限</li><li>sudo chmod +x check.cgi</li><li>sudo chmod +x color.cgi</li></ul></li></ul><p>5.正常运行起来</p><p><img src="/../0_images/Tinyhttpd/1_%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5.png" alt="alt text"></p><p><img src="/../0_images/Tinyhttpd/2_%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82.png" alt="alt text"></p><h1 id="tinyhttpd"><a href="#tinyhttpd" class="headerlink" title="tinyhttpd"></a>tinyhttpd</h1><p>无论怎么说，还是得自己对着做一遍的 ： )</p><p>重写顺序：main -&gt; startup -&gt; accept_request -&gt; get_line -&gt; serve_file -&gt; cat -&gt; execute_cgi</p><p>可以按照上面这个顺序来写，其他的函数可知看一看，直接复制上来就好</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>Socket 网络变成</li><li>计算机网络 TCP HTTP</li><li>进程之间的通信</li></ul><p>要理解HTTP报文，这个很重要，要不然代码可能会看不懂(注意请求报文和响应报文，两者不一样)</p><p><img src="/../0_images/Tinyhttpd/3_HTTP%E6%8A%A5%E6%96%87.png" alt="alt text"></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>按照上面的顺序来</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对收到的请求进行处理，每次受到请求都会创建一个新的线程来做处理</span></span><br><span class="line"><span class="comment">// 这个就是定义的线程函数，void * 其实是用来接收 client_sock 的</span></span><br><span class="line"><span class="comment">// 其实这里我觉得使用int 来接收可能更好一些，可能原作者有一些其他的想法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept_request</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一些错误的请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_request</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cat</span><span class="params">(<span class="type">int</span>,FILE *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法执行的错误操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CIG脚本 // 如果没接触CIG也没关系，CIG可以直接用人家的，咱们第一次学的话就先学习网络的操作，后续想要加深理解可以学一下CIG</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一行数据 这里要注意看里面咋操作的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回http头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有发现文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">not_found</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是CGI文件，直接读取文件返回给请求的http客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启tcp连接，绑定端口等操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">startup</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是Get或者Post，就报方法没有实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unimplemented</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="mian"><a href="#mian" class="headerlink" title="mian()"></a>mian()</h3><p>这个很简单，就是一些服务器，客户端的基础操作，服务端在startup函数里面初始化，后面是客户端链接的过程，链接之后会使用 pthread_create 创建一个线程来处理，处理函数是 accept_request</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="number">4000</span>;</span><br><span class="line">    <span class="type">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_name;</span><br><span class="line">    <span class="comment">// 注意这个类型哈,因为后面要取地，所以不能是size_t 或者 int 等其他类型 (函数就是这么定义的)</span></span><br><span class="line">    <span class="type">socklen_t</span> client_name_len = <span class="built_in">sizeof</span>(client_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="type">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line">    server_sock = <span class="built_in">startup</span>(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//socket - accept</span></span><br><span class="line">        client_sock = <span class="built_in">accept</span>(server_sock,(<span class="keyword">struct</span> sockaddr *)&amp;client_name,&amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sock == <span class="number">-1</span>)&#123; <span class="comment">// 没accept到，错误处理</span></span><br><span class="line">            <span class="built_in">error_die</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面加一个线程来处理这个HTTP请求</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;newthread,<span class="literal">NULL</span>,(<span class="type">void</span>*)accept_request,(<span class="type">void</span> *)(<span class="type">intptr_t</span>)client_sock)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="startup"><a href="#startup" class="headerlink" title="startup"></a>startup</h3><p>开启tcp连接，绑定端口等操作, 就是TCP服务器部分的基本操作</p><p>套接字 -&gt; 绑定 -&gt; 监听 -&gt; 返回描述符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">startup</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> httpd = <span class="number">0</span>; <span class="comment">//serverFd</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> name;</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    httpd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空一下内容 后面再赋值</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="built_in">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port = <span class="built_in">htons</span>(*port); <span class="comment">//小端转大端</span></span><br><span class="line">    name.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//本地能使用的IP地址都行</span></span><br><span class="line">    <span class="comment">// 这个是为了复用端口的，其实有没有都可以，不太重要</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">setsockopt</span>(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on))) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(httpd,(<span class="keyword">struct</span> sockaddr *)&amp;name,<span class="built_in">sizeof</span>(name))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有提供端口，系统会分配一个端口</span></span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> namelen = <span class="built_in">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockname</span>(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_die</span>(<span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line">        *port = <span class="built_in">ntohs</span>(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> httpd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="accept-request"><a href="#accept-request" class="headerlink" title="accept_request"></a>accept_request</h3><p>处理请求的线程函数 </p><p>这里先不管 get_line 等其他函数 先知道他是干啥的就行了</p><p>下面代码写了注释，可以看的很清楚</p><p>这里一定要记得HTTP请求报文的报文头</p><p>第一行：方法（post get ..） + 空格 + URL + 空格 + 版本 + ‘\r\n’</p><p>这里要注意这一行：sprintf(path, “..&#x2F;htdocs%s”, url);</p><p>要把地址找对，我自己这边习惯用cmake，所以一般会建一个build文件夹来存储一些中间文件，生成的可执行程序也在build文件夹之中，因此要找到与build文件夹同级的htdocs，得用..&#x2F;htdocs</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept_request</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = (<span class="type">intptr_t</span>)arg; <span class="comment">// clientFd</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];      <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> numchars;     <span class="comment">//存储get_line返回的第一行的长度</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">255</span>];    <span class="comment">//存储请求的方法，这里只支持两种 POST与GET</span></span><br><span class="line">    <span class="type">char</span> url[<span class="number">255</span>];       <span class="comment">//存储URL</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">512</span>];      <span class="comment">//存储路径 就是资源文件的路径 咱们这里的资源文件存储到 htdocs 里面了</span></span><br><span class="line">    <span class="type">size_t</span> i, j;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="type">int</span> cgi = <span class="number">0</span>;         <span class="comment">//一个标志，看需不需要调用 CGI 程序</span></span><br><span class="line">    <span class="type">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    i = <span class="number">0</span>;j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意这里一定要对这HTTP报文头来看，HTTP 请求报文第一行 方法（post get ..） + 空格 + URL + 空格 + 版本 + ‘\r\n’</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ISspace</span>(buf[i]) &amp;&amp; (i &lt; <span class="built_in">sizeof</span>(method)<span class="number">-1</span>))&#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;  <span class="comment">// 保存一下现在的位置</span></span><br><span class="line">    method[i] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 字符串结束符号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strcasecmp 这个就不过多解释了，忽略大小写比较字符串，等于0的时候表示两个字符串在忽略大小写的时候完全相等</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) &amp;&amp; <span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 这里就只有GET 和 POST两种请求，其他的不支持</span></span><br><span class="line">        <span class="built_in">unimplemented</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是POST，cgi置为1 需要运行CGI脚本</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过着一个空格</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">ISspace</span>(buf[j]) &amp;&amp; (j &lt; numchars))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要处理下一个东西了 URL</span></span><br><span class="line">    <span class="comment">//再强调一下HTTP请求报文的第一行  HTTP 请求报文第一行 方法（post get ..） + 空格 + URL + 空格 + 版本 + ‘\r\n’</span></span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 还是一样的操作，先把url拿过来</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ISspace</span>(buf[j]) &amp;&amp; (i &lt; <span class="built_in">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; numchars))&#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://127.0.0.1:9734/</span></span><br><span class="line">    <span class="comment">//http://127.0.0.1:9734/color.cgi?color=red  </span></span><br><span class="line">    <span class="comment">//注意哈，前面是IP + 端口 不是 url 内部 哈 这个 第二个实际发送的是 实际客户发送的为 GET /color.cgi?color=red HTTP/1.1 记得看一下HTTP请求报文头</span></span><br><span class="line">    <span class="comment">//处理get请求，get请求如果不带参数就是上面第一种，get请求如果带参数就是上面第二种，参数放在?后面，color=red 参数名=参数值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="comment">//找一下?的位置 或者没有的话就到结尾了</span></span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="string">&#x27;\0&#x27;</span>))&#123;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理一下带参数的get请求</span></span><br><span class="line">        <span class="keyword">if</span>(*query_string == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            cgi = <span class="number">1</span>; <span class="comment">// 带参数就得调用CGI脚本了</span></span><br><span class="line">            *query_string = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 注意这里把url给截断了 ? 改成 &#x27;\0&#x27; 表示结尾 color.cgi?color=red - &gt; color.cgi</span></span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把地址拿一下，注意以下htdocs是相对地址哈，我的可执行文件放在了build里面了，build与htdocs同级，所以是</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;../htdocs%s&quot;</span>, url);   <span class="comment">//还是拿上面第一个和第二个例子距离，如果没有参数 那么路径为 ../htdocs/  有参数则为../htdocs/color.cgi(因此这个需要cgi = 1)</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="built_in">strlen</span>(path)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span>)&#123;     <span class="comment">//无参的情况</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">&quot;index.html&quot;</span>);      <span class="comment">//把咱们的初始界面 index.html 加上 然后 返回去给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(path, &amp;st) == <span class="number">-1</span>) &#123; <span class="comment">// stat 失败（文件或者目录不存在） stat 成功返回 0 反之 返回 -1</span></span><br><span class="line">        <span class="comment">// 读取并丢弃剩余的请求头（直到空行）销毁报文头 返回 404 就好了</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123;  <span class="comment">// 注意：HTTP 头以 \r\n 结尾</span></span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">not_found</span>(client); <span class="comment">// 发送 404 Not Found</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 这里再次判断是个目录还是文件 详细的看一下struct stat 了解一下，这里就不多介绍了</span></span><br><span class="line">        <span class="comment">// 知道这是一个判断目录还是文件的操作就好了</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)&#123; </span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">&quot;/index.html&quot;</span>); <span class="comment">//还是一样的操作，是目录就加上 index.html </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查文件是否有执行权限（任意用户组）</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||    <span class="comment">//检查所有者是否有执行权限。</span></span><br><span class="line">            (st.st_mode &amp; S_IXGRP) ||    <span class="comment">//检查组是否有执行权限。</span></span><br><span class="line">            (st.st_mode &amp; S_IXOTH)    )&#123; <span class="comment">//检查其他人是否有执行权限</span></span><br><span class="line">                cgi = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cgi)&#123;</span><br><span class="line">            <span class="comment">//接读取文件返回给请求的http客户端</span></span><br><span class="line">            <span class="built_in">serve_file</span>(client, path); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//执行cgi文件</span></span><br><span class="line">            <span class="built_in">execute_cgi</span>(client, path, method, query_string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完毕关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-line"><a href="#get-line" class="headerlink" title="get_line"></a>get_line</h3><p>得到一行HTTP报文数据</p><p>这里再强调一下HTTP请求报文的报文头</p><p>报文头的每一行都是以 ‘\r\n’ 结尾的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// &#x27;\n&#x27;就换行了</span></span><br><span class="line">    <span class="keyword">while</span>((i &lt; size - <span class="number">1</span>)&amp;&amp;(c != <span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">        <span class="comment">//一个字节一个字节的接收</span></span><br><span class="line">        n = <span class="built_in">recv</span>(sock, &amp;c , <span class="number">1</span> ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 判断是否接收成功</span></span><br><span class="line">            <span class="comment">// 处理回车符 &#x27;\r&#x27; // 注意：看一下HTTP报文，每一个行的结尾是&#x27;\r\n&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 注意这里 这里的参数是 MSG_PEEK，这指的是‘窥探’ 只是看一下，并不会拿出来</span></span><br><span class="line">                <span class="comment">// 下一次再调用recv的话，取出的还是那个字符   ！！！‘窥探’ </span></span><br><span class="line">                n = <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="keyword">if</span>((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">                    <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后加上 ‘\0’ 结束符</span></span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve-file"><a href="#serve-file" class="headerlink" title="serve_file"></a>serve_file</h3><p>这个主要针对那些没有参数的，不需要运行CGI脚本的请求，这些请求一般只会请求一些文件，咱们直接把请求的文件传递过去就行了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">serve_file</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span></span>&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123; <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        <span class="comment">//后面就销毁头部其他的信息就好了，反正已经知道要返回什么了，并且也知道client客户端的信息，没必要再保留请求报文头了</span></span><br><span class="line">        numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resource = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">//以读的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>)&#123;  <span class="comment">//打开失败</span></span><br><span class="line">        <span class="built_in">not_found</span>(client); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">headers</span>(client, filename); <span class="comment">//组合响应报文头  //这里一定要对着响应报文看一看呀</span></span><br><span class="line">        <span class="built_in">cat</span>(client, resource);     <span class="comment">//把文件传过去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>就是传文件的过程</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cat</span><span class="params">(<span class="type">int</span> client, FILE *resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里就不说了，基本的文件操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), resource);  <span class="comment">// 获取文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(resource))             <span class="comment">// 只要没到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);  <span class="comment">// 一直send</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), resource);  <span class="comment">//再拿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execute-cgi"><a href="#execute-cgi" class="headerlink" title="execute_cgi"></a>execute_cgi</h3><p>这个是用来处理那些带参的，需要运行CGI脚本的请求</p><p>注意：POST 和 GET 请求是不一样的，GET请求会直接将参数附带到URL之中 ?query&#x3D;dsada POST的话得看HTTP报文消息体数据</p><p>这里的处理是，父进程负责读POST请求的参数将参数传递到管道之中，子进程通过管道拿到参数(如果是GET请求的话就不需要拿了)负责运行CGI脚本，将脚本结果传递到管道，父进程再拿到数据，然后send除去</p><pre><code>父进程│├─ 创建管道 cgi_input 和 cgi_output├─ fork()│  ├─ 子进程│  │  ├─ dup2(cgi_output[1], STDOUT)  // 输出重定向│  │  ├─ dup2(cgi_input[0], STDIN)    // 输入重定向│  │  ├─ close(cgi_output[0])         // 关闭无关端│  │  ├─ close(cgi_input[1])│  │  ├─ 设置环境变量（REQUEST_METHOD等）│  │  └─ execl(path)                  // 执行CGI脚本│  ││  └─ 父进程│     ├─ close(cgi_output[1])         // 关闭无关端│     ├─ close(cgi_input[0])│     ├─ 向cgi_input[1]写入POST数据│     └─ 从cgi_output[0]读取CGI输出</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *query_string)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];            <span class="comment">// 缓冲区，用于读取请求头或临时数据</span></span><br><span class="line">    <span class="type">int</span> cgi_output[<span class="number">2</span>];         <span class="comment">// 管道，子进程写输出，父进程读</span></span><br><span class="line">    <span class="type">int</span> cgi_input[<span class="number">2</span>];          <span class="comment">// 管道，父进程写输入，子进程读</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                 <span class="comment">// 进程 ID</span></span><br><span class="line">    <span class="type">int</span> status;                <span class="comment">// 子进程退出状态</span></span><br><span class="line">    <span class="type">int</span> i;                     <span class="comment">// 循环计数器</span></span><br><span class="line">    <span class="type">char</span> c;                    <span class="comment">// 临时字符</span></span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;          <span class="comment">// 记录读取的行数</span></span><br><span class="line">    <span class="type">int</span> content_length = <span class="number">-1</span>;   <span class="comment">// POST 请求的内容长度</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//同理，GET请求不需要那些有的没的 client 有客户端的信息 path有请求的文件，method有请求的方法 query_string有请求的参数</span></span><br><span class="line">        <span class="comment">//剩下的头就没必要用了</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123;</span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123; <span class="comment">//POST 这才是麻烦的 因为 这个没能获取参数，参数在 请求报文里面</span></span><br><span class="line">        numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123; <span class="comment">// 一样的用法 遍历 请求报文</span></span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 截断字符串，检查是否是 &quot;Content-Length:&quot;(Content-Length:字符串长度为15哈)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(buf, <span class="string">&quot;Content-Length:&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                content_length = <span class="built_in">atoi</span>(&amp;(buf[<span class="number">16</span>]));  <span class="comment">//注意这里哈atoi是将字符串转int的函数，这里&amp;(buf[16])不是取 第16个字符和  第16个字符是数字字符串的开始地址</span></span><br><span class="line">            &#125;</span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// 上面的我举个例子：这一行报文头的内容是(首部字段名 + 空格 + 值 + &#x27;\r\n&#x27;) </span></span><br><span class="line">            <span class="comment">// Content-Length: 1234  那么将buf[15] = &#x27;\0&#x27; 则分成了两个串 Content-Length: 与 1234 1234的起始地址为buf[16]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123; <span class="comment">//同样的处理异常情况</span></span><br><span class="line">            <span class="built_in">bad_request</span>(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//其他请求，这里暂时不支持哈</span></span><br><span class="line">        <span class="built_in">unimplemented</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管道创建失败，返回 500 错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);  <span class="comment">// fork 失败，返回 500 错误</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里发送了200的信息，其实不应该的，应该执行完CGI再发的，毕竟执行的时候可能会出现错误</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> length_env[<span class="number">255</span>];</span><br><span class="line">        <span class="comment">// cgi_output这个pipe的写端，重定向到标准输出流，</span></span><br><span class="line">        <span class="comment">// 即cgi脚本的控制台输出，会传递到cgi_output这个pipe中。</span></span><br><span class="line">        <span class="comment">// 后续父进程可以从cgi_output里读cgi脚本处理结果</span></span><br><span class="line">        <span class="built_in">dup2</span>(cgi_output[<span class="number">1</span>], STDOUT); <span class="comment">//这里是啥意思呢？简单举个例子：咱们的执行的CGI文件应该是输出到控制台的也就是STDOUT，现在把STDOUT与管道的cgi_output[1]链接在一起，也就是会写到管道里面</span></span><br><span class="line">        <span class="comment">// cgi_input这个pipe的读端，重定向到标准输入流。</span></span><br><span class="line">        <span class="comment">// 这意味着以后从标准输入读取数据时，实际上是从cgi_input这个pipe中读取数据。</span></span><br><span class="line">        <span class="comment">// 后续父进程向cgi_input里写入数据，等于向标准输入流写入数据</span></span><br><span class="line">        <span class="built_in">dup2</span>(cgi_input[<span class="number">0</span>], STDIN);   <span class="comment">//这个也是一样的STDIN标准输入，现在他也接受cgi_input[0]的输入//这个例子还是不太清楚，我写的可能也有点模糊，README之中有个图，参考理解一下</span></span><br><span class="line">        <span class="comment">//在子进程中，关闭另外2个pipe的端口</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//写入新的环境变量，用于后续cgi脚本使用</span></span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">&quot;REQUEST_METHOD=%s&quot;</span>, method);</span><br><span class="line">        <span class="built_in">putenv</span>(meth_env);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123; <span class="comment">//get</span></span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, query_string);</span><br><span class="line">            <span class="built_in">putenv</span>(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);</span><br><span class="line">            <span class="built_in">putenv</span>(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换后续代码的进程镜像，执行cgi脚本。</span></span><br><span class="line">        <span class="built_in">execl</span>(path,path, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//int m = execl(path, path, NULL);</span></span><br><span class="line">        <span class="comment">//如果path有问题，例如将html网页改成可执行的，但是执行后m为-1</span></span><br><span class="line">        <span class="comment">//退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal SIGPIPE, Broken pipe.</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;    <span class="comment">/* parent */</span></span><br><span class="line">        <span class="comment">//关闭无用管道口</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//父进程拿参数 输入的 管道 再让子进程 拿</span></span><br><span class="line">        <span class="comment">//得到post请求数据，写到input管道中，供子进程使用</span></span><br><span class="line">        <span class="comment">//其实是向标准输入流写数据，cgi脚本会从标准输入流，获取post协议携带的数据，做出处理。</span></span><br><span class="line">        <span class="comment">//考虑父子进程启动顺序问题</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 父进程先启动，则post协议数据被存入标准输入流，等待子进程启动后，调用cgi脚本，脚本从标准输入流得到post数据</span></span><br><span class="line"><span class="comment">         * 2. 子进程先启动，则需要从标准输入得到数据的cgi脚本，需要阻塞等待，直到父进程把post数据填入标准输入流。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">                <span class="built_in">recv</span>(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">write</span>(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从output管道读到子进程处理后的信息，然后send出去</span></span><br><span class="line">        <span class="comment">//其实是cgi脚本运行后，向控制台打印的标准输出流，被重定向到cgi_output这个pipe里。</span></span><br><span class="line">        <span class="comment">//因此父进程是截获了cgi脚本的运行结果，转发给http客户端了。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">send</span>(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成操作后关闭管道</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里整体看来其实没什么大问题，但是管道那部分比较难理解，下面是GIT官方源码里面给的图，配合这个图就很好理解了（官方的图实效了，不知道咋回事，在这里找到的<a href="https://www.cnblogs.com/pluviophile/p/7440529.html%EF%BC%89">https://www.cnblogs.com/pluviophile/p/7440529.html）</a></p><p><img src="/../0_images/Tinyhttpd/4_%E7%AE%A1%E9%81%93.png" alt="alt text"></p><h1 id="总体代码："><a href="#总体代码：" class="headerlink" title="总体代码："></a>总体代码：</h1><p><a href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISspace(x) isspace((int) x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_STRING <span class="string">&quot;Server: jdbhttpd/0.1.0\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对收到的请求进行处理，每次受到请求都会创建一个新的线程来做处理</span></span><br><span class="line"><span class="comment">// 这个就是定义的线程函数，void * 其实是用来接收 client_sock 的</span></span><br><span class="line"><span class="comment">// 其实这里我觉得使用int 来接收可能更好一些，可能原作者有一些其他的想法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept_request</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理一些错误的请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_request</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cat</span><span class="params">(<span class="type">int</span>,FILE *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法执行的错误操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行CIG脚本 // 如果没接触CIG也没关系，CIG可以直接用人家的，咱们第一次学的话就先学习网络的操作，后续想要加深理解可以学一下CIG</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到一行数据 这里要注意看里面咋操作的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回http头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有发现文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">not_found</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是CGI文件，直接读取文件返回给请求的http客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serve_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启tcp连接，绑定端口等操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">startup</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是Get或者Post，就报方法没有实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unimplemented</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一些功能性的函数，包括错误处理等，这个挺好理解的，但是要看一看</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_request</span><span class="params">(<span class="type">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 400 BAD REQUEST\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Your browser sent a bad request, &quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;such as a POST without a Content-Length.\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="type">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 500 Internal Server Error\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Error prohibited CGI execution.\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">headers</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    (<span class="type">void</span>)filename;  <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, SERVER_STRING);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">not_found</span><span class="params">(<span class="type">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;your request because the resource specified\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;is unavailable or nonexistent.\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unimplemented</span><span class="params">(<span class="type">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 501 Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(sc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是比较重要的一些操作，仔细看，对着重写一遍，了解过程，细节</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="comment"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="comment"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="comment"> * port.</span></span><br><span class="line"><span class="comment"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="comment"> * Returns: the socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">startup</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *port)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> httpd = <span class="number">0</span>; <span class="comment">//serverFd</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> name;</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    httpd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空一下内容 后面再赋值</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="built_in">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port = <span class="built_in">htons</span>(*port); <span class="comment">//小端转大端</span></span><br><span class="line">    name.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//本地能使用的IP地址都行</span></span><br><span class="line">    <span class="comment">// 这个是为了复用端口的，其实有没有都可以，不太重要</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">setsockopt</span>(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on))) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(httpd,(<span class="keyword">struct</span> sockaddr *)&amp;name,<span class="built_in">sizeof</span>(name))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有提供端口，系统会分配一个端口</span></span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> namelen = <span class="built_in">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getsockname</span>(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_die</span>(<span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line">        *port = <span class="built_in">ntohs</span>(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error_die</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> httpd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// &#x27;\n&#x27;就换行了</span></span><br><span class="line">    <span class="keyword">while</span>((i &lt; size - <span class="number">1</span>)&amp;&amp;(c != <span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">        <span class="comment">//一个字节一个字节的接收</span></span><br><span class="line">        n = <span class="built_in">recv</span>(sock, &amp;c , <span class="number">1</span> ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 判断是否接收成功</span></span><br><span class="line">            <span class="comment">// 处理回车符 &#x27;\r&#x27; // 注意：看一下HTTP报文，每一个行的结尾是&#x27;\r\n&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 注意这里 这里的参数是 MSG_PEEK，这指的是‘窥探’ 只是看一下，并不会拿出来</span></span><br><span class="line">                <span class="comment">// 下一次再调用recv的话，取出的还是那个字符   ！！！‘窥探’ </span></span><br><span class="line">                n = <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="keyword">if</span>((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">                    <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后加上 ‘\0’ 结束符</span></span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX &quot;cat&quot; command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cat</span><span class="params">(<span class="type">int</span> client, FILE *resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里就不说了，基本的文件操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), resource);  <span class="comment">// 获取文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">feof</span>(resource))             <span class="comment">// 只要没到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);  <span class="comment">// 一直send</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), resource);  <span class="comment">//再拿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//如果不是CGI文件，直接读取文件返回给请求的http客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serve_file</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span></span>&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123; <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        <span class="comment">//后面就销毁头部其他的信息就好了，反正已经知道要返回什么了，并且也知道client客户端的信息，没必要再保留请求报文头了</span></span><br><span class="line">        numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resource = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">//以读的方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>)&#123;  <span class="comment">//打开失败</span></span><br><span class="line">        <span class="built_in">not_found</span>(client); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">headers</span>(client, filename); <span class="comment">//组合响应报文头  //这里一定要对着响应报文看一看呀</span></span><br><span class="line">        <span class="built_in">cat</span>(client, resource);     <span class="comment">//把文件传过去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *path,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *query_string)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];            <span class="comment">// 缓冲区，用于读取请求头或临时数据</span></span><br><span class="line">    <span class="type">int</span> cgi_output[<span class="number">2</span>];         <span class="comment">// 管道，子进程写输出，父进程读</span></span><br><span class="line">    <span class="type">int</span> cgi_input[<span class="number">2</span>];          <span class="comment">// 管道，父进程写输入，子进程读</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                 <span class="comment">// 进程 ID</span></span><br><span class="line">    <span class="type">int</span> status;                <span class="comment">// 子进程退出状态</span></span><br><span class="line">    <span class="type">int</span> i;                     <span class="comment">// 循环计数器</span></span><br><span class="line">    <span class="type">char</span> c;                    <span class="comment">// 临时字符</span></span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;          <span class="comment">// 记录读取的行数</span></span><br><span class="line">    <span class="type">int</span> content_length = <span class="number">-1</span>;   <span class="comment">// POST 请求的内容长度</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//同理，GET请求不需要那些有的没的 client 有客户端的信息 path有请求的文件，method有请求的方法 query_string有请求的参数</span></span><br><span class="line">        <span class="comment">//剩下的头就没必要用了</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123;</span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123; <span class="comment">//POST 这才是麻烦的 因为 这个没能获取参数，参数在 请求报文里面</span></span><br><span class="line">        numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123; <span class="comment">// 一样的用法 遍历 请求报文</span></span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 截断字符串，检查是否是 &quot;Content-Length:&quot;(Content-Length:字符串长度为15哈)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(buf, <span class="string">&quot;Content-Length:&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                content_length = <span class="built_in">atoi</span>(&amp;(buf[<span class="number">16</span>]));  <span class="comment">//注意这里哈atoi是将字符串转int的函数，这里&amp;(buf[16])不是取 第16个字符和  第16个字符是数字字符串的开始地址</span></span><br><span class="line">            &#125;</span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="comment">// 上面的我举个例子：这一行报文头的内容是(首部字段名 + 空格 + 值 + &#x27;\r\n&#x27;) </span></span><br><span class="line">            <span class="comment">// Content-Length: 1234  那么将buf[15] = &#x27;\0&#x27; 则分成了两个串 Content-Length: 与 1234 1234的起始地址为buf[16]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123; <span class="comment">//同样的处理异常情况</span></span><br><span class="line">            <span class="built_in">bad_request</span>(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//其他请求，这里暂时不支持哈</span></span><br><span class="line">        <span class="built_in">unimplemented</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管道创建失败，返回 500 错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cannot_execute</span>(client);  <span class="comment">// fork 失败，返回 500 错误</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="comment">// │</span></span><br><span class="line">    <span class="comment">// ├─ 创建管道 cgi_input 和 cgi_output</span></span><br><span class="line">    <span class="comment">// ├─ fork()</span></span><br><span class="line">    <span class="comment">// │  ├─ 子进程</span></span><br><span class="line">    <span class="comment">// │  │  ├─ dup2(cgi_output[1], STDOUT)  // 输出重定向</span></span><br><span class="line">    <span class="comment">// │  │  ├─ dup2(cgi_input[0], STDIN)    // 输入重定向</span></span><br><span class="line">    <span class="comment">// │  │  ├─ close(cgi_output[0])         // 关闭无关端</span></span><br><span class="line">    <span class="comment">// │  │  ├─ close(cgi_input[1])</span></span><br><span class="line">    <span class="comment">// │  │  ├─ 设置环境变量（REQUEST_METHOD等）</span></span><br><span class="line">    <span class="comment">// │  │  └─ execl(path)                 // 执行CGI脚本</span></span><br><span class="line">    <span class="comment">// │  │</span></span><br><span class="line">    <span class="comment">// │  └─ 父进程</span></span><br><span class="line">    <span class="comment">// │     ├─ close(cgi_output[1])        // 关闭无关端</span></span><br><span class="line">    <span class="comment">// │     ├─ close(cgi_input[0])</span></span><br><span class="line">    <span class="comment">// │     ├─ 向cgi_input[1]写入POST数据</span></span><br><span class="line">    <span class="comment">// │     └─ 从cgi_output[0]读取CGI输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里发送了200的信息，其实不应该的，应该执行完CGI再发的，毕竟执行的时候可能会出现错误</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> length_env[<span class="number">255</span>];</span><br><span class="line">        <span class="comment">// cgi_output这个pipe的写端，重定向到标准输出流，</span></span><br><span class="line">        <span class="comment">// 即cgi脚本的控制台输出，会传递到cgi_output这个pipe中。</span></span><br><span class="line">        <span class="comment">// 后续父进程可以从cgi_output里读cgi脚本处理结果</span></span><br><span class="line">        <span class="built_in">dup2</span>(cgi_output[<span class="number">1</span>], STDOUT); <span class="comment">//这里是啥意思呢？简单举个例子：咱们的执行的CGI文件应该是输出到控制台的也就是STDOUT，现在把STDOUT与管程的cgi_output[1]链接在一起，也就是会写到管程里面</span></span><br><span class="line">        <span class="comment">// cgi_input这个pipe的读端，重定向到标准输入流。</span></span><br><span class="line">        <span class="comment">// 这意味着以后从标准输入读取数据时，实际上是从cgi_input这个pipe中读取数据。</span></span><br><span class="line">        <span class="comment">// 后续父进程向cgi_input里写入数据，等于向标准输入流写入数据</span></span><br><span class="line">        <span class="built_in">dup2</span>(cgi_input[<span class="number">0</span>], STDIN);   <span class="comment">//这个也是一样的STDIN标准输入，现在他也接受cgi_input[0]的输入//这个例子还是不太清楚，我写的可能也有点模糊，README之中有个图，参考理解一下</span></span><br><span class="line">        <span class="comment">//在子进程中，关闭另外2个pipe的端口</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//写入新的环境变量，用于后续cgi脚本使用</span></span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">&quot;REQUEST_METHOD=%s&quot;</span>, method);</span><br><span class="line">        <span class="built_in">putenv</span>(meth_env);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123; <span class="comment">//get</span></span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, query_string);</span><br><span class="line">            <span class="built_in">putenv</span>(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);</span><br><span class="line">            <span class="built_in">putenv</span>(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换后续代码的进程镜像，执行cgi脚本。</span></span><br><span class="line">        <span class="built_in">execl</span>(path,path, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//int m = execl(path, path, NULL);</span></span><br><span class="line">        <span class="comment">//如果path有问题，例如将html网页改成可执行的，但是执行后m为-1</span></span><br><span class="line">        <span class="comment">//退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal SIGPIPE, Broken pipe.</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;    <span class="comment">/* parent */</span></span><br><span class="line">        <span class="comment">//关闭无用管道口</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//父进程拿参数 输入的 管程 再让子进程 拿</span></span><br><span class="line">        <span class="comment">//得到post请求数据，写到input管道中，供子进程使用</span></span><br><span class="line">        <span class="comment">//其实是向标准输入流写数据，cgi脚本会从标准输入流，获取post协议携带的数据，做出处理。</span></span><br><span class="line">        <span class="comment">//考虑父子进程启动顺序问题</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 父进程先启动，则post协议数据被存入标准输入流，等待子进程启动后，调用cgi脚本，脚本从标准输入流得到post数据</span></span><br><span class="line"><span class="comment">         * 2. 子进程先启动，则需要从标准输入得到数据的cgi脚本，需要阻塞等待，直到父进程把post数据填入标准输入流。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">                <span class="built_in">recv</span>(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">write</span>(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从output管道读到子进程处理后的信息，然后send出去</span></span><br><span class="line">        <span class="comment">//其实是cgi脚本运行后，向控制台打印的标准输出流，被重定向到cgi_output这个pipe里。</span></span><br><span class="line">        <span class="comment">//因此父进程是截获了cgi脚本的运行结果，转发给http客户端了。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">send</span>(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成操作后关闭管道</span></span><br><span class="line">        <span class="built_in">close</span>(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accept_request</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client = (<span class="type">intptr_t</span>)arg; <span class="comment">// clientFd</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];      <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> numchars;     <span class="comment">//存储get_line返回的第一行的长度</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">255</span>];    <span class="comment">//存储请求的方法，这里只支持两种 POST与GET</span></span><br><span class="line">    <span class="type">char</span> url[<span class="number">255</span>];       <span class="comment">//存储URL</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">512</span>];      <span class="comment">//存储路径 就是资源文件的路径 咱们这里的资源文件存储到 htdocs 里面了</span></span><br><span class="line">    <span class="type">size_t</span> i, j;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="type">int</span> cgi = <span class="number">0</span>;         <span class="comment">//一个标志，看需不需要调用 CGI 程序</span></span><br><span class="line">    <span class="type">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    i = <span class="number">0</span>;j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意这里一定要对这HTTP报文头来看，HTTP 请求报文第一行 方法（post get ..） + 空格 + URL + 空格 + 版本 + ‘\r\n’</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ISspace</span>(buf[i]) &amp;&amp; (i &lt; <span class="built_in">sizeof</span>(method)<span class="number">-1</span>))&#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;  <span class="comment">// 保存一下现在的位置</span></span><br><span class="line">    method[i] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 字符串结束符号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strcasecmp 这个就不过多解释了，忽略大小写比较字符串，等于0的时候表示两个字符串在忽略大小写的时候完全相等</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) &amp;&amp; <span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 这里就只有GET 和 POST两种请求，其他的不支持</span></span><br><span class="line">        <span class="built_in">unimplemented</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是POST，cgi置为1 需要运行CGI脚本</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过着一个空格</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">ISspace</span>(buf[j]) &amp;&amp; (j &lt; numchars))&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要处理下一个东西了 URL</span></span><br><span class="line">    <span class="comment">//再强调一下HTTP请求报文的第一行  HTTP 请求报文第一行 方法（post get ..） + 空格 + URL + 空格 + 版本 + ‘\r\n’</span></span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 还是一样的操作，先把url拿过来</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">ISspace</span>(buf[j]) &amp;&amp; (i &lt; <span class="built_in">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; numchars))&#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://127.0.0.1:9734/</span></span><br><span class="line">    <span class="comment">//http://127.0.0.1:9734/color.cgi?color=red  </span></span><br><span class="line">    <span class="comment">//注意哈，前面是IP + 端口 不是 url 内部 哈 这个 第二个实际发送的是 实际客户发送的为 GET /color.cgi?color=red HTTP/1.1 记得看一下HTTP请求报文头</span></span><br><span class="line">    <span class="comment">//处理get请求，get请求如果不带参数就是上面第一种，get请求如果带参数就是上面第二种，参数放在?后面，color=red 参数名=参数值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="comment">//找一下?的位置 或者没有的话就到结尾了</span></span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="string">&#x27;\0&#x27;</span>))&#123;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理一下带参数的get请求</span></span><br><span class="line">        <span class="keyword">if</span>(*query_string == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            cgi = <span class="number">1</span>; <span class="comment">// 带参数就得调用CGI脚本了</span></span><br><span class="line">            *query_string = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 注意这里把url给截断了 ? 改成 &#x27;\0&#x27; 表示结尾 color.cgi?color=red - &gt; color.cgi</span></span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把地址拿一下，注意以下htdocs是相对地址哈，我的可执行文件放在了build里面了，build与htdocs同级，所以是</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;../htdocs%s&quot;</span>, url);   <span class="comment">//还是拿上面第一个和第二个例子距离，如果没有参数 那么路径为 ../htdocs/  有参数则为../htdocs/color.cgi(因此这个需要cgi = 1)</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="built_in">strlen</span>(path)<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span>)&#123;     <span class="comment">//无参的情况</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">&quot;index.html&quot;</span>);      <span class="comment">//把咱们的初始界面 index.html 加上 然后 返回去给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(path, &amp;st) == <span class="number">-1</span>) &#123; <span class="comment">// stat 失败（文件或者目录不存在） stat 成功返回 0 反之 返回 -1</span></span><br><span class="line">        <span class="comment">// 读取并丢弃剩余的请求头（直到空行）销毁报文头 返回 404 就好了</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf))&#123;  <span class="comment">// 注意：HTTP 头以 \r\n 结尾</span></span><br><span class="line">            numchars = <span class="built_in">get_line</span>(client, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">not_found</span>(client); <span class="comment">// 发送 404 Not Found</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 这里再次判断是个目录还是文件 详细的看一下struct stat 了解一下，这里就不多介绍了</span></span><br><span class="line">        <span class="comment">// 知道这是一个判断目录还是文件的操作就好了</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)&#123; </span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">&quot;/index.html&quot;</span>); <span class="comment">//还是一样的操作，是目录就加上 index.html </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查文件是否有执行权限（任意用户组）</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||    <span class="comment">//检查所有者是否有执行权限。</span></span><br><span class="line">            (st.st_mode &amp; S_IXGRP) ||    <span class="comment">//检查组是否有执行权限。</span></span><br><span class="line">            (st.st_mode &amp; S_IXOTH)    )&#123; <span class="comment">//检查其他人是否有执行权限</span></span><br><span class="line">                cgi = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cgi)&#123;</span><br><span class="line">            <span class="comment">//接读取文件返回给请求的http客户端</span></span><br><span class="line">            <span class="built_in">serve_file</span>(client, path); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//执行cgi文件</span></span><br><span class="line">            <span class="built_in">execute_cgi</span>(client, path, method, query_string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完毕关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> server_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="number">4000</span>;</span><br><span class="line">    <span class="type">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_name;</span><br><span class="line">    <span class="comment">// 注意这个类型哈,因为后面要取地，所以不能是size_t 或者 int 等其他类型 (函数就是这么定义的)</span></span><br><span class="line">    <span class="type">socklen_t</span> client_name_len = <span class="built_in">sizeof</span>(client_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="type">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line">    server_sock = <span class="built_in">startup</span>(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//socket - accept</span></span><br><span class="line">        client_sock = <span class="built_in">accept</span>(server_sock,(<span class="keyword">struct</span> sockaddr *)&amp;client_name,&amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span>(client_sock == <span class="number">-1</span>)&#123; <span class="comment">// 没accept到，错误处理</span></span><br><span class="line">            <span class="built_in">error_die</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面加一个线程来处理这个HTTP请求</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;newthread,<span class="literal">NULL</span>,(<span class="type">void</span>*)accept_request,(<span class="type">void</span> *)(<span class="type">intptr_t</span>)client_sock)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(server_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：我习惯用Cmake</span><br><span class="line"></span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>emmm, 好像写了又好像没写，哈哈哈哈，刚开始写README的时候想好好整理一下，但是写的过程中附上代码又感觉自己注释写的听清楚的，不知道补充啥。</p><p>git: <a href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/12/hello-world/"/>
      <url>/2025/04/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
