<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>My New Post</title>
      <link href="/2025/04/13/My-New-Post/"/>
      <url>/2025/04/13/My-New-Post/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池项目"><a href="#线程池项目" class="headerlink" title="线程池项目"></a>线程池项目</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>线程池的概念：</p><p>线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。</p><p>说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程</p><p>那么我们就可以想到一个线程池的最基础的构造</p><p>变量：</p><ul><li>一个vector 用来存储构造好的线程</li><li>一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 )</li><li>mutex  有了queue自然得考虑到互斥的问题</li><li>condition_variable 条件变量 同mutex理</li><li>flag   停止标识</li></ul><p>函数：</p><ul><li>首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数)</li><li>其次得有线程的释放join 的函数  （此处可以使用类的析构函数）</li><li>还有得有添加任务的函数</li></ul><h2 id="ThreadPool声明"><a href="#ThreadPool声明" class="headerlink" title="ThreadPool声明"></a>ThreadPool声明</h2><p>通过前面描述来声明一下CLASS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;        <span class="comment">// 工作线程集合</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列（存储无参void函数）</span></span><br><span class="line">    std::mutex queue_mutex;                  <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    std::condition_variable condition;       <span class="comment">// 线程间通信的条件变量</span></span><br><span class="line">    <span class="type">bool</span> stop;                               <span class="comment">// 停止标志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>); <span class="comment">// 构造函数，参数为线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>; <span class="comment">// 任务入队方法</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>(); <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里其他的都比较好理解，主要是enqueue函数难以理解，这个先放一放，后面再详细解释</p><h2 id="ThreadPool构造函数，初始化函数的实现"><a href="#ThreadPool构造函数，初始化函数的实现" class="headerlink" title="ThreadPool构造函数，初始化函数的实现"></a>ThreadPool构造函数，初始化函数的实现</h2><p>这个其实没啥说的，很常规的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threadsNum)</span>:stop(false)&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;threadsNum; i++)&#123;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>( <span class="comment">// 创建线程并绑定到Lambda</span></span><br><span class="line">            [<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;      <span class="comment">// 无限循环，直到线程池停止</span></span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop||!<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();</span><br><span class="line">                        &#125;);<span class="comment">// 等待任务或停止信号（如果任务列表为空或者是stop为true的话，就会一直等待）</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                           <span class="keyword">return</span>;   <span class="comment">// 停止且无任务时退出线程</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());  <span class="comment">//取任务</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125; <span class="comment">//这里会自动释放锁</span></span><br><span class="line">                    <span class="built_in">task</span>(); <span class="comment">//执行任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPool析构函数，函数的释放"><a href="#ThreadPool析构函数，函数的释放" class="headerlink" title="~ThreadPool析构函数，函数的释放"></a>~ThreadPool析构函数，函数的释放</h2><p>emmm 这个也常规</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;stop = <span class="literal">true</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="keyword">for</span>(std::thread&amp; worker:<span class="keyword">this</span>-&gt;workers)&#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();      <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="enqueue-添加任务功能的实现"><a href="#enqueue-添加任务功能的实现" class="headerlink" title="enqueue 添加任务功能的实现"></a>enqueue 添加任务功能的实现</h2><p>这里就是最为复杂的地方，本来也是挺常规的，正常的传入（无参void函数）就行了，但是确实会出现问题，这样的话就只能处理 无参void函数 这一种类型了，这显然很有局限性。因此便有了这样一种书写方式</p><p>基本思想：将一个带参数的有返回值的函数，转化一下，转化为 无参void函数 就行了</p><p>先把代码发放上来，稍后一句一句分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下函数的声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure><p>定义的是一个模板，template &lt;class F, class… Args&gt;  两个参数</p><ul><li>class F：接受任意类型的可调用对象（函数、Lambda、函数对象等）。</li><li>class… Args：接受任意数量和类型的参数包。</li></ul><p>函数参数</p><ul><li>F&amp;&amp; f：万能引用（不是右值引用！），可以绑定到任意类型的可调用对象（左值或右值）。</li><li>Args&amp;&amp;… args：参数包的万能引用，保留参数的原始值类别（左值&#x2F;右值）。</li></ul><p>注意：这里的返回值是auto 是根据箭头后面的来推理出来的</p><ul><li>-&gt; std::future&lt;typename std::result_of&lt;F(Args…)&gt;::type&gt;</li><li>future用于异步获取进程的返回值</li><li>result_of获取函数 F(Args…) 的返回值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>packaged_task包装，这个下面解释，先解释一下bind函数</p><p>bind函数，这里使用的很巧妙</p><p>这里可以看一下bind的用法，这个挺重要的 <a href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p><p>这里就介绍一下bind在这里的用法</p><p>对于一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print: x = &quot;</span> &lt;&lt; x </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, z = &quot;</span> &lt;&lt; z </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是有三个参数的，x y z ，我们通过 bind 来做处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f2 的第一，二个参数指定</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(fun_1, std::placeholders::_1, std::placeholders::_2, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样的话：绑定函数 fun 的第一，二，三个参数值为： 1 2 3</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(fun_1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f2</span>();     <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br></pre></td></tr></table></figure><p>这里的用法是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br></pre></td></tr></table></figure><p>实现了从有参到无参数的转化</p><p>继续:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure><p>这里解释一下上面说的 packaged_task </p><p>std::packaged_task&lt;return_type()&gt; 的核心目的是将任意函数 ​​包装成异步任务​​，并自动关联一个 std::future 用于获取结果。</p><ul><li>std::packaged_task&lt;return_type()&gt; task(func); &#x2F;&#x2F; 包装为 packaged_task<ul><li>此时，task 的签名是 return_type()，即调用 task() 会执行 func 并返回结果。</li><li>packaged_task 内部维护一个 ​​共享状态​​（shared state），当调用 task() 执行函数时：<ul><li>执行绑定的函数 func</li><li>将函数返回值存入共享状态</li><li>唤醒通过 future 等待该结果的线程</li></ul></li></ul></li></ul><p>为什么上面的语句 未执行就能获取 future</p><p>std::future<return_type> res &#x3D; task-&gt;get_future();</p><ul><li>future 是一个 ​​结果的占位符​​，它的有效性从 packaged_task 创建时就开始，与任务执行时机无关。调用 res.get() 时：<ul><li>若任务已执行：立即返回结果</li><li>若任务未执行：阻塞等待结果</li></ul></li></ul><p>为什么要用make_shared管理</p><p>auto task &#x3D; std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(…);</p><ul><li>确保 packaged_task 存活至任务被执行</li><li>不用手动释放(只能指针的妙用嘛)</li></ul><p>继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面不用多说，主要是最后一行</p><p>task经过之前的处理，已经相当于一个 函数指针 了，这里直接调用 (*task)() 他的返回值由 packaged_task 管理</p><p>我们整体来看：Lambda  表达式 <a href="">task</a> { (*task)(); } 就是一个无参数，无返回值的函数 因此 可以正常的 放到 this-&gt;tasks里面</p><p>继续：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>没啥好说的</p><p>我们最后再整体看一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理流程：</p><ul><li>用户调用 enqueue​<ul><li>提交函数 f 和参数 args，要求返回 future。</li></ul></li><li>创建 packaged_task​<ul><li>将 f(args…) 绑定为 return_type() 类型的任务。</li></ul></li><li>获取 future​<ul><li>立即通过 task-&gt;get_future() 获取结果占位符。</li></ul></li><li>​​封装为 void() 任务​<ul><li>将任务包装为 <a href="">task</a>{ (*task)(); }，符合队列类型。</li></ul></li><li>​​任务入队与通知​<ul><li>唤醒线程池中的工作线程。</li></ul></li><li>​​任务执行​<ul><li>工作线程调用 (*task)()，执行用户函数并存储结果到共享状态。</li></ul></li><li>​​用户获取结果​<ul><li>用户通过 future.get() 等待或获取结果。</li></ul></li></ul><h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="language-cpp">#include &lt;iostream&gt;#include &quot;include/threadPool.h&quot;using namespace std;int main()&#123;    // 测试1：基本任务执行和返回值    &#123;        ThreadPool pool(2);        auto future_add = pool.enqueue([](int a, int b) &#123;            return a + b;        &#125;, 2, 3);        int result = future_add.get();        std::cout &lt;&lt; &quot;Test 1: 2 + 3 = &quot; &lt;&lt; result &lt;&lt; std::endl;  // 预期输出5    &#125;    // 测试2：并行执行多个任务    &#123;        const int num_tasks = 8;        ThreadPool pool(4);        std::vector&lt;std::future&lt;int&gt;&gt; futures;                for (int i = 0; i &lt; num_tasks; ++i) &#123;            futures.emplace_back(pool.enqueue([i] &#123;                std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟耗时操作                return i * i;            &#125;));        &#125;        std::cout &lt;&lt; &quot;Test 2: Results: &quot;;        for (auto&amp; fut : futures) &#123;            std::cout &lt;&lt; fut.get() &lt;&lt; &quot; &quot;;  // 预期输出0 1 4 9 16 25 36 49（顺序可能不同）        &#125;        std::cout &lt;&lt; &quot;\n&quot;;    &#125;    // 测试3：异常传播    &#123;        ThreadPool pool(2);        auto future_exception = pool.enqueue([] &#123;            throw std::runtime_error(&quot;Intentional exception&quot;);            return 0;        &#125;);        try &#123;            future_exception.get();        &#125; catch (const std::exception&amp; e) &#123;            std::cout &lt;&lt; &quot;Test 3: Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        &#125;    &#125;    // 测试4：线程池自动回收（通过作用域生命周期）    &#123;        std::cout &lt;&lt; &quot;Test 4: Creating nested thread pool...&quot; &lt;&lt; std::endl;        &#123;            ThreadPool inner_pool(2);            inner_pool.enqueue([] &#123;                std::cout &lt;&lt; &quot;Task executed in inner pool&quot; &lt;&lt; std::endl;            &#125;);        &#125;  // 此处inner_pool析构，自动等待任务完成        std::cout &lt;&lt; &quot;Inner pool destroyed&quot; &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;All tests completed successfully.&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>cd build</p><p>cmake .. </p><p>make</p><p>.&#x2F;threadPool</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/12/hello-world/"/>
      <url>/2025/04/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
