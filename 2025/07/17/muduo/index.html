<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ Muduo 库 | 张振强的个人博客</title><meta name="author" content="张振强"><meta name="copyright" content="张振强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ Muduo 库https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1UE4m1R72y&#x2F;?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;28887ecca1f25a715214067a2b3b58ac   noncopyable 禁止拷贝我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承no">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Muduo 库">
<meta property="og:url" content="http://example.com/2025/07/17/muduo/index.html">
<meta property="og:site_name" content="张振强的个人博客">
<meta property="og:description" content="C++ Muduo 库https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1UE4m1R72y&#x2F;?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;28887ecca1f25a715214067a2b3b58ac   noncopyable 禁止拷贝我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承no">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/2.png">
<meta property="article:published_time" content="2025-07-17T02:05:26.162Z">
<meta property="article:modified_time" content="2025-07-17T02:12:22.163Z">
<meta property="article:author" content="张振强">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++ Muduo 库",
  "url": "http://example.com/2025/07/17/muduo/",
  "image": "http://example.com/img/cover/2.png",
  "datePublished": "2025-07-17T02:05:26.162Z",
  "dateModified": "2025-07-17T02:12:22.163Z",
  "author": [
    {
      "@type": "Person",
      "name": "张振强",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_1.png"><link rel="canonical" href="http://example.com/2025/07/17/muduo/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Muduo 库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/index_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">张振强的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ Muduo 库</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ Muduo 库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-17T02:05:26.162Z" title="发表于 2025-07-17 10:05:26">2025-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-17T02:12:22.163Z" title="更新于 2025-07-17 10:12:22">2025-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%A1%B9%E7%9B%AE/">C++ 项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-Muduo-库"><a href="#C-Muduo-库" class="headerlink" title="C++ Muduo 库"></a>C++ Muduo 库</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&vd_source=28887ecca1f25a715214067a2b3b58ac">https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac</a></p>
<p><img src="/img/load4.gif" data-original="/../0_images/muduo/muduo%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="alt text"></p>
<p><img src="/img/load4.gif" data-original="/../0_images/muduo/muduo%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="alt text"></p>
<h1 id="noncopyable-禁止拷贝"><a href="#noncopyable-禁止拷贝" class="headerlink" title="noncopyable 禁止拷贝"></a>noncopyable 禁止拷贝</h1><p>我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承noncopyable类，我们看一下noncopyable.h代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NONCOPYABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCOPYABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>noncopyable会取消拷贝构造，这样子类继承它之后，在调用构造函数进行构造的时候会默认调用父类的构造函数来构造父类的属性，因此当进行拷贝构造的时候就会发现，父类没有拷贝构造，因此就无法实现，从而无法实现拷贝构造</p>
<h1 id="Timestamp-时间类"><a href="#Timestamp-时间类" class="headerlink" title="Timestamp 时间类"></a>Timestamp 时间类</h1><p>主要是用于格式化输出当前的时间，向外提供接口就好，非常的简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIMESTAMP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMESTAMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timestamp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    <span class="built_in">Timestamp</span>(); </span><br><span class="line">    <span class="comment">//带参构造 explicit 是为了防止编译器将microSecondsSinceEpoch优化成int</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timestamp</span><span class="params">(<span class="type">int64_t</span> microSecondsSinceEpoch)</span></span>; </span><br><span class="line">    <span class="comment">//返回当前的Timestamp</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Timestamp <span class="title">now</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//转化为string输出 //一般是Timestamp::now().toString() 这样用</span></span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>():<span class="built_in">microSecondsSinceEpoch_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//带参构造</span></span><br><span class="line">Timestamp::<span class="built_in">Timestamp</span>(<span class="type">int64_t</span> microSecondsSinceEpoch)</span><br><span class="line">    : <span class="built_in">microSecondsSinceEpoch_</span>(microSecondsSinceEpoch)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的Timestamp</span></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Timestamp</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化输出</span></span><br><span class="line"><span class="function">std::string <span class="title">Timestamp::toString</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    tm *tm_time = <span class="built_in">localtime</span>(&amp;microSecondsSinceEpoch_);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">128</span>, <span class="string">&quot;%4d/%02d/%02d %02d:%02d:%02d&quot;</span>, </span><br><span class="line">        tm_time-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">        tm_time-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">        tm_time-&gt;tm_mday,</span><br><span class="line">        tm_time-&gt;tm_hour,</span><br><span class="line">        tm_time-&gt;tm_min,</span><br><span class="line">        tm_time-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; Timestamp::now().toString() &lt;&lt; std::endl; </span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>


<h1 id="Logger-日志"><a href="#Logger-日志" class="headerlink" title="Logger 日志"></a>Logger 日志</h1><p>向外提供打印的接口，用以输出log信息，一共由四种信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义日志的级别 INFO ERROR FATAL DEBUG</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line">    INFO,  <span class="comment">// 普通信息</span></span><br><span class="line">    ERROR, <span class="comment">// 错误信息</span></span><br><span class="line">    FATAL, <span class="comment">// 崩溃信息(无法挽回的一些错误)</span></span><br><span class="line">    DEBUG, <span class="comment">// 调试信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Logger class 里面只需要设置最为简单的接口就好，不需要写在txt里面，如果写的话涉及到日志的回滚等操作，很复杂。详细的可以看webserver的日志</p>
<p>那么这里只需要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="comment">// 写日志</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string message)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logLevel_; <span class="comment">//日志级别</span></span><br><span class="line">    <span class="comment">// 构造函数私有化 单例模式</span></span><br><span class="line">    <span class="built_in">Logger</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单例模式，使用static，以及构造函数私有化等操作，其他的还有设置日志级别以及写日志的基础操作就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Logger::setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    logLevel_ = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写日志 [级别日志] time : message</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(std::string message)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志级别</span></span><br><span class="line">    <span class="keyword">switch</span> (logLevel_) &#123;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FATAL:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[FATAL]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[DEBUG]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印时间和message</span></span><br><span class="line">    std::cout &lt;&lt; Timestamp::<span class="built_in">now</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上到这里日志class就已经完成的，但是如果用户使用的话就需要先 instance 初始化 再 setLogLevel 才能 log 打印，会很麻烦，而且logLevel不应该由用户来设置，咱们只需要定义一些宏向外提供接口就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(INFO);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(ERROR);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(FATAL);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">        exit(-1);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG的信息比较多，而且一般不提供给用户使用，因此设置一个MUDEBUG开关来操作一下</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(DEBUG);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>完整的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGGER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义日志的级别 INFO ERROR FATAL DEBUG</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line">    INFO,  <span class="comment">// 普通信息</span></span><br><span class="line">    ERROR, <span class="comment">// 错误信息</span></span><br><span class="line">    FATAL, <span class="comment">// 崩溃信息(无法挽回的一些错误)</span></span><br><span class="line">    DEBUG, <span class="comment">// 调试信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一个日志类 //不需要进行拷贝构造和赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="comment">// 写日志</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string message)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logLevel_; <span class="comment">//日志级别</span></span><br><span class="line">    <span class="comment">// 构造函数私有化 单例模式</span></span><br><span class="line">    <span class="built_in">Logger</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 因为在用户使用的时候不可能初始化日志，设置日志的level等操作，因此定义好提供给用户使用的宏</span></span><br><span class="line"><span class="comment">// LOG_INFO(&quot;%s,%d&quot;,ard1,arg2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(INFO);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(ERROR);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(FATAL);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">        exit(-1);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG的信息比较多，而且一般不提供给用户使用，因此设置一个MUDEBUG开关来操作一下</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MUDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)\</span></span><br><span class="line"><span class="meta">    do \</span></span><br><span class="line"><span class="meta">    &#123;  \</span></span><br><span class="line"><span class="meta">        Logger&amp; logger = Logger::instance();\</span></span><br><span class="line"><span class="meta">        logger.setLogLevel(DEBUG);\</span></span><br><span class="line"><span class="meta">        char buf[1024] = &#123;0&#125;;\</span></span><br><span class="line"><span class="meta">        snprintf(buf,1024,logMsgFormat,##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">        logger.log(buf);\</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_DEBUG(logMsgFormat,...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日志唯一的实例对象</span></span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Logger::setLogLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    logLevel_ = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写日志 [级别日志] time : message</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(std::string message)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印日志级别</span></span><br><span class="line">    <span class="keyword">switch</span> (logLevel_) &#123;</span><br><span class="line">        <span class="keyword">case</span> INFO:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[INFO]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[ERROR]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FATAL:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[FATAL]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEBUG:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[DEBUG]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印时间和message</span></span><br><span class="line">    std::cout &lt;&lt; Timestamp::<span class="built_in">now</span>().<span class="built_in">toString</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="InetAddress-address封装"><a href="#InetAddress-address封装" class="headerlink" title="InetAddress address封装"></a>InetAddress address封装</h1><p>主要是将IP和PORT进行封装，提供一些基础的接口 比如 toIp toIpPort toPort等,这里只做了IPV4的支持</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INETADDRESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INETADDRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装socket地址类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//两个构造</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="type">uint16_t</span> port = <span class="number">0</span>, std::string ip = <span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InetAddress</span><span class="params">(<span class="type">const</span> sockaddr_in &amp;addr)</span>:addr_(addr)&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取IP</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIp</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取IP与Port</span></span><br><span class="line">    <span class="function">std::string <span class="title">toIpPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取port</span></span><br><span class="line">    <span class="function"><span class="type">uint16_t</span> <span class="title">toPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//直接获取sockaddr_in</span></span><br><span class="line">    <span class="function"><span class="type">const</span> sockaddr_in* <span class="title">getSockAddr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> &amp;addr_;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSockAddr</span><span class="params">(<span class="type">const</span> sockaddr_in &amp;addr)</span> </span>&#123; addr_ = addr; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sockaddr_in addr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造</span></span><br><span class="line">InetAddress::<span class="built_in">InetAddress</span>(<span class="type">uint16_t</span> port, std::string ip )&#123;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr_,<span class="built_in">sizeof</span>(addr_)); <span class="comment">//将addr_清零</span></span><br><span class="line">    addr_.sin_family = AF_INET;</span><br><span class="line">    addr_.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    addr_.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取IP</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得把addr_之中的网络字节序传成本地字节序</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 网络地址从二进制形式转换为点分十进制（IPv4）或冒号十六进制（IPv6）的字符串形式</span></span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET,&amp;addr_.sin_addr,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取IP与Port</span></span><br><span class="line"><span class="function">std::string <span class="title">InetAddress::toIpPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET,&amp;addr_.sin_addr,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="type">size_t</span> end = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+end,<span class="string">&quot;:%u&quot;</span>,port);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取port</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">InetAddress::toPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ntohs</span>(addr_.sin_port);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     InetAddress addr(8080);</span></span><br><span class="line"><span class="comment">//     std::cout&lt;&lt;addr.toIpPort()&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h1><p>简单来说，就是将fd封装起来，和poller做配合。核心思想就是自己的事情自己做</p>
<p>fd一般会注册到poller里面，设置一些感兴趣的事件，比如 EPOLLIN  EPOLLOUT 等，然后设置一些回调事件，当发生事件的时候就执行这些回调</p>
<p>要注意的是Channel会注册到poller之中，但是他俩都是由EventLoop来控制的，EventLoop里面有一个poller和多个Channel</p>
<p>Channel的核心思想就是自己的事情自己做，因此会有很多的操作本身的操作，比如注册事件、删除本身等操作，这些事件会会在class类里面提供接口，但是需要EventLoop来调用从而操作poller</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHANNEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHANNEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接前置声明，不包含头文件,直接后面在源文件之中包含头文件，这样的话就可以直接编译成库从而不用提供给用户头文件的信息，防止泄漏更多的东西</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理清楚  EventLoop、Channel、Poller之间的关系   《= Reactor模型上对应 Demultiplex</span></span><br><span class="line"><span class="comment"> * Channel 理解为通道，封装可sockfd和其感兴趣的event 如EPOLLIN  EPOLLOUT</span></span><br><span class="line"><span class="comment"> * 还绑定了poller返回的具体事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//事件回调</span></span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="comment">//只读事件回调</span></span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in">void</span>(Timestamp)&gt;; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Channel</span>(EventLoop *loop,<span class="type">int</span> fd);</span><br><span class="line">    ~<span class="built_in">Channel</span>(); <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd得到poller通知以后，处理事件的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123;</span><br><span class="line">        readCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//读事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        writeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        closeCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//关闭事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span></span>&#123;</span><br><span class="line">        errorCallback_ = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;  <span class="comment">//错误事件回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止当channel被手动remove掉，channel还在执行回调，使用弱智能指针实现</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回绑定的fd</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fd_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回注册的事件</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 revents_ 真正发生的事件，这个接口是放给epoll和eventloop用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span></span>&#123;</span><br><span class="line">        revents_ = revt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fd相应的事件的状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ |= kReadEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//读事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ &amp;= ~kReadEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消读</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ |= kWriteEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//写事件 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ &amp;= ~kWriteEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        events_ = kNoneEvent; </span><br><span class="line">        <span class="built_in">update</span>(); </span><br><span class="line">    &#125; <span class="comment">//取消所有的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回fd当前的事件状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kNoneEvent;</span><br><span class="line">    &#125; <span class="comment">//对所有事件都不敢兴起</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kWriteEvent;</span><br><span class="line">    &#125; <span class="comment">//对写事件感兴趣</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReading</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events_ == kReadEvent;</span><br><span class="line">    &#125; <span class="comment">//对读事件感兴趣</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前的状态 -1：channel未添加到poller中 1 channel已添加到poller中 2 channel从poller中删除</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置状态，这个接口也是放给epoll和eventloop用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_index</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        index_ = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个线程有一个EventLoop，一个EventLoop里面有一个poller，一个poller可以监听很多的channel，因此一个channel需要有一个EventLoop。但是一个EventLoop可以包含很多的channel</span></span><br><span class="line">    <span class="comment">// 这个方法就是返回该channel属于那个EventLoop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">ownerLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除channel用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;  <span class="comment">//没有任何事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;  <span class="comment">//读事件</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent; <span class="comment">//写事件</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// 事件注册</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fd_;    <span class="comment">// fd,poller监听的对象</span></span><br><span class="line">    <span class="type">int</span> events_;      <span class="comment">// 注册fd感兴趣的事件</span></span><br><span class="line">    <span class="type">int</span> revents_;     <span class="comment">// poller返回的具体发生的事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // index表示什么？ 在 EpollPoller之中右这个</span></span><br><span class="line">    <span class="comment">// // channel未添加到poller中</span></span><br><span class="line">    <span class="comment">// const int kNew = -1;          // channel的成员index_ = -1</span></span><br><span class="line">    <span class="comment">// // channel已添加到poller中</span></span><br><span class="line">    <span class="comment">// const int kAdded = 1;</span></span><br><span class="line">    <span class="comment">// // channel从poller中删除</span></span><br><span class="line">    <span class="comment">// const int kDeleted = 2;</span></span><br><span class="line">    <span class="type">int</span> index_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak_ptr 可以转化为 share_ptr </span></span><br><span class="line">    <span class="comment">// 用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">void</span>&gt; tie_;</span><br><span class="line">    <span class="type">bool</span> tied_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Channel通道里面能够获取fd最终发生的事件的revents，所以它负责调用具体事件的回调操作</span></span><br><span class="line">    <span class="comment">// 这些方法需要用户传递过来</span></span><br><span class="line">    ReadEventCallback readCallback_;</span><br><span class="line">    EventCallback writeCallback_;</span><br><span class="line">    EventCallback closeCallback_;</span><br><span class="line">    EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;                   <span class="comment">//没有任何事件</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;  <span class="comment">//读事件</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = EPOLLOUT;           <span class="comment">//写事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop *loop,<span class="type">int</span> fd)</span><br><span class="line">    :<span class="built_in">loop_</span>(loop),<span class="built_in">fd_</span>(fd),<span class="built_in">events_</span>(<span class="number">0</span>),<span class="built_in">revents_</span>(<span class="number">0</span>),<span class="built_in">index_</span>(<span class="number">-1</span>),<span class="built_in">tied_</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Channel::~<span class="built_in">Channel</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel的tie方法什么时候调用过？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当改变channel所表示fd的events事件后，update负责在poller里面更改fd相应的事件epoll_ctl</span></span><br><span class="line"><span class="comment"> * EventLoop =&gt; ChannelList   Poller,  Poller与ChannelList是独立的，因此只能通过EventLoop来操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过channel所属的EventLoop，调用poller的相应方法，注册fd的events事件</span></span><br><span class="line">    loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在channel所属的EventLoop中， 把当前的channel删除掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tied_)&#123;</span><br><span class="line">        <span class="comment">//weak_ptr不控制对象的生命周期，但是，它知道对象是否还活着</span></span><br><span class="line">        <span class="comment">//用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(guard)&#123;</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据poller通知的channel发生的具体事件， 由channel负责调用具体的回调操作</span></span><br><span class="line"><span class="comment">// 根据相应的事件来调用相应的回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;channel handleEvent revents:%d\n&quot;</span>, revents_);</span><br><span class="line">    <span class="comment">// 关闭事件</span></span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) &#123;</span><br><span class="line">            <span class="built_in">closeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) &#123;</span><br><span class="line">            <span class="built_in">errorCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (EPOLLIN | EPOLLPRI)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) &#123;</span><br><span class="line">            <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写事件</span></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) &#123;</span><br><span class="line">            <span class="built_in">writeCallback_</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Poller-封装"><a href="#Poller-封装" class="headerlink" title="Poller 封装"></a>Poller 封装</h1><p>Muduo提供了poll与Epoll，处于复用的考虑，在使用的时候不可能提供固定poll与Epoll，因此要将两者封装一下，使用一个抽象类Poller，poll与Epoll来继承Poller，这样使用的时候直接用Poller来替代即可</p>
<p>抽象类Poller提供一些通用的接口，由poll与Epoll来实现，比如updateChannel removeChannel 等事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> POLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// muduo库中多路事件分发器的核心IO复用模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Poller</span>(EventLoop *loop);    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>() = <span class="keyword">default</span>;<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给所有的IO复用保留统一的接口 select poll epoll</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;   <span class="comment">//updata Channel的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;   <span class="comment">//删除Channel的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断参数channel是否在poller之中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop可以通过该接口获取默认的IO复用的具体实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Poller* <span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// map的key：sockfd  value：sockfd所属的channel通道类型</span></span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>,Channel*&gt;;</span><br><span class="line">    ChannelMap channels_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *ownerLoop_; <span class="comment">//定义Poller所属的事件循环EventLoop</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Poller::<span class="built_in">Poller</span>(EventLoop *loop):<span class="built_in">ownerLoop_</span>(loop)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Poller::hasChannel</span><span class="params">(Channel *channel)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = channels_.<span class="built_in">find</span>(channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">return</span> it != channels_.<span class="built_in">end</span>() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultPoller.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &quot;PollPoller.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EpollPoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想一下为啥在这里实现，不在Poller里面实现,因为PollPoller 与 EPollPoller 继承于Poller,如果在Poller.cc 里面实现的话就得包含PollPoller.h EPollPoller.h 感觉有一些反过来了</span></span><br><span class="line"><span class="function">Poller* <span class="title">Poller::newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getenv</span>(<span class="string">&quot;MUDUO_USE_POLL&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 生成poll的实例 因为没有实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EpollPoller</span>(loop); <span class="comment">// 生成epoll的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EpollPoller 就是真正的 IO多路复用的实现了 poll没有实现</p>
<p>EpollPoller要实现Poller的接口和一些基本的操作，主要是将epoll的一些事情封装起来 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * epoll的使用  </span></span><br><span class="line"><span class="comment"> * epoll_create</span></span><br><span class="line"><span class="comment"> * epoll_ctl   add/mod/del</span></span><br><span class="line"><span class="comment"> * epoll_wait</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpollPoller</span> : <span class="keyword">public</span> Poller &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollPoller</span>(EventLoop* loop);</span><br><span class="line">    ~<span class="built_in">EpollPoller</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写基类Poller的抽象方法</span></span><br><span class="line">    <span class="function">Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充活跃链接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,ChannelList *activeChannels)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 更新channel通道</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation,Channel *channel)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epollfd_;</span><br><span class="line">    EventList events_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EpollPoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// channel未添加到poller中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kNew = <span class="number">-1</span>;          <span class="comment">// channel的成员index_ = -1</span></span><br><span class="line"><span class="comment">// channel已添加到poller中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kAdded = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// channel从poller中删除</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kDeleted = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">EpollPoller::<span class="built_in">EpollPoller</span>(EventLoop* loop)</span><br><span class="line">    :<span class="built_in">Poller</span>(loop),</span><br><span class="line">    <span class="built_in">epollfd_</span>(::<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)),</span><br><span class="line">    <span class="built_in">events_</span>(kInitEventListSize)  <span class="comment">// vector&lt;epoll_event&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">if</span>(epollfd_ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_create error:%d \n&quot;</span>,errno);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EpollPoller::~<span class="built_in">EpollPoller</span>()&#123;</span><br><span class="line">    ::<span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写基类Poller的抽象方法 </span></span><br><span class="line"><span class="comment">// EventLoop 调用 poller.poll，  poller.poll通过将epoll_wait之中发生事件的channel写入activeChannels之中来告知EventLoop那些发生了</span></span><br><span class="line"><span class="function">Timestamp <span class="title">EpollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs,ChannelList *activeChannels)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实际上应该用LOG_DEBUG输出日志更为合理</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd total count:%lu \n&quot;</span>, __FUNCTION__, channels_.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_,&amp;*events_.<span class="built_in">begin</span>(),<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()),timeoutMs);</span><br><span class="line">    <span class="type">int</span> saveErrno = errno;</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numEvents &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%d events happened \n&quot;</span>, numEvents);</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(numEvents,activeChannels);</span><br><span class="line">        <span class="keyword">if</span>(numEvents == events_.<span class="built_in">size</span>())&#123; <span class="comment">//所有的event都发生了，那么可能空间不够，需要扩容</span></span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numEvents == <span class="number">0</span>)&#123; <span class="comment">// 超时链</span></span><br><span class="line">         <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s timeout! \n&quot;</span>, __FUNCTION__);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//外部中断</span></span><br><span class="line">        <span class="keyword">if</span> (saveErrno != EINTR)&#123;</span><br><span class="line">            errno = saveErrno;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EPollPoller::poll() err!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel update remove =&gt; EventLoop updateChannel removeChannel =&gt; Poller updateChannel removeChannel</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *            EventLoop  =&gt;   poller.poll  </span></span><br><span class="line"><span class="comment"> *     ChannelList      Poller</span></span><br><span class="line"><span class="comment"> *                     ChannelMap  &lt;fd, channel*&gt;   epollfd</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::updateChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d events=%d index=%d \n&quot;</span>, __FUNCTION__, channel-&gt;<span class="built_in">fd</span>(), channel-&gt;<span class="built_in">events</span>(), index);</span><br><span class="line">    <span class="comment">// channel还没有注册或者是已经删除掉了（kDeleted的时候Poller里面的ChannelMap里面并没有删除掉,调用removeChannel的时候才会在ChannelMap里面删除掉）</span></span><br><span class="line">    <span class="keyword">if</span>(index == kNew || index == kDeleted)&#123; </span><br><span class="line">        <span class="keyword">if</span>(index == kNew)&#123;</span><br><span class="line">            <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD,channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// channel已经在poller上注册过了</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        <span class="keyword">if</span>(channel-&gt;<span class="built_in">isNoneEvent</span>())&#123; <span class="comment">//对任何事情都不感兴趣了，那就删除</span></span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL,channel);</span><br><span class="line">            channel-&gt;<span class="built_in">set_index</span>(kDeleted);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从poller中删除channel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::removeChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;func=%s =&gt; fd=%d\n&quot;</span>, __FUNCTION__, fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="keyword">if</span>(index == kAdded)&#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL,channel);</span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kNew);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充活跃链接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,ChannelList *activeChannels)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numEvents;i++)&#123;</span><br><span class="line">        Channel* channel = <span class="built_in">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);</span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel);  <span class="comment">// EventLoop就拿到了它的poller给它返回的所有发生事件的channel列表了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新channel通道 epoll_ctl add/mod/del</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EpollPoller::update</span><span class="params">(<span class="type">int</span> operation,Channel *channel)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event,<span class="keyword">sizeof</span> event);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line"></span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">epoll_ctl</span>(epollfd_,operation,fd,&amp;event) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(operation == EPOLL_CTL_DEL)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;epoll_ctl del error:%d\n&quot;</span>, errno);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_ctl add/mod error:%d\n&quot;</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的倒是挺常规的，要注意的是kNew kAdded kDeleted三个状态，EventList 与 ChannelList的管理，activeChannels的管理等操作</p>
<p>还有的是update函数里面event.data.ptr &#x3D; channel;这一行代码，与fillActiveChannels里面的操作相联动</p>
<p>前面已经说了，poller是由EventLoop来管理的，因此Timestamp EpollPoller::poll(int timeoutMs,ChannelList *activeChannels)是由EventLoop来调用的</p>
<p>EventLoop传给Timestamp EpollPoller::poll(int timeoutMs,ChannelList *activeChannels) activeChannels，就会得到相应的channel，后面再由EventLoop调用channel的handleEvent来处理事件就好</p>
<h1 id="EventLoop-Reactor"><a href="#EventLoop-Reactor" class="headerlink" title="EventLoop  Reactor"></a>EventLoop  Reactor</h1><p>上面已经说了EventLoop负责管理一个poller与很多个Channel，这个有点复杂 要注意的是四个函数   void wakeup();  void loop();    void runInLoop(Functor cb);  void queueInLoop(Functor cb);  要不然可能会迷糊，其他的就挺常规的</p>
<p>先看代码，先了解一下其他的函数，这里就不多讲了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CurrentThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 退出事件循环</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Timestamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollReturnTime_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前loop中执行cb</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">    <span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来唤醒loop所在的线程的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断EventLoop对象是否在自己的线程里面</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId_ == CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;         <span class="comment">// wake up</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;  <span class="comment">// 执行回调</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line"></span><br><span class="line">    std::atomic_bool looping_;  <span class="comment">//原子操作</span></span><br><span class="line">    std::atomic_bool quit_;  <span class="comment">//标志退出loop循环</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">pid_t</span> threadId_; <span class="comment">// 记录当前loop所在线程的id</span></span><br><span class="line">    </span><br><span class="line">    Timestamp pollReturnTime_; <span class="comment">// poller返回发生事件的channels的时间点</span></span><br><span class="line">    std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> wakeupFd_;   <span class="comment">// 主要作用，当mainLoop获取一个新用户的channel，通过轮询算法选择一个subloop，通过该成员唤醒subloop处理channel</span></span><br><span class="line">    std::unique_ptr&lt;Channel&gt; wakeupChannel_; <span class="comment">//将wakeupFd_打包成channel</span></span><br><span class="line"></span><br><span class="line">    ChannelList activeChannels_;</span><br><span class="line"></span><br><span class="line">    std::atomic_bool callingPendingFunctors_; <span class="comment">// 标识当前loop是否有需要执行的回调操作</span></span><br><span class="line">    std::vector&lt;Functor&gt; pendingFunctors_;    <span class="comment">// 存储loop需要执行的所有的回调操作</span></span><br><span class="line">    std::mutex mutex_;                        <span class="comment">// 互斥锁，用来保护上面vector容器的线程安全操作</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Poller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止一个线程创建多个EventLoop   thread_local 相当于线程里面的单例模式,看构造函数</span></span><br><span class="line">__thread EventLoop *t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义默认的Poller IO复用接口的超时时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createEventfd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> evtfd = ::<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(evtfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;eventfd error:%d \n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::<span class="built_in">EventLoop</span>() </span><br><span class="line">    : <span class="built_in">looping_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">quit_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">callingPendingFunctors_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">threadId_</span>(CurrentThread::<span class="built_in">tid</span>())</span><br><span class="line">    , <span class="built_in">poller_</span>(Poller::<span class="built_in">newDefaultPoller</span>(<span class="keyword">this</span>))</span><br><span class="line">    , <span class="built_in">wakeupFd_</span>(<span class="built_in">createEventfd</span>())</span><br><span class="line">    , <span class="built_in">wakeupChannel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(<span class="keyword">this</span>, wakeupFd_)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;EventLoop created %p in thread %d \n&quot;</span>, <span class="keyword">this</span>, threadId_);</span><br><span class="line">    <span class="keyword">if</span>(t_loopInThisThread) &#123;</span><br><span class="line">        <span class="comment">// 防止一个线程创建多个EventLoop </span></span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;Another EventLoop %p exists in this thread %d \n&quot;</span>, t_loopInThisThread, threadId_);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置wakeupfd的事件类型以及发生事件后的回调操作</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;EventLoop::handleRead,<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 每一个eventloop都将监听wakeupchannel的EPOLLIN读事件了</span></span><br><span class="line">    <span class="comment">// mainReactor给subReactor发送一个消息，那么subReactor就不阻塞了，起来做事情了</span></span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">enableReading</span>();</span><br><span class="line">&#125;</span><br><span class="line">EventLoop::~<span class="built_in">EventLoop</span>() &#123;</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    wakeupChannel_-&gt;<span class="built_in">remove</span>();</span><br><span class="line">    ::<span class="built_in">close</span>(wakeupFd_);</span><br><span class="line">    t_loopInThisThread = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mainReactor给subReactor发送一个消息，那么subReactor就不阻塞了，起来做事情了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事件循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_)&#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd（mainLoop与channel之间的通信）</span></span><br><span class="line">        <span class="comment">// 正常的client的fd就直接用下面的channel-&gt;handleEvent(pollReturnTime_);来解决了</span></span><br><span class="line">        <span class="comment">// wakeupf基本上用于接收新的连接，由mainLoop注册一些回调cb存储在pendingFunctors_然后再唤醒subloop，由subloop来执行这些回调，这样方便把这些新的连接注册到subloop上  这一操作由doPendingFunctors函数实现</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs,&amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(Channel* channel:activeChannels_)&#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop   mainLoop接收新的连接得到fd，我们用channel打包fd然后分发给subloop来执行一些回调</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作（pendingFunctors_）</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping. \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出事件循环  </span></span><br><span class="line"><span class="comment">// 1.loop在自己的线程中调用quit(这就直接结束了，下次loop函数里面while循环发现quit为true就结束了)  </span></span><br><span class="line"><span class="comment">// 2.在非loop的线程中，调用loop的quit，那么这个loop可能在阻塞 poller_-&gt;poll 这一部，则需要把这个loop先唤醒，这样的话等下一次循环的时候发现quit_为true就结束了，反之不唤醒的话就会一直阻塞在poller_-&gt;poll这一步，如果不发生事件可能永远无法结束 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *              mainLoop</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *                                             no ==================== 生产者-消费者的线程安全的队列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  subLoop1     subLoop2     subLoop3</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    quit_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果是在其它线程中，调用的quit   在一个subloop(woker)中，调用了mainLoop(IO)的quit</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>())&#123;   <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();<span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来唤醒loop所在的线程的  向wakeupfd_写一个数据，wakeupChannel就发生读事件，当前loop线程就会被唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventLoop的方法 =》 Poller的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">updateChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span></span>&#123;</span><br><span class="line">    poller_-&gt;<span class="built_in">removeChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;<span class="built_in">hasChannel</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;  <span class="comment">// 执行回调</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);  <span class="comment">//不直接使用pendingFunctors_执行下面的代码为了防止一边写一边读，交叉持有锁，造成耗费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor &amp;functor: functors)&#123;</span><br><span class="line">        <span class="built_in">functor</span>();  <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是wakeup函数， EventLoop肯定会调用poller_-&gt;poll （也就是epoll_wait），这里肯定会阻塞，但是有一些特殊情况可能需要唤醒这个（这个特殊情况一会再说），因此需要wakeup来实现</p>
<p>我们看到EventLoop里面有一个wakeupFd_的属性，系统会提供一个eventfd函数，这个和socketfd用法差不多也可以用来读和写，将eventfd封装成channel再用poller来监听，这样的话要实现wakeup的话就简单了，只需要注册读事件，然后往wakeupFd_里面写一些东西就好</p>
<p>我们可以看到构造函数里面wakeupChannel_注册了enableReading读事件，setReadCallback设置的回调是EventLoop::handleRea</p>
<p>我们把wakeup与handleRead拿出来看一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wakeup 就是写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleRead 就是读</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">read</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看void loop(); </p>
<p>这个就比较简单了，主要是逻辑，为什么说比较简单，我们看代码就知道</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!quit_)&#123;</span><br><span class="line">        activeChannels_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 监听两类fd   一种是client的fd，一种wakeupfd（mainLoop与channel之间的通信）</span></span><br><span class="line">        <span class="comment">// 正常的client的fd就直接用下面的channel-&gt;handleEvent(pollReturnTime_);来解决了</span></span><br><span class="line">        <span class="comment">// wakeupf基本上用于接收新的连接，由mainLoop注册一些回调cb存储在pendingFunctors_然后再唤醒subloop，由subloop来执行这些回调，这样方便把这些新的连接注册到subloop上  这一操作由doPendingFunctors函数实现</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;<span class="built_in">poll</span>(kPollTimeMs,&amp;activeChannels_);</span><br><span class="line">        <span class="keyword">for</span>(Channel* channel:activeChannels_)&#123;</span><br><span class="line">            <span class="comment">// Poller监听哪些channel发生事件了，然后上报给EventLoop，通知channel处理相应的事件</span></span><br><span class="line">            channel-&gt;<span class="built_in">handleEvent</span>(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行当前EventLoop事件循环需要处理的回调操作</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * IO线程 mainLoop accept fd《=channel subloop   mainLoop接收新的连接得到fd，我们用channel打包fd然后分发给subloop来执行一些回调</span></span><br><span class="line"><span class="comment">         * mainLoop 事先注册一个回调cb（需要subloop来执行）    wakeup subloop后，执行下面的方法，执行之前mainloop注册的cb操作（pendingFunctors_）</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="built_in">doPendingFunctors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;EventLoop %p stop looping. \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上就几行，调用poller_-&gt;poll(kPollTimeMs,&amp;activeChannels_)获取那些channel发生事件了，然后回调事件channel可以自己做，这里做一下调用就行，其他的就是doPendingFunctors</p>
<p>doPendingFunctors就涉及到void runInLoop(Functor cb);  void queueInLoop(Functor cb); 这两个函数了</p>
<p>runInLoop比较好理解，就是当前loop所在的线程执行的函数，这样的话就直接执行就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在当前loop中执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>())&#123;   <span class="comment">// 在当前的loop线程中，执行cb</span></span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">// 在非当前loop线程中执行cb , 就需要唤醒loop所在线程，执行cb</span></span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在非当前loop线程中执行cb的时候就需要调用queueInLoop函数了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把cb放入队列中，唤醒loop所在的线程，执行cb</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒相应的，需要执行上面回调操作的loop的线程了</span></span><br><span class="line">    <span class="comment">// || callingPendingFunctors_的意思是：当前loop正在执行回调，但是loop又有了新的回调</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();<span class="comment">// 唤醒loop所在线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queueInLoop会把cb放置到pendingFunctors_里面，然后唤醒当前loop（原来的loop可能正在阻塞的状态），然后loop就会调用doPendingFunctors</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;  <span class="comment">// 执行回调</span></span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.<span class="built_in">swap</span>(pendingFunctors_);  <span class="comment">//不直接使用pendingFunctors_执行下面的代码为了防止一边写一边读，交叉持有锁，造成耗费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> Functor &amp;functor: functors)&#123;</span><br><span class="line">        <span class="built_in">functor</span>();  <span class="comment">// 执行当前loop需要执行的回调操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐一执行pendingFunctors_里面的函数</p>
<h1 id="Thread-EventLoopThread-EventLoopThreadPool"><a href="#Thread-EventLoopThread-EventLoopThreadPool" class="headerlink" title="Thread EventLoopThread EventLoopThreadPool"></a>Thread EventLoopThread EventLoopThreadPool</h1><p>Thread是对<thread>库的封装，其他没有特殊的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc,<span class="type">const</span> std::string &amp;name = std::string())</span></span>;</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> started_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">tid</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tid_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name_; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> numCreated_; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">bool</span> joined_;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_;</span><br><span class="line">    <span class="type">pid_t</span> tid_;</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">static</span> std::atomic_int numCreated_;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CurrentThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic_int <span class="title">Thread::numCreated_</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func,<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">joined_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">tid_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">func_</span>(std::<span class="built_in">move</span>(func))</span><br><span class="line">    , <span class="built_in">name_</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setDefaultName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~<span class="built_in">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_ &amp;&amp; !joined_)&#123;</span><br><span class="line">        thread_-&gt;<span class="built_in">detach</span>();    <span class="comment">// thread类提供的设置分离线程的方法 detach之后等到线程结束之后会自动join</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::setDefaultName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = ++ numCreated_;</span><br><span class="line">    <span class="keyword">if</span>(name_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;Thread%d&quot;</span>, num);</span><br><span class="line">        name_ = buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span>&#123;    <span class="comment">// 一个Thread对象，记录的就是一个新线程的详细信息</span></span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem,<span class="literal">false</span>,<span class="number">0</span>);  <span class="comment">//信号量为0</span></span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    thread_ = std::<span class="built_in">shared_ptr</span>&lt;std::thread&gt;(<span class="keyword">new</span> std::<span class="built_in">thread</span>([&amp;]()&#123;</span><br><span class="line">        <span class="comment">// 获取线程的tid值</span></span><br><span class="line">        tid_ = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem); <span class="comment">//信号量+1</span></span><br><span class="line">        <span class="comment">// 开启一个新线程，专门执行该线程函数</span></span><br><span class="line">        <span class="built_in">func_</span>(); </span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">// 这里必须等待获取上面新创建的线程的tid值,因为有时候会使用tid是否大于0来判断是否创建成功</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem); <span class="comment">//信号量-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span></span>&#123;</span><br><span class="line">    joined_ = <span class="literal">true</span>;</span><br><span class="line">    thread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们看，我们用的是std::shared_ptr<thread> thread_; 来存储的，正常的话如果我们直接申请一个thread，那么它就直接start了，这样的话我们就可以通过调用void Thread::start()来开始了</p>
<p>EventLoopThread 将Eventloop和Thread结合起来，简单来说就是创建线程，循环里面是一个loop，这就muduo所追求的 one loop per thread</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOPTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOPTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThread</span>:noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb = <span class="built_in">ThreadInitCallback</span>(),<span class="type">const</span> std::string &amp;name = std::<span class="built_in">string</span>());</span><br><span class="line">    ~<span class="built_in">EventLoopThread</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">EventLoop* <span class="title">startLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    EventLoop* loop_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exiting_;</span><br><span class="line">    Thread thread_;</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">    ThreadInitCallback callback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">exiting_</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">thread_</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name)</span><br><span class="line">        , <span class="built_in">mutex_</span>()</span><br><span class="line">        , <span class="built_in">cond_</span>()</span><br><span class="line">        , <span class="built_in">callback_</span>(cb) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>()&#123;</span><br><span class="line">    exiting_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop_ != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        loop_-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        thread_.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread_.<span class="built_in">start</span>();  <span class="comment">// 启动底层的新线程 执行的是threadFunc</span></span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(loop_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cond_.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个方法，实在单独的新线程里面运行的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop loop; <span class="comment">// 创建一个独立的eventloop，和上面的线程是一一对应的，one loop per thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(callback_)&#123;</span><br><span class="line">        <span class="built_in">callback_</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// EventLoop loop  =&gt; Poller.poll</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventLoopThreadPool 声明多个EventLoop 以供选择，主要是setThreadNum函数以及 EventLoop* getNextLoop();方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENTLOOPTHREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTLOOPTHREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThread</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThreadPool</span>: noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">EventLoopThreadPool</span>(EventLoop *baseLoop, <span class="type">const</span> std::string &amp;nameArg);</span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span> </span>&#123;</span><br><span class="line">        numThreads_ = numThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果工作在多线程中，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> started_; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    EventLoop *baseLoop_; <span class="comment">// EventLoop loop;  </span></span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">bool</span> started_;</span><br><span class="line">    <span class="type">int</span> numThreads_;</span><br><span class="line">    <span class="type">int</span> next_;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;</span><br><span class="line">    std::vector&lt;EventLoop*&gt; loops_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop *baseLoop, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">baseLoop_</span>(baseLoop)</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">started_</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">numThreads_</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">next_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[name_.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, name_.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        EventLoopThread *t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb, buf);</span><br><span class="line">        threads_.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>()); <span class="comment">// 底层创建线程，绑定一个新的EventLoop，并返回该loop的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个服务端只有一个线程，运行着baseloop</span></span><br><span class="line">    <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果工作在多线程中，baseLoop_默认以轮询的方式分配channel给subloop</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop *loop = baseLoop_;</span><br><span class="line">    <span class="keyword">if</span> (!loops_.<span class="built_in">empty</span>()) &#123; <span class="comment">// 通过轮询获取下一个处理事件的loop</span></span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        <span class="keyword">if</span> (next_ &gt;= loops_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            next_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;EventLoop*&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loops_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;EventLoop*&gt;(<span class="number">1</span>, baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loops_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看start的时候通过numThreads_来初始化EventLoopThread的数量numThreads_是subReactor的数量，这个和原始的muduo不一样，原始的muduo是baseloop + subReactor的数量</p>
<p>最为主要的是通过轮询的方法来选择subReactor（EventLoop）看EventLoop* EventLoopThreadPool::getNextLoop()，如果loops_为空的话就只会return baseLoop_了</p>
<h1 id="Socket-Socket的封装"><a href="#Socket-Socket的封装" class="headerlink" title="Socket Socket的封装"></a>Socket Socket的封装</h1><p>前面我们封装了IP 与 PORT (InetAddress) 这里的Socket是对 socket fd的封装 也就是 初始化 bind listen accept</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOCKET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装socket fd</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">        : sockfd_(sockfd)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sockfd_; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localaddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(InetAddress *peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//一些选项</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReusePort</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sockfd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Socket::~<span class="built_in">Socket</span>()&#123;</span><br><span class="line">    <span class="built_in">close</span>(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localaddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">bind</span>(sockfd_,(sockaddr*)localaddr.<span class="built_in">getSockAddr</span>(),<span class="built_in">sizeof</span>(sockaddr_in)))&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;bind sockfd:%d fail \n&quot;</span>, sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">listen</span>(sockfd_,<span class="number">1024</span>))&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;listen sockfd:%d fail \n&quot;</span>, sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket::accept</span><span class="params">(InetAddress *peeraddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. accept函数的参数不合法</span></span><br><span class="line"><span class="comment">     * 2. 对返回的connfd没有设置非阻塞</span></span><br><span class="line"><span class="comment">     * Reactor模型 one loop per thread</span></span><br><span class="line"><span class="comment">     * poller + non-blocking IO</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span> addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr,<span class="keyword">sizeof</span> addr);</span><br><span class="line">    <span class="type">int</span> connfd = ::<span class="built_in">accept4</span>(sockfd_,(sockaddr*)&amp;addr,&amp;len,SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">    <span class="comment">//把连接的addr存储在peeraddr之中，方便返回</span></span><br><span class="line">    <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        peeraddr-&gt;<span class="built_in">setSockAddr</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">shutdown</span>(sockfd_,SHUT_WR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shutdownWrite error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, IPPROTO_TCP, TCP_NODELAY, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setReusePort</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(sockfd_, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Acceptor-新连接接收"><a href="#Acceptor-新连接接收" class="headerlink" title="Acceptor 新连接接收"></a>Acceptor 新连接接收</h1><p>Acceptor会工作在mainLoop之中，负责接受新的连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//新连接的回调</span></span><br><span class="line">    <span class="keyword">using</span> NewConnectionCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport);</span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123;</span><br><span class="line">        newConnectionCallback_ = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> listenning_; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里不是真正的Read，acceptChannel_会注册到mainloop上，当有新连接来的时候就会唤醒来执行回调，这也是Read事件，这个里面调用的是newConnectionCallback_</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    EventLoop *loop_; <span class="comment">// Acceptor用的就是用户定义的那个baseLoop，也称作mainLoop</span></span><br><span class="line">    Socket acceptSocket_;</span><br><span class="line">    Channel acceptChannel_;</span><br><span class="line">    NewConnectionCallback newConnectionCallback_;</span><br><span class="line">    <span class="type">bool</span> listenning_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以看到acceptSocket_ 就值服务器的 socket(ip 与 port) 客户端连接的时候就是连接这个</p>
<p>还可以看到 Channel acceptChannel_; 这就是用来处理新的连接的，acceptChannel_会监听读事件并且注册到mainLoop之中（有新连接的时候会相应）</p>
<p>绑定的回调事件为handleRead 其实是 NewConnectionCallback</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">createNonblocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d listen socket create err:%d \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop)</span><br><span class="line">    , <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">    , <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>())</span><br><span class="line">    , <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// TcpServer::start() Acceptor.listen  有新用户的连接，要执行一个回调（connfd=》channel=》subloop）</span></span><br><span class="line">    <span class="comment">// baseLoop =&gt; acceptChannel_(listenfd) =&gt; </span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>(); <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:%s:%d accept err:%d \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:%s:%d sockfd reached limit! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是handleRead函数，直接看 通过peerAddr接收连接sockaddr_in，然后connfd接收socket fd,简单的判断一下传递给newConnectionCallback_就行了，这个由调用方自己设置怎么处理，Acceptor不用管，这不是他应该处理的逻辑</p>
<h1 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h1><p>和webserver的缓冲区一样，准确来说，webserver的缓冲区是仿照这个来写的，这里就不做多解释了webserver里面已经解释的很清楚了</p>
<p>|————-A———|————B———–|———–C————|</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络库底层的缓冲器类型定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class="line"><span class="function">        : buffer_(kCheapPrepend + initialSize)</span></span><br><span class="line"><span class="function">        , readerIndex_(kCheapPrepend)</span></span><br><span class="line"><span class="function">        , writerIndex_(kCheapPrepend)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读空间的大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可写空间大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后被隐藏能源</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onMessage string &lt;- Buffer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>()) &#123;</span><br><span class="line">            readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// len == readableBytes() </span></span><br><span class="line">            <span class="built_in">retrieveAll</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readerIndex_ = writerIndex_ = kCheapPrepend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把onMessage函数上报的Buffer数据，转成string类型的数据返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">        <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer_.size() - writerIndex_    len</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">            <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把[data, data+len]内存上的数据，添加到writable缓冲区当中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">        std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">        writerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">beginWrite</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从fd上读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line">    <span class="comment">// 通过fd发送数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// it.operator*()</span></span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();  <span class="comment">// vector底层数组首元素的地址，也就是数组的起始地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">            buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">            std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                    <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                    <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">            readerIndex_ = kCheapPrepend;</span><br><span class="line">            writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> readerIndex_;</span><br><span class="line">    <span class="type">size_t</span> writerIndex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从fd上读取数据  Poller工作在LT模式</span></span><br><span class="line"><span class="comment"> * Buffer缓冲区是有大小的！ 但是从fd上读数据的时候，却不知道tcp数据最终的大小</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); <span class="comment">// 这是Buffer底层缓冲区剩余的可写空间大小</span></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) &#123;<span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// extrabuf里面也写入了数据 </span></span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="TcpConnection-连接管理"><a href="#TcpConnection-连接管理" class="headerlink" title="TcpConnection 连接管理"></a>TcpConnection 连接管理</h1><p>主要负责管理TCP的连接，比如新连接的建立（connectionCallback_）这个回调由调用者设置，读数据（handleRead messageCallback_） 写数据（send handleWrite），其他的函数都是一些辅助性的，很好理解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Callbacks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TcpServer =&gt; Acceptor =&gt; 有一个新用户连接，通过accept函数拿到connfd</span></span><br><span class="line"><span class="comment"> * =》 TcpConnection 设置回调 =》 Channel =》 Poller =》 Channel的回调操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span> : noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> std::string &amp;name,</span><br><span class="line">                <span class="type">int</span> sockfd,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; peerAddr);</span><br><span class="line">    ~<span class="built_in">TcpConnection</span>(); <span class="comment">//析构</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getLoop</span></span><br><span class="line">    <span class="function">EventLoop* <span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getname</span></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get localAddress</span></span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">localAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localAddr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get peerAddress</span></span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">peerAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peerAddr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是已连接状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state_ == kConnected;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="type">const</span> HighWaterMarkCallback&amp; cb, <span class="type">size_t</span> highWaterMark)</span></span></span><br><span class="line"><span class="function">    </span>&#123; highWaterMarkCallback_ = cb; highWaterMark_ = highWaterMark; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> CloseCallback&amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123; closeCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接建立</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 连接销毁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectDestroyed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">StateE</span>&#123;kDisconnected,kConnecting,kConnected,kDisconnecting&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(StateE state)</span></span>&#123;</span><br><span class="line">        state_ = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data,<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// 这里绝对不是baseLoop， 因为TcpConnection都是在subLoop里面管理的</span></span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line">    std::atomic_int state_;</span><br><span class="line">    <span class="type">bool</span> reading_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里和Acceptor类似   Acceptor=》mainLoop    TcpConenction=》subLoop</span></span><br><span class="line">    std::unique_ptr&lt;Socket&gt; socket_;</span><br><span class="line">    std::unique_ptr&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> InetAddress localAddr_;</span><br><span class="line">    <span class="type">const</span> InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_; <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;       <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_; <span class="comment">// 消息发送完成以后的回调</span></span><br><span class="line">    HighWaterMarkCallback highWaterMarkCallback_; <span class="comment">// 消息阈值的回调</span></span><br><span class="line">    CloseCallback closeCallback_; <span class="comment">//关闭回调</span></span><br><span class="line">    <span class="type">size_t</span> highWaterMark_;        <span class="comment">//消息阈值（流量控制）</span></span><br><span class="line"></span><br><span class="line">    Buffer inputBuffer_;  <span class="comment">// 接收数据的缓冲区</span></span><br><span class="line">    Buffer outputBuffer_; <span class="comment">// 发送数据的缓冲区</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop *loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loop == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d TcpConnection Loop is null! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop, </span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg, </span><br><span class="line">                <span class="type">int</span> sockfd,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">    : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">    , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">    , <span class="built_in">state_</span>(kConnecting)</span><br><span class="line">    , <span class="built_in">reading_</span>(<span class="literal">true</span>)</span><br><span class="line">    , <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd))</span><br><span class="line">    , <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd))</span><br><span class="line">    , <span class="built_in">localAddr_</span>(localAddr)</span><br><span class="line">    , <span class="built_in">peerAddr_</span>(peerAddr)</span><br><span class="line">    , <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">// 64M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下面给channel设置相应的回调函数，poller给channel通知感兴趣的事件发生了，channel会回调相应的操作函数</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>, name_.<span class="built_in">c_str</span>(), sockfd);</span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>()&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::dtor[%s] at fd=%d state=%d \n&quot;</span>, </span><br><span class="line">        name_.<span class="built_in">c_str</span>(), channel_-&gt;<span class="built_in">fd</span>(), (<span class="type">int</span>)state_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(loop_-&gt;<span class="built_in">isInLoopThread</span>())&#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(),buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(</span><br><span class="line">                &amp;TcpConnection::sendInLoop,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                buf.<span class="built_in">c_str</span>(),</span><br><span class="line">                buf.<span class="built_in">size</span>()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据  应用写的快， 而内核发送数据慢， 需要把待发送数据写入缓冲区， 而且设置了水位回调</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;        <span class="comment">// 已发送的数据量</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len;    <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;   <span class="comment">// 是否发生了错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前调用过该connection的shutdown，不能再进行发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected, give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel_第一次开始写数据（这个时候还没有注册写事件），而且缓冲区没有待发送数据（刚开始数据来的时候就直接发，还没有往缓冲区里面写数据，如果第一次发不完再往缓冲区里面写）</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);  <span class="comment">// 直接开始写</span></span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)&#123; <span class="comment">//写成功</span></span><br><span class="line">            remaining = len - nwrote;  <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)&#123;  <span class="comment">//写完了看看是不是需要调用writeCompleteCallback_回调</span></span><br><span class="line">                <span class="comment">// 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)&#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class="comment">// SIGPIPE  RESET</span></span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write，并没有把数据全部发送出去，剩余的数据需要保存到缓冲区当中，然后给channel</span></span><br><span class="line">    <span class="comment">// 注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用writeCallback_回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite方法，把发送缓冲区中的数据全部发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 调用highWaterMarkCallback</span></span><br><span class="line">        <span class="keyword">if</span>(oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldLen+remaining)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把剩余的数据都写到outputBuffer_之中，然后注册写事件，后面poller会通知写事件，然后调用TcpConnection::handleWrite的回调</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line">        <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">// 这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop,<span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;   <span class="comment">// 说明outputBuffer中的数据已经全部发送完成</span></span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>(); <span class="comment">// 关闭写端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接建立</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// 向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">// 新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)&#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>(); <span class="comment">// 把channel的所有感兴趣的事件，从poller中del掉</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>(); <span class="comment">// 把channel从poller中删除掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)&#123;</span><br><span class="line">                    <span class="comment">// 唤醒loop_对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poller =&gt; channel::closeCallback =&gt; TcpConnection::handleClose</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpConnection::handleClose fd=%d state=%d \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>(), (<span class="type">int</span>)state_);</span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(connPtr); <span class="comment">// 执行连接关闭的回调</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr); <span class="comment">// 关闭连接的回调  执行的是TcpServer::removeConnection回调方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> optval;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockopt</span>(channel_-&gt;<span class="built_in">fd</span>(), SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = optval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleError name:%s - SO_ERROR:%d \n&quot;</span>, name_.<span class="built_in">c_str</span>(), err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读数据 handleRead 主要是调用messageCallback_还有一些错误处理 messageCallback_ 也是调用者（TcpServer）设置的(其实也是用户设置的)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写数据 send handleWrite 基本思路：send会先发送一份，如果数据比较少，一次可以写完的话就直接写，不用直接调用buffer等操作，但是如果没发送完就把剩余的写进buf里面，然后注册写事件，这样的话会触发poller通知，从而触发channel的handleWrite回调，从而把剩下的数据给发送除去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;        <span class="comment">// 已发送的数据量</span></span><br><span class="line">    <span class="type">size_t</span> remaining = len;    <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;   <span class="comment">// 是否发生了错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前调用过该connection的shutdown，不能再进行发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected, give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel_第一次开始写数据（这个时候还没有注册写事件），而且缓冲区没有待发送数据（刚开始数据来的时候就直接发，还没有往缓冲区里面写数据，如果第一次发不完再往缓冲区里面写）</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);  <span class="comment">// 直接开始写</span></span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)&#123; <span class="comment">//写成功</span></span><br><span class="line">            remaining = len - nwrote;  <span class="comment">// 剩余还有多少没发</span></span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)&#123;  <span class="comment">//写完了看看是不是需要调用writeCompleteCallback_回调</span></span><br><span class="line">                <span class="comment">// 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)&#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) &#123;<span class="comment">// SIGPIPE  RESET</span></span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明当前这一次write，并没有把数据全部发送出去，剩余的数据需要保存到缓冲区当中，然后给channel</span></span><br><span class="line">    <span class="comment">// 注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用writeCallback_回调方法</span></span><br><span class="line">    <span class="comment">// 也就是调用TcpConnection::handleWrite方法，把发送缓冲区中的数据全部发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 调用highWaterMarkCallback</span></span><br><span class="line">        <span class="keyword">if</span>(oldLen + remaining &gt;= highWaterMark_ &amp;&amp; oldLen &lt; highWaterMark_ &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldLen+remaining)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把剩余的数据都写到outputBuffer_之中，然后注册写事件，后面poller会通知写事件，然后调用TcpConnection::handleWrite的回调</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="type">char</span>*)data + nwrote,remaining);</span><br><span class="line">        <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>(); <span class="comment">// 这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriting</span>())&#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)&#123;</span><br><span class="line">                    <span class="comment">// 唤醒loop_对应的thread线程，执行回调</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnected)&#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleWrite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd=%d is down, no more writing \n&quot;</span>, channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他的就是关闭连接 错误处理等操作了，需要注意的是里面针对channel等操作</p>
<h1 id="TcpServer-模块连接"><a href="#TcpServer-模块连接" class="headerlink" title="TcpServer 模块连接"></a>TcpServer 模块连接</h1><p>所有一切的基础功能，上面的模块已经完成了，在TcpServer里面主要是将这些基础的功能连接在一起</p>
<p>比如：Adaptor如何分配connection给subReactor，newConnection的回调是什么（connectionCallback_ messageCallback_ 交给用户自己来设置了）等</p>
<p>其他的还有一些像EventLoopThreadPool的setThreadNum，还有removeConnection等简单操作了，这些操作一般就是直接调用写好模块的函数再加一些简单的逻辑就好</p>
<p>TcpServer:</p>
<ul>
<li><p>有一个baseLoop（loop_） 是mainLoop 负责分发任务，需要用户自己定义，然后在TcpServer初始化的时候传给TcpServer</p>
</li>
<li><p>有一个EventLoopThreadPool，根据初始化的numThreads的数量初始化subLoop的数量，负责处理新连接以外的各种事物</p>
</li>
<li><p>有一个Acceptor，负责新连接，注册到baseLoop里面的poller，监听读事件，设置TcpServer::newConnection的回调，也就是说，当有新连接的时候就会触发读事件从而通知Acceptor里面的channel执行回调（newConnection）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户使用muduo编写服务器程序</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Acceptor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;InetAddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EventLoopThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Callbacks.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外的服务器编程使用的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;;</span><br><span class="line">    <span class="comment">// 端口复用开关</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Option</span> &#123;</span><br><span class="line">        kNoReusePort,</span><br><span class="line">        kReusePort,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option = kNoReusePort);</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadInitcallback</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        threadInitCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        connectionCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        messageCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; </span><br><span class="line">        writeCompleteCallback_ = cb; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置底层subloop的个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启服务器监听</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ConnectionMap = std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; <span class="comment">// baseLoop 用户定义的loop</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string ipPort_;</span><br><span class="line">    <span class="type">const</span> std::string name_;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Acceptor&gt; acceptor_;              <span class="comment">// 运行在mainLoop，任务就是监听新连接事件</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; <span class="comment">// one loop per thread</span></span><br><span class="line"></span><br><span class="line">    ConnectionCallback connectionCallback_;       <span class="comment">// 有新连接时的回调</span></span><br><span class="line">    MessageCallback messageCallback_;             <span class="comment">// 有读写消息时的回调</span></span><br><span class="line">    WriteCompleteCallback writeCompleteCallback_; <span class="comment">// 消息发送完成以后的回调</span></span><br><span class="line"></span><br><span class="line">    ThreadInitCallback threadInitCallback_; <span class="comment">// loop线程初始化的回调</span></span><br><span class="line"></span><br><span class="line">    std::atomic_int started_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextConnId_;</span><br><span class="line">    ConnectionMap connections_; <span class="comment">// 保存所有的连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpConnection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查loop是否是nullptr</span></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop *loop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainLoop is null! \n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有先用户连接时，会执行TcpServer::newConnection回调</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item:connections_)&#123;</span><br><span class="line">        <span class="comment">// 这个局部的shared_ptr智能指针对象，出右括号，可以自动释放new出来的TcpConnection对象资源了</span></span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁连接</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置底层subloop的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>&#123;</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启服务器监听   loop.loop()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>)&#123; <span class="comment">// 防止一个TcpServer对象被start多次</span></span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen,acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个新的客户端的连接，acceptor会执行这个回调操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法，选择一个subLoop，来管理channel</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd，创建TcpConnection连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    <span class="comment">// 下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调   conn-&gt;shutDown()</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s\n&quot;</span>, </span><br><span class="line">        name_.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed,conn)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接来看newConnection这一关键函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一个新的客户端的连接，acceptor会执行这个回调操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法，选择一个subLoop，来管理channel</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">    name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本机的ip地址和端口信息</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local,<span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd，创建TcpConnection连接对象</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    <span class="comment">// 下面的回调都是用户设置给TcpServer=&gt;TcpConnection=&gt;Channel=&gt;Poller=&gt;notify channel调用回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调   conn-&gt;shutDown()</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 直接调用TcpConnection::connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接通过EventLoopThreadPool的轮询算法选择一个subReactor（ioLoop） 然后初始化一些这个新连接的一些信息，后面再通过ioLoop直接调用TcpConnection的connectEstablished函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// 向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">// 新连接建立，执行回调</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听新连接的读事件，当有信息发过来，有可读信息的时候，就会触发channel_里面读的回调从而调用回调函数，也就是用户设置的messageCallback</p>
<p>其他的到没有啥需要特别说明的了，针对启动一切的start函数的话，就直接调用地层模块的启动就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听   loop.loop()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(started_++ == <span class="number">0</span>)&#123; <span class="comment">// 防止一个TcpServer对象被start多次</span></span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen,acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话我们就理清楚了，留给用户需要做的就是，setConnectionCallback（可选） setMessageCallback（必须） setThreadNum（不做的话就只有mainbReactor在工作了，非常不好）</p>
<h1 id="编译成库添加环境变量路径"><a href="#编译成库添加环境变量路径" class="headerlink" title="编译成库添加环境变量路径"></a>编译成库添加环境变量路径</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">&lt;!-- CMakeLists.txt --&gt;</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">project</span>(mymuduo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake =&gt; makefile   make</span></span><br><span class="line"><span class="comment"># mymuduo最终编译成so动态库，设置动态库的路径，放在根目录的lib文件夹下面</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 设置调试信息 以及 启动C++11语言标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -std=c++11 -fPIC&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参与编译的源代码文件 </span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment"># 编译生成动态库mymuduo</span></span><br><span class="line"><span class="keyword">add_library</span>(mymuduo SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有build目录，创建该目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d `<span class="built_in">pwd</span>`/build ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> `<span class="built_in">pwd</span>`/build</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf `<span class="built_in">pwd</span>`/build/*</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">pwd</span>`/build &amp;&amp;</span><br><span class="line">    cmake .. &amp;&amp;</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到项目根目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把头文件拷贝到 /usr/include/mymuduo  so库拷贝到 /usr/lib    PATH</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /usr/include/mymuduo ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">mkdir</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> header <span class="keyword">in</span> `<span class="built_in">ls</span> *.h`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cp</span> <span class="variable">$header</span> /usr/include/mymuduo</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> `<span class="built_in">pwd</span>`/lib/libmymuduo.so /usr/lib</span><br><span class="line"></span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mymuduo/Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">            <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">            <span class="type">const</span> std::string &amp;name)</span><br><span class="line">        : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        server_.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接建立或者断开的回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection UP : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connection DOWN : %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                Buffer *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                Timestamp time)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        std::string msg = buf-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 写端   EPOLLHUP =》 closeCallback_</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="number">8000</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;EchoServer-01&quot;</span>)</span></span>; <span class="comment">// Acceptor non-blocking listenfd  create bind </span></span><br><span class="line">    server.<span class="built_in">start</span>(); <span class="comment">// listen  loopthread  listenfd =&gt; acceptChannel =&gt; mainLoop =&gt;</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">// 启动mainLoop的底层Poller</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testserver :</span></span><br><span class="line"><span class="comment">// 	g++ -o testserver testserver.cc -lmymuduo -lpthread -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clean :</span></span><br><span class="line"><span class="comment">// 	rm -f testserver</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试： telnet 127.0.0.1 8000</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张振强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/17/muduo/">http://example.com/2025/07/17/muduo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">张振强的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img class="cover" src="/img/load4.gif" data-original="/img/cover/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基于IPV4的流媒体广播</div></div><div class="info-2"><div class="info-item-1">基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃） 运行起来原项目git：https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4 环境: Ubuntu 20.04...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/13/ThreadPool/" title="ThreadPool"><img class="cover" src="/img/load4.gif" data-original="/img/cover/4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">ThreadPool</div></div><div class="info-2"><div class="info-item-1">线程池项目基本概念线程池的概念： 线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。 说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程 那么我们就可以想到一个线程池的最基础的构造 变量：  一个vector 用来存储构造好的线程 一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 ) mutex  有了queue自然得考虑到互斥的问题 condition_variable 条件变量 同mutex理 flag   停止标识  函数：  首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数) 其次得有线程的释放join 的函数  （此处可以使用类的析构函数） 还有得有添加任务的函数  ThreadPool声明通过前面描述来声明一下CLASS class ThreadPool&#123;private:    std::vector&lt;std::thread&gt; workers;        // 工作线程集合   ...</div></div></div></a><a class="pagination-related" href="/2025/04/15/chatRoom/" title="chatRoom"><img class="cover" src="/img/load4.gif" data-original="/img/cover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">chatRoom</div></div><div class="info-2"><div class="info-item-1">chatRoom 项目git:https://github.com/zqzhang2023/zzqStudy 简单介绍：socket的简单应用，简单来说，就是一个服务端：server 许多个客户端：client1 client2 client3 client4… 现在要把这么多客户端拉到一个聊天室里面，实现群聊通信 实现方式：其实思想很简单，就是 client_i 向 server发送消息，然后server接收到消息之后，把消息转发给除却 client_i 之外的所有的 客户 这里主要学习 I&#x2F;O多路复用技术 之前学习的基础的 socket 是客户端 服务器 一对一的，现在需要服务器接收多个客户端的连接，因此需要用到 I&#x2F;O多路复用技术 I&#x2F;O多路复用技术为什么使用socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。 有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程 而且每一次切换线程...</div></div></div></a><a class="pagination-related" href="/2025/04/13/tinyhttpd/" title="Tinyhttpd"><img class="cover" src="/img/load4.gif" data-original="/img/cover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">Tinyhttpd</div></div><div class="info-2"><div class="info-item-1">tinyhttpd 项目写在前面：这个项目是  J. David 大佬 在1999年做出来的，虽然很老旧, 而且手打一遍之后也感觉有些地方可能不适合这么写，但是做完这个项目之后学到的东西有很多很多，如果大家有时间的话，不妨跟着做一做，相信一定会有很大的收获 膜拜大佬！！！ GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 我这边加上注释的代码： 运行起来做之前需要先确定自己的环境能够正常把项目运行起来，要不然做的过程之中不知道是自己代码的问题还是环境的问题 我用的Linux ubuntu 提前安装了perl 地址在 &#x2F;usr&#x2F;bin&#x2F;perl(这个可以通过 which perl 命令得到) GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 1.克隆下来，解压 这个不必对多说 2.执行make命令  会生成 httpd 与 client (会有一些警告，不必在意)  3.执行httpd(.&#x2F;httpd)  这个时候浏览器输入...</div></div></div></a><a class="pagination-related" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img class="cover" src="/img/load4.gif" data-original="/img/cover/5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">tinyWebServer</div></div><div class="info-2"><div class="info-item-1">tinyWebServer 项目写在前面： 学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。 刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急，可以提前了解一下项目的知识再重新来做一下。 于是就先做了三个小项目，每个项目都挺经典的，而且项目的代码量也很小。  线程池的项目：(主要学习线程池的概念和用法) 项目介绍：https://blog.zqzhang2025.com/2025/04/13/ThreadPool/ git链接：https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool   tinyhttpd...</div></div></div></a><a class="pagination-related" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img class="cover" src="/img/load4.gif" data-original="/img/cover/6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">ffmpeg</div></div><div class="info-2"><div class="info-item-1">C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++...</div></div></div></a><a class="pagination-related" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img class="cover" src="/img/load4.gif" data-original="/img/cover/1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-07</div><div class="info-item-2">基于IPV4的流媒体广播</div></div><div class="info-2"><div class="info-item-1">基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃） 运行起来原项目git：https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4 环境: Ubuntu 20.04...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张振强</div><div class="author-info-description">咱们都是最棒的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zqzhang2023"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zqzhang2023" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_45769058" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1611379529&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:bzzhenqiang@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Muduo-%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">C++ Muduo 库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#noncopyable-%E7%A6%81%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.</span> <span class="toc-text">noncopyable 禁止拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Timestamp-%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">Timestamp 时间类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Logger-%E6%97%A5%E5%BF%97"><span class="toc-number">4.</span> <span class="toc-text">Logger 日志</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InetAddress-address%E5%B0%81%E8%A3%85"><span class="toc-number">5.</span> <span class="toc-text">InetAddress address封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-%E9%80%9A%E9%81%93"><span class="toc-number">6.</span> <span class="toc-text">Channel 通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poller-%E5%B0%81%E8%A3%85"><span class="toc-number">7.</span> <span class="toc-text">Poller 封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EventLoop-Reactor"><span class="toc-number">8.</span> <span class="toc-text">EventLoop  Reactor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread-EventLoopThread-EventLoopThreadPool"><span class="toc-number">9.</span> <span class="toc-text">Thread EventLoopThread EventLoopThreadPool</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket-Socket%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">10.</span> <span class="toc-text">Socket Socket的封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Acceptor-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E6%94%B6"><span class="toc-number">11.</span> <span class="toc-text">Acceptor 新连接接收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">12.</span> <span class="toc-text">Buffer 缓冲区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TcpConnection-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">TcpConnection 连接管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TcpServer-%E6%A8%A1%E5%9D%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">14.</span> <span class="toc-text">TcpServer 模块连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%88%90%E5%BA%93%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84"><span class="toc-number">15.</span> <span class="toc-text">编译成库添加环境变量路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">16.</span> <span class="toc-text">测试代码</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/muduo/" title="C++ Muduo 库"><img src="/img/load4.gif" data-original="/img/cover/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Muduo 库"/></a><div class="content"><a class="title" href="/2025/07/17/muduo/" title="C++ Muduo 库">C++ Muduo 库</a><time datetime="2025-07-17T02:05:26.162Z" title="发表于 2025-07-17 10:05:26">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img src="/img/load4.gif" data-original="/img/cover/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于IPV4的流媒体广播"/></a><div class="content"><a class="title" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播">基于IPV4的流媒体广播</a><time datetime="2025-05-07T09:43:42.756Z" title="发表于 2025-05-07 17:43:42">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img src="/img/load4.gif" data-original="/img/cover/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ffmpeg"/></a><div class="content"><a class="title" href="/2025/04/17/ffmpeg/" title="ffmpeg">ffmpeg</a><time datetime="2025-04-17T14:51:36.000Z" title="发表于 2025-04-17 22:51:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img src="/img/load4.gif" data-original="/img/cover/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tinyWebServer"/></a><div class="content"><a class="title" href="/2025/04/15/tinyWebServer/" title="tinyWebServer">tinyWebServer</a><time datetime="2025-04-15T14:58:54.000Z" title="发表于 2025-04-15 22:58:54">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/chatRoom/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/04/15/chatRoom/" title="chatRoom">chatRoom</a><time datetime="2025-04-15T14:57:54.000Z" title="发表于 2025-04-15 22:57:54">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 张振强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>