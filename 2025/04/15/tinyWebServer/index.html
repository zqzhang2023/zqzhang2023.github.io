<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>tinyWebServer | 张振强的个人博客</title><meta name="author" content="张振强"><meta name="copyright" content="张振强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="tinyWebServer 项目写在前面： 学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。 刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急">
<meta property="og:type" content="article">
<meta property="og:title" content="tinyWebServer">
<meta property="og:url" content="http://example.com/2025/04/15/tinyWebServer/index.html">
<meta property="og:site_name" content="张振强的个人博客">
<meta property="og:description" content="tinyWebServer 项目写在前面： 学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。 刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/7.jpg">
<meta property="article:published_time" content="2025-04-15T14:58:54.000Z">
<meta property="article:modified_time" content="2025-04-15T15:34:19.689Z">
<meta property="article:author" content="张振强">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "tinyWebServer",
  "url": "http://example.com/2025/04/15/tinyWebServer/",
  "image": "http://example.com/img/cover/7.jpg",
  "datePublished": "2025-04-15T14:58:54.000Z",
  "dateModified": "2025-04-15T15:34:19.689Z",
  "author": [
    {
      "@type": "Person",
      "name": "张振强",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_1.png"><link rel="canonical" href="http://example.com/2025/04/15/tinyWebServer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'tinyWebServer',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/index_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">张振强的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">tinyWebServer</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">tinyWebServer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-15T14:58:54.000Z" title="发表于 2025-04-15 22:58:54">2025-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-15T15:34:19.689Z" title="更新于 2025-04-15 23:34:19">2025-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%A1%B9%E7%9B%AE/">C++ 项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">25.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="tinyWebServer-项目"><a href="#tinyWebServer-项目" class="headerlink" title="tinyWebServer 项目"></a>tinyWebServer 项目</h1><p>写在前面：</p>
<p>学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。</p>
<p>刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急，可以提前了解一下项目的知识再重新来做一下。</p>
<p>于是就先做了三个小项目，每个项目都挺经典的，而且项目的代码量也很小。</p>
<ul>
<li>线程池的项目：(主要学习线程池的概念和用法)<ul>
<li>项目介绍：<a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/</a></li>
<li>git链接：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool">https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool</a></li>
</ul>
</li>
<li>tinyhttpd 项目：（主要HTTP协议）<ul>
<li>项目介绍：<a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/">https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/</a></li>
<li>git链接：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/3_tinyhttpd">https://github.com/zqzhang2023/zzqStudy/tree/main/project/3_tinyhttpd</a></li>
</ul>
</li>
<li>chatRoom 项目：（主要学习socket和IO多路复用）<ul>
<li>项目介绍：<a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a></li>
<li>git链接：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/4_chatRoom">https://github.com/zqzhang2023/zzqStudy/tree/main/project/4_chatRoom</a></li>
</ul>
</li>
</ul>
<p>学习完基础知识之后，就开始尝试学学习这个项目</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这个项目在github上面有很多的版本</p>
<p>先说一下我自己的（嘿嘿嘿）：</p>
<p>cmake版本：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer</a></p>
<p>makefile版本：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile</a></p>
<p>初始的应该是这个：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer</a></p>
<p>但是这个确实有些久远，有些语法可能目前不太常使用了， 在这个最初的版本后面有贴C++ 11 实现的版本</p>
<p>也就是这个：<a target="_blank" rel="noopener" href="https://github.com/markparticle/WebServer">https://github.com/markparticle/WebServer</a></p>
<p>这个C++ 11 的版本看着很舒心，于是我就选择了这个版本开始学习</p>
<p>介绍：(这个是官方git上的原话，我直接拿过来了)</p>
<p>Linux下C++轻量级Web服务器，助力初学者快速实践网络编程，搭建属于自己的服务器.</p>
<ul>
<li><p>使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型</p>
</li>
<li><p>使用状态机解析HTTP请求报文，支持解析GET和POST请求</p>
</li>
<li><p>访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件</p>
</li>
<li><p>实现同步&#x2F;异步日志系统，记录服务器运行状态</p>
</li>
<li><p>经Webbench压力测试可以实现上万的并发连接数据交换</p>
</li>
</ul>
<p><img src="/img/load4.gif" data-original="/../0_images/tinyWebServer/0_tinyWebServer.jpg" alt="alt text"></p>
<h1 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h1><p>image<br>我的运行环境是Linux Ubuntu 20.04，Mysql，C++ 11</p>
<p>使用的版本是：<a target="_blank" rel="noopener" href="https://github.com/markparticle/WebServer">https://github.com/markparticle/WebServer</a></p>
<p>1.首先要安装数据库（这个可以找一下教程，网上有很多，而且安装确实不难）</p>
<p>2.然后按照网站是给出的步骤来,建立数据库和创建表格添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 建立yourdb库</span><br><span class="line">create database yourdb;</span><br><span class="line"></span><br><span class="line">// 创建user表</span><br><span class="line">USE yourdb;</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">    username char(50) NULL,</span><br><span class="line">    password char(50) NULL</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">// 添加数据</span><br><span class="line">INSERT INTO user(username, password) VALUES(&#x27;name&#x27;, &#x27;password&#x27;);</span><br></pre></td></tr></table></figure>

<p>3.修改一下 code&#x2F;main.cpp 里面的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 守护进程 后台运行 </span></span><br><span class="line">    <span class="function">WebServer <span class="title">server</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">1316</span>, <span class="number">3</span>, <span class="number">60000</span>,              <span class="comment">// 端口 ET模式 timeoutMs </span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">3306</span>, <span class="string">&quot;用户(一般是root)&quot;</span>, <span class="string">&quot;密码&quot;</span>, <span class="string">&quot;数据库名&quot;</span>, <span class="comment">/* Mysql配置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">12</span>, <span class="number">8</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="number">1024</span>)</span></span>;             <span class="comment">/* 连接池数量 线程池数量 日志开关 日志等级 日志异步队列容量 */</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>4.在根目录下 执行  make</p>
<p>5.在根目录下 执行 sudo .&#x2F;bin&#x2F;server （这里要用sudo哈，要不然可能出现权限问题）</p>
<p>下面是运行成功图（这个是后面截的，我修改了一部分）：</p>
<p><img src="/img/load4.gif" data-original="/../0_images/tinyWebServer/1_%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F%E5%9B%BE.png" alt="alt text"></p>
<h1 id="项目文件作用"><a href="#项目文件作用" class="headerlink" title="项目文件作用"></a>项目文件作用</h1><p>简单介绍一下各个文件的作用，官方给的是这个，但是咱们主要看code文件里面的东西</p>
<pre><code>.
├── code           源代码的目录
│   ├── buffer     
│   ├── config     
│   ├── http       
│   ├── log
│   ├── timer
│   ├── pool
│   ├── server
│   └── main.cpp
├── test           单元测试
│   ├── Makefile
│   └── test.cpp
├── resources      静态资源
│   ├── index.html
│   ├── image
│   ├── video
│   ├── js
│   └── css
├── bin            可执行文件
│   └── server
├── log            日志文件
├── webbench-1.5   压力测试
├── build          
│   └── Makefile
├── Makefile
├── LICENSE
└── readme.md
</code></pre>
<p>code文件夹目录：</p>
<pre><code>code/
├── buffer/
│   ├── buffer.cpp
│   ├── buffer.h             缓冲区的实现
│   └── readme.md
├── http/
│   ├── httpconn.cpp
│   ├── httpconn.h           综合httprequest与httpresponse
│   ├── httprequest.cpp
│   ├── httprequest.h        处理http请求
│   ├── httpresponse.cpp
│   ├── httpresponse.h       处理http响应
│   └── readme.md
├── log/
│   ├── blockqueue.h         阻塞队列(生产者消费者模式)
│   ├── log.cpp
│   ├── log.h                日志系统
│   └── readme.md
├── pool/
│   ├── readme.md
│   ├── sqlconnpool.cpp
│   ├── sqlconnpool.h        mysql链接池
│   └── threadpool.h         线程池
├── server/
│   ├── epoller.cpp
│   ├── epoller.h            对epoll接口的封装
│   ├── readme.md
│   ├── webserver.cpp    
│   └── webserver.h          最后的实现，综合了前面所有东西
├── timer/
│   ├── heap_timer.cpp 
│   ├── heap_timer.h         小根堆计时器
│   └── readme.md
└── main.cpp                 入口文件
</code></pre>
<p>下面就开始复现该项目，这个是别人的思路：</p>
<ul>
<li><p>通过采用从局部到整体的设计思想。先使用单一线程完成串行的HTTP连接建立、HTTP消息处理和HTTP应答发送，然后围绕高并发这个核心扩展多个模块。</p>
</li>
<li><p>首先就是日志模块和缓冲区模块的一个设计，这里优先实现是为了下面各个模块的调试方便，记录各个模块运行的状况和打印输出模块运作情况来排除明显的BUG。</p>
</li>
<li><p>然后是引入I&#x2F;O多路复用实现单线程下也能在一次系统调用中同时监听多个文件描述符，再进一步搭配线程池实现多客户多任务并行处理，这是高并发的核心部分。</p>
</li>
<li><p>在这个基础上做一点优化，在应用层实现了心跳机制，通过定时器实现非活跃连接的一个检测和中断，减少系统资源（内存）不必要的浪费。最后将所有模块整合起来，实现一个单Reactor多线程的网络设计模式，将多个模块串联起来实现完整高并发的服务器程序。</p>
</li>
<li><p>线程安全这块是通过不断将锁的粒度降低，平衡性能和安全。一开始采用粒度较粗的锁实现互斥（通常是整个操作），然后慢慢分析将一些不共享的代码移出临界区，慢慢调整慢慢优化。</p>
</li>
<li><p>最后加入数据库部分，因为这一部分比较独立，采用RAII机制创建连接池，拿出连接来使用。在HTTP中加入数据库信息验证的功能。</p>
</li>
</ul>
<p>我确实水平有限，没有按上面的思路实现，我的实现方法是：过两遍</p>
<ul>
<li><p>先看一遍代码，为原先的代码添加注释，一行一行的添加，每一行都要理解</p>
</li>
<li><p>自己写一遍，写的时候只看头文件(第一遍加注释的时候已经在头文件上加上各个函数的功能了)，自己写cpp文件实现头文件，遇到不会的再看原作者的实现</p>
<ul>
<li>如何验证自己写的是对的？</li>
<li>刚开始已经把原项目跑起来了，把自己写好的cpp实现替换跑起来的原项目的文件，看能不能再跑起来，有问题就调整。</li>
</ul>
</li>
</ul>
<h1 id="项目复现流程"><a href="#项目复现流程" class="headerlink" title="项目复现流程"></a>项目复现流程</h1><p>建立复现的流程：</p>
<ul>
<li>buffer 缓冲区的实现，这个和其不依赖其他模块，但是其他模块很依赖这个</li>
<li>log    日志系统,这个只依赖buffer模块，而且实现这个之后咱们就可以通过日志来调试了</li>
<li>pool   线程池和数据库连接池模块，这个模块比较独立，也是只依赖log和buffer</li>
<li>http   处理http请求与响应，依赖buffer log pool<ul>
<li>内部建议实现顺序：</li>
<li>httprequest(http请求的处理)</li>
<li>httpresponse(根据http请求来生成响应)</li>
<li>httpconn(将上面两个连接在一起，包括请求的接收以及响应的发送等)</li>
</ul>
</li>
<li>timer  小根堆计时器，是一个工具，只依赖log，还是因为调试才依赖的，很独立</li>
<li>server 最后的综合实现<ul>
<li>内部建议实现顺序：</li>
<li>epoller 对IO多路复用技术 epoll进行了一个封装</li>
<li>webserver 最后对所有模块进行综合</li>
</ul>
</li>
</ul>
<h1 id="项目复现"><a href="#项目复现" class="headerlink" title="项目复现"></a>项目复现</h1><p>按照项目复现流程开始复现</p>
<p>因为我已经提前看了一遍代码了，确实不知道如何从0开始写介绍，所以针对每个模块，我主要介绍一下我当时闭环模糊的点</p>
<h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><p>这是一个缓冲区模块模块，设计的非常的巧妙，通过两个指针来切分整个 vector ，我搜索的资料是这个设计的思路来源于 陈硕大佬的muduo网络库。</p>
<p>注意buffer的内容，要不然很容易搞迷糊，通过两个指针把buffer分成了三个区域 </p>
<p><img src="/img/load4.gif" data-original="/../0_images/tinyWebServer/2_buffer%E7%BB%93%E6%9E%84.png" alt="alt text"></p>
<p>|————-A———|————B———–|———–C————-|</p>
<ul>
<li>A区域：左侧是Buffer[0] 右侧是readPos_  这里表示prependable区域(正常情况下应该是读区域和写区域，读区域最开始的index应该是0，数据读除去之后 readPos_++ 就形成了这样一个区域，所以这个区域被称为备用区域，后续可以用这个区域来扩容写空间)</li>
<li>B区域：左侧是readPos_  右侧是writePos_ 这篇区域表示可以被读出去的区域</li>
<li>C区域：左侧是writePos_  右侧是readPos_ 这片区域表示便是可以写进来的区域</li>
</ul>
<p>那么我们模拟一下过程，假设一个buffer为1024这么大，那么初始的readPos_，writePos_均为0，现在进行模拟(记得在脑海里面想象一下过程)</p>
<ul>
<li>现在有一个socketfd要往buffer里面写东西，咱们调用他的read函数，然后把得到东西写入buffer中，假设使用了64字节那么大 (现在就是字节存进取，writePos_后移动64个位置)（现在写区域还剩下1024-64）</li>
<li>服务器读取内容，假设第一次读取32个字节(假设哈，这里是模拟，不是真实的)，那么readPos_向后移动32个位置，这个时候就形成了3个区域了，其中A区域，也就是0-31这些地方的内容已经被读出去了，不再需要了</li>
<li>现在服务器要把返回的东西写进来buffer，假设要写进来的东西是1024-64 + 16 比 还剩下的1024 - 64 多 16个字节，那么咱们就需要查找一下A区域的大小，咱们发现，A区域还有32个字节，可以支持，那么现在就需要合并一下A与C区域<ul>
<li>合并方法，移动B区域，将B区域移动到最前面，readPos_变成 0 writePos_变成 B.size B区域的大小</li>
<li>如果发现合并区域之后还是不行的话，那么就要给buffer多分配空间了</li>
</ul>
</li>
</ul>
<p><strong>代码（其实项目里面有，但是我这里加了注释可能比较清楚一些）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>    <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;         <span class="comment">// 地层的容器</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_; <span class="comment">// 原子类型的读指针(当前的读的位置)</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;<span class="comment">// 原子类型的写指针(当前的写的位置)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区起始地址（非常量）</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取缓冲区起始地址（常量）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 扩容或整理缓冲区以提供至少len字节可写空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数，初始化缓冲区大小及读写位置</span></span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize = <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//默认析构函数</span></span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//获取当前可写空间大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取当前可读数据大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//获取预留空间（已读区域）大小</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//返回当前可读数据的起始地址（常量指针）</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//确保至少有len字节的可写空间，否则扩容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动写指针（数据写入后调用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动读指针（消费len字节数据）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//移动读指针到指定地址（消费到end的数据）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line">    <span class="comment">//重置缓冲区（清空数据，读写指针归零）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//取出所有可读数据并转为字符串，清空缓冲区</span></span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回当前写位置常量指针</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//返回当前写位置指针</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//添加字符串到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="comment">//添加字符数组到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str,<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//添加任意类型数据到缓冲区（转换为char*）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="comment">//添加另一个缓冲区的可读数据到当前缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="comment">//从文件描述符读取数据到缓冲区（使用readv,并且注意这里是读数据到缓冲区，所以要放入C区域，操作的是writePos_）</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="comment">//将缓冲区的可读数据写入文件描述符(注意这里是写入文件描述符，因此要读缓冲区，是从B区域读出去，操作的是readPos_)</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="comment">//注意上面俩参数，非常容易搞混乱</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：初始化缓冲区大小和读写位置</span></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize):<span class="built_in">buffer_</span>(initBuffSize),<span class="built_in">readPos_</span>(<span class="number">0</span>),<span class="built_in">writePos_</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(initBuffSize &gt; <span class="number">0</span> ); <span class="comment">//确保initBuffSize的有效性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可写字节数 = 总容量 - 写位置</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前可读字节数 = 写位置 - 读位置</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回预留空间（已读区域）大小 = 读位置 (已经读过的就没用了，等于读下标)</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可读数据起始地址（常量指针）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[readPos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保至少有len字节可写空间，否则扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="built_in">WritableBytes</span>())&#123;  <span class="comment">//目前的空间不足</span></span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);        <span class="comment">//整理(合并)一下空间，再不足就扩容了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(len &lt; <span class="built_in">WritableBytes</span>()); <span class="comment">//打个断言</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动写下标，更新写位置（数据写入后调用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    writePos_ += len; <span class="comment">// 写指针后移len字节 注意：可能会有疑问，这里就不怕越界吗？其实一般情况下，要写入输入之前会调用EnsureWriteable，再写再移动指针，但是说实话还是程序控制比较好，现在的方法全靠程序员自觉（而且这还是个public方法）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取len长度，移动读下标 消费数据：移动读指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    readPos_ += len; <span class="comment">//和HasWritten同理，如果跟着做完有时间的话，可以尝试一下重构一下代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费数据直到指定地址，这里没说要读哈，就是相当于把end之前的可读的区域都放弃掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end); <span class="comment">//你看这这里就打断言了， &amp;buffer_[readPos_] 要小于 end</span></span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>()); <span class="comment">// end指针 - 读指针 长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出所有数据，buffer归零，读写下标归零,在别的函数中会用到</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());  <span class="comment">// 覆盖原本数据 清空数据 可选，因为readPos_ = writePos_ = 0; 其实就代表归0了，里面的内容就相当于全部舍弃了</span></span><br><span class="line">    readPos_ = writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  取出剩余可读的str 取出所有可读数据并转为字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(),ReadableBytes())</span></span>; <span class="comment">//string字符串构造，记得看了解一下字符串</span></span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前写位置常量指针</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前写位置指针</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加str到缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);                       <span class="comment">// 确保可写的长度</span></span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());    <span class="comment">// 将str放到写下标开始的地方</span></span><br><span class="line">    <span class="built_in">HasWritten</span>(len);                            <span class="comment">// 移动写下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加字符串到缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">c_str</span>(),str.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型，强制转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加另一个缓冲区的可读数据到当前缓冲区(不是合并俩缓冲区哈，就相当与把buff之中的可读数据写在现在这个缓冲区里面哈，别搞错了)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区起始地址（内部使用）</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓冲区起始地址（常量版本）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len)&#123;  <span class="comment">// C + A 区域 都无法满足 len大小的数据了，这时候就要扩容了</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>); <span class="comment">//  扩容至所需大小+1（保险）</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//合并空间</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>()); <span class="comment">//将缓冲区中从readPos_到writePos_之间的数据复制到缓冲区的起始位置</span></span><br><span class="line">        readPos_ = <span class="number">0</span>;          <span class="comment">// 读指针归零</span></span><br><span class="line">        writePos_ = readable;  <span class="comment">// 写指针指向原数据末尾</span></span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>()); <span class="comment">// 确保数据完整性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个最为重要的函数，放在最后来写</span></span><br><span class="line"><span class="comment">// 将buffer中可读的区域写入fd中</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span>* Errno)</span></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd,<span class="built_in">Peek</span>(),<span class="built_in">ReadableBytes</span>()); <span class="comment">//将读区域内部的所有的东西都写进fd之中，一般情况下都不会出错，也就是 len 会= ReadableBytes()，但是也有可能会出错</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        *Errno = errno;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Retrieve</span>(len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将fd的内容读到缓冲区，即writable的位置</span></span><br><span class="line"><span class="comment">// 这里要注意哈，看咱们前面的函数，一般情况下，咱们会调用咱们的Append函数来向buffer里面写东西</span></span><br><span class="line"><span class="comment">// 但是碰到一个问题，如何判断咱们要写入的长度，这取决于fd要传给咱们多少东西，咱们现在也不知道，要传给咱多少</span></span><br><span class="line"><span class="comment">// 因此这里要使用 分散读写 通过定义一个 struct iovec 数组接收, struct iovec iov[2]; ssize_t len = readv(fd, iov, 2); 会优先向iov[0]之中写,如果不够写的话,会再向iov[1]写</span></span><br><span class="line"><span class="comment">// struct iovec &#123;</span></span><br><span class="line"><span class="comment">//     void  *iov_base;  // 指向缓冲区的指针</span></span><br><span class="line"><span class="comment">//     size_t iov_len;   // 缓冲区的长度</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span>* Errno)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];   <span class="comment">// 栈区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">size_t</span> writeable = <span class="built_in">WritableBytes</span>(); <span class="comment">// 获取现在缓冲区内部还有多少可写的空间</span></span><br><span class="line">    <span class="comment">// 分散读,保证数据能够读完</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginWrite</span>();</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writeable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff); <span class="comment">//65535</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>); <span class="comment">//开始读</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123; <span class="comment">// 出现错误了</span></span><br><span class="line">        *Errno = errno;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writeable)&#123; <span class="comment">//说明咱们基础的缓存空间是足够存储的,没有使用char buff[65535]; </span></span><br><span class="line">        writePos_ += len;   <span class="comment">// 直接移动写下标 //你看你看,我就说HasWritten函数有问题,这里估计作者自己都忘记了有这么一个函数</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 说明咱们的空间是不够的(同时说明了,咱们的buffer_空间内部已经填满了)</span></span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>(); <span class="comment">// 写区写满了,下标移到最后</span></span><br><span class="line">        <span class="built_in">Append</span>(buff, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len - writeable)); <span class="comment">// 剩余的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>日志系统</p>
<p>1.使用单例模式来实现，目的是保证一个类只有一个实例，并提供一个他的全局访问点，该实例被所有程序模块共享。</p>
<p>2.异步日志，日志写入的时候需要写入文件，因此需要进行IO操作，IO操作如果放在主线程的话就会很大的阻塞线程，因此需要再创建一个线程来进行这个IO操作</p>
<p>3.日志的分级与分文件</p>
<ul>
<li>Debug，调试代码时的输出，在系统实际运行时，一般不使用。</li>
<li>Warn，这种警告与调试时终端的warning类似，同样是调试代码时使用。</li>
<li>Info，报告系统当前的状态，当前执行的流程或接收的信息等。</li>
<li>Erro，输出系统的错误信息</li>
</ul>
<p>4.分文件情况</p>
<ul>
<li>按天分，日志写入前会判断当前today是否为创建日志的时间，若为创建日志时间，则写入日志，否则按当前时间创建新的log文件，更新创建时间和行数。</li>
<li>按行分，日志写入前会判断行数是否超过最大行限制，若超过，则在当前日志的末尾加lineCount &#x2F; MAX_LOG_LINES为后缀创建新的log文件。</li>
</ul>
<h3 id="blockqueue"><a href="#blockqueue" class="headerlink" title="blockqueue"></a>blockqueue</h3><p>这是一个安全队列，咱们普通的队列在进行多线程操作的时候会出现互斥，必须得先加锁，再进行队列操作才可以，现在将这些加锁的操作封装到队列之中，这就是安全队列。在其他多线程的地方调用安全队列的方法的的时候不需要加锁，因为内部已经加锁了</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;T&gt; deq_;                      <span class="comment">// 底层双端队列容器</span></span><br><span class="line">    mutex mtx_;                         <span class="comment">// 互斥锁，保护队列操作</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                      <span class="comment">// 关闭标志</span></span><br><span class="line">    <span class="type">size_t</span> capacity_;                   <span class="comment">// 队列关闭标志</span></span><br><span class="line">    condition_variable condConsumer_;   <span class="comment">// 消费者条件变量（队列空时等待）</span></span><br><span class="line">    condition_variable condProducer_;   <span class="comment">// 生产者条件变量（队列满时等待）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockQueue</span><span class="params">(<span class="type">size_t</span> maxsize = <span class="number">1000</span>)</span></span>;   <span class="comment">// 构造函数，设置队列容量</span></span><br><span class="line">    ~<span class="built_in">BlockQueue</span>();                                <span class="comment">// 析构函数，关闭队列并释放资源</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;                                 <span class="comment">// 判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;                                  <span class="comment">// 判满</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;                <span class="comment">// 在队尾添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;               <span class="comment">// 在队头添加元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;                            <span class="comment">// 弹出的任务放入item</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> timeout)</span></span>;               <span class="comment">// 带超时的弹出操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                                 <span class="comment">// 清空队列</span></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;                                    <span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;                                     <span class="comment">// 获取队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;                            <span class="comment">// 获取队列容量</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;                                <span class="comment">// 获取当前元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;                                 <span class="comment">// 唤醒一个消费者线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                 <span class="comment">// 关闭队列，唤醒所有线程</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造函数</span></span><br><span class="line"><span class="comment"> * @param maxsize 队列最大容量，必须大于0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::<span class="built_in">BlockQueue</span>(<span class="type">size_t</span> maxsize):<span class="built_in">capacity_</span>(maxsize)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(maxsize &gt; <span class="number">0</span>);        <span class="comment">// 确保容量合法</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;           <span class="comment">// 初始化关闭标志为false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 析构函数：调用Close清理资源 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::~<span class="built_in">BlockQueue</span>()&#123;  <span class="comment">// 析构函数：调用Close清理资源</span></span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空队列 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭队列：清空队列并唤醒所有等待线程 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">Close</span>()&#123;</span><br><span class="line">    <span class="built_in">clear</span>();  <span class="comment">//内部加锁了，咱们这里就不用加锁了</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有等待的消费者和生产者线程</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">empty</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否已满 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">full</span>()&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;  <span class="comment">// 线程安全，一定要加锁</span></span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;<span class="comment">// 当前大小 &gt;= 容量即为满</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在队尾插入元素（生产者调用）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="comment">// 注意，条件变量需要搭配unique_lock</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    condProducer_.<span class="built_in">wait</span>(locker,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;deq_.<span class="built_in">size</span>() &gt;= <span class="keyword">this</span>-&gt;capacity_)||<span class="keyword">this</span>-&gt;isClose_;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClose_) &#123; <span class="comment">//关闭就抛出异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);               <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知一个消费者可以取数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在队头插入元素（生产者调用）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="comment">// 注意，条件变量需要搭配unique_lock</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    condProducer_.<span class="built_in">wait</span>(locker,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;deq_.<span class="built_in">size</span>() &gt;= <span class="keyword">this</span>-&gt;capacity_)||<span class="keyword">this</span>-&gt;isClose_;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (isClose_) &#123; <span class="comment">//关闭就return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);               <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知一个消费者可以取数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弹出队头元素（消费者调用，阻塞）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;    <span class="comment">// 必须使用unique_lock以便操作条件变量</span></span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>()) &#123;               <span class="comment">// 队列空则等待</span></span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);     <span class="comment">// 挂起消费者，等待队列非空信号</span></span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;                   <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();                <span class="comment">// 取队头元素</span></span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();         <span class="comment">// 通知生产者有空位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弹出队头元素（支持超时等待）</span></span><br><span class="line"><span class="comment"> * @param timeout 超时时间（秒）</span></span><br><span class="line"><span class="comment"> * @return 超时或队列关闭返回false，否则true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;   <span class="comment">// 必须使用unique_lock以便操作条件变量</span></span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout)) </span><br><span class="line">                == std::cv_status::timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 超时返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;                      <span class="comment">// 检查队列是否已关闭</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队头元素（线程安全）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队尾元素（线程安全）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列容量 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前元素数量 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒一个消费者线程（常用于手动触发处理）*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="log-1"><a href="#log-1" class="headerlink" title="log"></a>log</h3><p>(下面是我复现的时候的一些想法)</p>
<p>日志系统对整个项目来说非常重要，涉及到一些错误调试操作</p>
<ul>
<li><p>单例模式：确保整个程序中只有一个日志实例，在这样一个“庞大”的系统之中，无法避免的的要全局的访问日志系统，如果使用多个日志实例的话，那么就需要考虑很多很多的同步的问题，因此单例模式是最优解</p>
<ul>
<li>这里要注意，这个项目是C++11实现的 C++11标准 （§6.7 [stmt.dcl] 第4段） 如果控制流在变量初始化时并发进入声明，并发线程必须等待初始化完成。 也就是说 静态局部变量 是线程安全的</li>
</ul>
</li>
<li><p>同步与异步：这里又涉及到了同步与异步的概念，这个可以搜索了解一下，这里简单来说，就是：同步，在写入文件的时候直接在主线程里面写；异步：重新申请一个线程，在线程里面写，不会阻塞主线程</p>
<ul>
<li>咱们来理一下整个流程</li>
<li>1.向外接口是 LOG_INFO （以LOG_INFO为例哈，其他的还有LOG_DEBUG啥的）看下面的宏定义。首先会获取实例，然后经过判断调用write</li>
<li>2.在写的时候先判断一下对应的文件(比如日期，比如文件的行数是不是超过最大的行数)，如果有问题的话会重新生成一个新的日志文件</li>
<li>3.然后会组合日志的语句，存储到buffer之中。比如：一行日志：2025-04-11 10:58:46.397812 [info] : Client<a href="127.0.0.1:59563">23</a> in, userCount:6 这里需要生成前面的2025-04-11 10:58:46.397812 [info]还要组合后面的内容</li>
<li>4.最后才是写进去，这里要注意，写的时候就涉及到同步和异步了<ul>
<li>同步：直接在主线程里面写就行了，也就是说直接写，并不需要啥多余的操作，因此这里的IO操作就会对主线程造成阻塞</li>
<li>异步：通过申请一个新的线程来写。具体操作：设置一个阻塞队列，典型的生产者-消费者模型。咱们申请的线程会一直读取这个队列里面的的内容(也就是pop)，如果为空的话就会线程就会阻塞，但是只要有值push进去的话，就会重新唤醒线程<ul>
<li>因此，在异步的情况下，直接将buffer之中的内容push到队列之中就行了，push之后会唤醒线程从而执行写的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>还有一个小点，就是可变参数，这个不解释其实也能的懂，但是这边还是记录一下把</p>
<ul>
<li>正常的调用比如：LOG_INFO(“11111”) 这种是没有可变参数的</li>
<li>带有可变参数的比如：LOG_INFO(“%s,%s,%d”,str1,str2,int1) 这样就是有可变参数的</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>           <span class="comment">// 可变参数支持（va_start, va_end）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">// 目录操作（mkdir）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 常量定义  static const 可以直接在里面初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>; <span class="comment">// 日志文件最长文件名</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>; <span class="comment">// 日志最长名字</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;  <span class="comment">// 日志文件内的最长日志条数</span></span><br><span class="line">    <span class="comment">// 日志文件相关参数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;   <span class="comment">// 日志文件存储路径</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_; <span class="comment">// 日志文件后缀名</span></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;      <span class="comment">// 最大日志行数</span></span><br><span class="line">    <span class="comment">// 运行时状态</span></span><br><span class="line">    <span class="type">int</span> lineCount_;      <span class="comment">// 当前日志文件行数计数器</span></span><br><span class="line">    <span class="type">int</span> toDay_;          <span class="comment">// 记录当前日期（用于日志滚动）</span></span><br><span class="line">    <span class="type">bool</span> isOpen_;        <span class="comment">// 日志系统是否开启标志</span></span><br><span class="line">    <span class="comment">// 缓冲区与日志级别</span></span><br><span class="line">    Buffer buff_;        <span class="comment">// 输出的内容，缓冲区</span></span><br><span class="line">    <span class="type">int</span> level_;          <span class="comment">// 日志等级</span></span><br><span class="line">    <span class="type">bool</span> isAsync_;       <span class="comment">// 是否开启异步日志</span></span><br><span class="line">    <span class="comment">// 文件与线程相关</span></span><br><span class="line">    FILE* fp_;           <span class="comment">// 打开log的文件指针</span></span><br><span class="line">    std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; deque_; <span class="comment">// 阻塞队列（用于异步模式） //注意哈，这里设置的是一个智能指针因此用的时候注意一下，这是一个指针</span></span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;       <span class="comment">// 异步写线程 指针，同队列理</span></span><br><span class="line">    std::mutex mtx_;                                 <span class="comment">// 互斥锁（保证线程安全）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造与析构</span></span><br><span class="line">    <span class="built_in">Log</span>();                                          <span class="comment">// 构造函数（私有，单例模式）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;           <span class="comment">// 添加日志级别前缀</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();                                 <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;                             <span class="comment">// 异步写日志的实际执行方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化日志系统</span></span><br><span class="line">    <span class="comment">// 参数：level-日志级别, path-日志路径, suffix-日志后缀, maxQueueCapacity-阻塞队列容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>, <span class="type">const</span> <span class="type">char</span>* suffix = <span class="string">&quot;.log&quot;</span>,<span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;       <span class="comment">// 获取单例实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>; <span class="comment">// 异步写日志公有方法，调用私有方法asyncWrite 异步写日志线程入口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写日志方法（核心方法</span></span><br><span class="line">    <span class="comment">// 参数：level-日志级别, format-格式化字符串, ...-可变参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span>;  <span class="comment">// 将输出内容按照标准格式整理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;                                  <span class="comment">// 刷新缓冲区到文件</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;                                <span class="comment">// 获取当前日志级别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;                      <span class="comment">// 设置日志级别</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isOpen_; &#125;              <span class="comment">// 判断日志系统是否开启</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 日志宏定义（对外接口） ********************/</span></span><br><span class="line"><span class="comment">// 基础日志宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个宏定义，主要用于不同类型的日志输出，也是外部使用日志的接口</span></span><br><span class="line"><span class="comment">// ...表示可变参数，__VA_ARGS__就是将...的值复制到这里</span></span><br><span class="line"><span class="comment">// 前面加上##的作用是：当可变参数的个数为0时，这里的##可以把把前面多余的&quot;,&quot;去掉,否则会编译出错。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">Log::<span class="built_in">Log</span>()&#123;</span><br><span class="line">    fp_ = <span class="literal">nullptr</span>;           <span class="comment">// 初始化文件指针为空</span></span><br><span class="line">    deque_ = <span class="literal">nullptr</span>;        <span class="comment">// 初始化阻塞队列为空</span></span><br><span class="line">    writeThread_ = <span class="literal">nullptr</span>;  <span class="comment">// 初始化写线程为空</span></span><br><span class="line">    lineCount_ = <span class="number">0</span>;          <span class="comment">// 初始化行计数器 </span></span><br><span class="line">    toDay_ = <span class="number">0</span>;              <span class="comment">// 初始化当前日期</span></span><br><span class="line">    isAsync_ = <span class="literal">false</span>;        <span class="comment">// 默认同步模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Log::~<span class="built_in">Log</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">empty</span>())&#123;</span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>();      <span class="comment">// 唤醒消费者，处理掉剩下的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    deque_-&gt;<span class="built_in">Close</span>();          <span class="comment">// 关闭队列</span></span><br><span class="line">    <span class="keyword">if</span>(writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>())&#123; <span class="comment">// 确保线程存在且可join</span></span><br><span class="line">        writeThread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp_)&#123;                  <span class="comment">// 冲洗文件缓冲区，关闭文件描述符</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">flush</span>();              <span class="comment">// 清空缓冲区中的数据</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);          <span class="comment">// 关闭日志文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞队列消费者，开始写日志 刷新缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isAsync_)&#123;         <span class="comment">// 只有异步日志才会用到deque</span></span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(fp_);           <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉模式 局部静态变量法（这种方法不需要加锁和解锁操作）</span></span><br><span class="line"><span class="function">Log* <span class="title">Log::Instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> Log log;  <span class="comment">// C++11保证静态局部变量线程安全</span></span><br><span class="line">    <span class="keyword">return</span> &amp;log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步日志的写线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();   <span class="comment">// 调用实际写方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写线程真正的执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">pop</span>(str))&#123; <span class="comment">// 从队列获取日志字符串 //阻塞的地方在这里 writeThread_ 相当于deque_的消费者，当没有数据的时候会阻塞</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;     <span class="comment">// 这里的加锁不是针对队列(安全队列会自己加锁)哈，针对的是 fp_</span></span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);            <span class="comment">// 写入文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化日志系统</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix, <span class="type">int</span> maxQueCapacity)</span> </span>&#123;</span><br><span class="line">    isOpen_ = <span class="literal">true</span>;       <span class="comment">// 标记日志系统开启</span></span><br><span class="line">    level_ = level;       <span class="comment">// 设置日志级别</span></span><br><span class="line">    path_ = path;         <span class="comment">// 日志存储路径</span></span><br><span class="line">    suffix_ = suffix;     <span class="comment">// 文件后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(maxQueCapacity)&#123;   <span class="comment">// 异步方式 队列容量&gt;0启用异步</span></span><br><span class="line">        isAsync_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!deque_)&#123;      <span class="comment">// 为空则创建一个</span></span><br><span class="line">            unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; <span class="built_in">newQue</span>(<span class="keyword">new</span> BlockQueue&lt;std::string&gt;);</span><br><span class="line">            <span class="comment">// 因为unique_ptr不支持普通的拷贝或赋值操作,所以采用move</span></span><br><span class="line">            <span class="comment">// 将动态申请的内存权给deque，newDeque被释放</span></span><br><span class="line">            deque_ = <span class="built_in">move</span>(newQue);</span><br><span class="line">            <span class="comment">// 启动写线程</span></span><br><span class="line">            <span class="function">unique_ptr&lt;thread&gt;  <span class="title">newThread</span><span class="params">(<span class="keyword">new</span> thread(FlushLogThread))</span></span>;</span><br><span class="line">            writeThread_ = <span class="built_in">move</span>(newThread); <span class="comment">//注意这里哈，刚开始写的时候是不是有些疑问呀，就是这个时候已经对writeThread_进行初始化了，该线程已经执行了，但是他执行的啥呢？刚开始啥也么没有应当会阻塞的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置行计数器</span></span><br><span class="line">    lineCount_ = <span class="number">0</span>;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间处理（日志文件按日期滚动）</span></span><br><span class="line">    <span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建日志文件名</span></span><br><span class="line">    path_ = path;     <span class="comment">//和前面重复了，原作者没注意估计</span></span><br><span class="line">    suffix_ = suffix;</span><br><span class="line">    <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, </span><br><span class="line">        path_, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);</span><br><span class="line">    toDay_ = t.tm_mday;      <span class="comment">// 记录当前日期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作（加锁保证线程安全）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="keyword">if</span>(fp_) &#123;              <span class="comment">// 处理旧文件指针</span></span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">            <span class="built_in">fclose</span>(fp_);</span><br><span class="line">        &#125;</span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>); <span class="comment">// 追加模式打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(fp_ == <span class="literal">nullptr</span>)&#123;         <span class="comment">// 文件不存在时创建目录</span></span><br><span class="line">            <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);     <span class="comment">// 创建日志目录（rwx权限）</span></span><br><span class="line">            fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>); <span class="comment">// 生成目录文件（最大权限）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);  <span class="comment">// 确保文件打开成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心写日志方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);    <span class="comment">// 获取精确时间（微秒级）</span></span><br><span class="line">    <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    va_list vaList;                <span class="comment">// 可变参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志文件滚动判断 */</span></span><br><span class="line">    <span class="comment">// 条件1：日期变化 或 条件2：行数超过限制</span></span><br><span class="line">    <span class="keyword">if</span>(toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_  %  MAX_LINES == <span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        locker.<span class="built_in">unlock</span>();              <span class="comment">// 临时释放锁，避免阻塞其他线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个时候得重新创建一个新的文件了</span></span><br><span class="line">        <span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 时间戳部分（yyyy_mm_dd）</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday); <span class="comment">// 目前的精准事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(toDay_!=t.tm_mday)&#123;  <span class="comment">// 事件部匹配</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);  <span class="comment">//为啥要减72？</span></span><br><span class="line">            toDay_ = t.tm_mday;      <span class="comment">// 更新日期记录</span></span><br><span class="line">            lineCount_ = <span class="number">0</span>;          <span class="comment">// 重置行计数器</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 行数超了</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_  / MAX_LINES), suffix_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        locker.<span class="built_in">lock</span>();  <span class="comment">// 重新加锁</span></span><br><span class="line">        <span class="built_in">flush</span>();        <span class="comment">// 确保数据写入当前文件</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);    </span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(newFile, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 创建新日志文件</span></span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在buffer内生成一条对应的日志信息</span></span><br><span class="line">    <span class="comment">// 说实话，我说实话，我觉得这里的buff很没必要</span></span><br><span class="line">    <span class="comment">// 这是一条完整info log 2025-04-11 10:58:52.272179 [info] : Verify name:111 pwd:111 先看这个的话可能会好理解一些</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        lineCount_++; <span class="comment">// 行号递增</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">        t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">        t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);  <span class="comment">//这是一条完整info log 2025-04-11 10:58:52.272179 [info] : Verify name:111 pwd:111</span></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(n);           <span class="comment">// 移动写指针</span></span><br><span class="line">        <span class="built_in">AppendLogLevelTitle_</span>(level);    <span class="comment">// 添加日志级别前缀 [info]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理可变参数 注意哈，这里的可变参数，刚开始可能会不太明白，但是你看一下上面的int n = snprintf(buff_.BeginWrite(), 128, &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;,</span></span><br><span class="line">        <span class="comment">// 如果传递的是 format = &quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot; vaList =         t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec</span></span><br><span class="line">        <span class="comment">// 这样是不是就明白了</span></span><br><span class="line">        <span class="built_in">va_start</span>(vaList, format);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);</span><br><span class="line">        <span class="built_in">va_end</span>(vaList);</span><br><span class="line"></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(m);      <span class="comment">// 更新缓冲区写位置</span></span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);  <span class="comment">// 添加换行和结束符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据模式选择写入方式</span></span><br><span class="line">        <span class="keyword">if</span>(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>())&#123;  <span class="comment">// 异步方式（加入阻塞队列中，等待写线程读取日志信息）</span></span><br><span class="line">            deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 同步方式（直接向文件中写入日志信息）</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);   <span class="comment">// 同步就直接写入文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();    <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加日志等级</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(level) &#123; <span class="comment">// 不同级别添加不同前缀</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前日志级别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>1.线程池</p>
<p>我在博客 <a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/</a> 里面也做了一些介绍，现在再介绍一下</p>
<p>线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程</p>
<p>2.数据库连接池</p>
<p>这里仿照了线程池的一些思路</p>
<p>服务器在运行的时候肯定不只一个用户连接，每个用户连接的时候都需要进行数据库操作，在连接的时候要对数据库连接进行初始化，那样就非常的耗时，因此引入了 数据库连接池</p>
<ul>
<li>先进行数据库连接，把连接好的标识放入一个池子里面（这里是queue），然后用户来的时候只需要把这些连接好的标识非配给他就好了</li>
</ul>
<p>因此：数据库连接池就需要使用 <strong>单例模式</strong> 了，为什么？</p>
<ul>
<li>整个系统就只需要一个池子，不需要多个池子，也就是说不需要多个实例</li>
<li>如果想要更多的池子的话，把的第一个池子扩大一些不就好了吗</li>
<li>因此单例模式是最为合适的</li>
</ul>
<p>3.RAII</p>
<p>这个就是说，由系统来管理资源的申请和释放。智能指针就是用这个来思路来实现的，咱们不需要手动释放资源了，系统会帮忙管理。</p>
<p>再说白了：其实就是再单独设计一个class，用来申请资源，比如在构造的时候new 一个 地址空间，在析构的时候delete一下，设计一个向外的接口，可以获取这个地址空间的指针。那么咱们在用的时候就不需要考虑这个地址空间的释放问题了，因为随着这个class生命周期的结束，就会自动释放这个空间。</p>
<p>这个可以看一下智能指针的实现的思路就理解了</p>
<p>我在这里介绍了 <a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/C++pointer/">https://blog.zqzhang2025.com/2025/04/13/C++pointer/</a></p>
<h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>这里的实现比较简单了，因为task只需要接收void类型的函数，就是说没有返回值的函数，我之前实现的theadpool(<a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/ThreadPool/)%E6%98%AF%E7%BB%BC%E5%90%88%E8%80%83%E8%99%91%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%AD%89%E9%97%AE%E9%A2%98%E7%9A%84">https://blog.zqzhang2025.com/2025/04/13/ThreadPool/)是综合考虑到返回值和可变参数等问题的</a></p>
<p>这里的比较简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用一个结构体封装起来，方便调用  其实我感觉没必要，CLASS 已经有了很好的封装性了 再说了，你一个私有的，你让谁调用，你的友元吗</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span>&#123;</span><br><span class="line">        std::mutex mtx_;</span><br><span class="line">        std::condition_variable cond_;</span><br><span class="line">        <span class="type">bool</span> isClosed;</span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;  <span class="comment">// 任务队列，函数类型为void()</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_; <span class="comment">//这个意思就是用智能指针管理Pool然后咱们不用手动释放了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数（C++11特性）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动构造函数（默认实现）</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/* 主要构造函数</span></span><br><span class="line"><span class="comment">     * @param threadCount: 线程数量，默认为8</span></span><br><span class="line"><span class="comment">     * @note 使用make_shared创建共享资源池，保证内存连续性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尽量用make_shared代替new，如果通过new再传递给shared_ptr，内存是不连续的，会造成内存碎片化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">int</span> threadCount = <span class="number">8</span>)</span> : pool_(std::make_shared&lt;Pool&gt;()) &#123;</span> <span class="comment">// make_shared:传递右值，功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr</span></span><br><span class="line">        <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);                  <span class="comment">// 校验线程数量合法性</span></span><br><span class="line">        <span class="comment">// 创建指定数量的工作线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            std::<span class="built_in">thread</span>([<span class="keyword">this</span>]&#123; <span class="comment">//注意哈，这里一定要把this传进去</span></span><br><span class="line">                std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool_-&gt;mtx_);    <span class="comment">// 自动加锁</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">// 任务队列非空时处理任务</span></span><br><span class="line">                    <span class="keyword">if</span>(!pool_-&gt;tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="comment">// 获取队列首个任务（使用移动语义转移所有权） 左值变右值,资产转移</span></span><br><span class="line">                        <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool_-&gt;tasks.<span class="built_in">front</span>());    </span><br><span class="line">                        pool_-&gt;tasks.<span class="built_in">pop</span>(); <span class="comment">// 移除队列元素</span></span><br><span class="line">                        locker.<span class="built_in">unlock</span>();    <span class="comment">// 因为已经把任务取出来了，所以可以提前解锁了</span></span><br><span class="line">                        <span class="built_in">task</span>();             <span class="comment">// 执行任务</span></span><br><span class="line">                        locker.<span class="built_in">lock</span>();      <span class="comment">// 马上又要取任务了，上锁</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pool_-&gt;isClosed)&#123; <span class="comment">// 池关闭时退出线程</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 队列空时进入等待状态</span></span><br><span class="line">                        pool_-&gt;cond_.<span class="built_in">wait</span>(locker); <span class="comment">// 等待,如果任务来了就notify的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>(); <span class="comment">// 分离线程（线程生命周期与主线程无关）  其实更好的操作是用一个vector来管理线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构函数 */</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool_)&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx_)</span></span>;</span><br><span class="line">            pool_-&gt;isClosed = <span class="literal">true</span>; <span class="comment">// 设置关闭标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond_.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加任务到队列</span></span><br><span class="line"><span class="comment">     * @tparam T: 可调用对象类型（自动推导）</span></span><br><span class="line"><span class="comment">     * @param task: 要添加的任务（通用引用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(T&amp;&amp; task)</span></span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx_)</span></span>; <span class="comment">//上锁</span></span><br><span class="line">        <span class="comment">// 使用完美转发保持参数的值类别</span></span><br><span class="line">        pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(task));</span><br><span class="line">        pool_-&gt;cond_.<span class="built_in">notify_one</span>();                       <span class="comment">// 通知一个等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="sqlconnpool"><a href="#sqlconnpool" class="headerlink" title="sqlconnpool"></a>sqlconnpool</h3><p>在看这个之前记得先了解一下C++数据库的基本操作哈，其实就是几个函数，挺简单了，去搜一下大概10分钟就业能了解了。</p>
<p>数据库的连接 数据库的查询 查询结果获取 数据库的插入 等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据库连接池类（单例模式） */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_CONN_; <span class="comment">//最大连接数</span></span><br><span class="line">    std::queue&lt;MYSQL* &gt; connQue_; <span class="comment">//连接队列</span></span><br><span class="line">    std::mutex mtx_;  <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> semId_;     <span class="comment">// 信号量（控制并发访问） PV操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">SqlConnPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 析构时自动关闭</span></span><br><span class="line">    ~<span class="built_in">SqlConnPool</span>() &#123; <span class="built_in">ClosePool</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例实例（C++11线程安全实现）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SqlConnPool* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取一个数据库连接</span></span><br><span class="line">    <span class="function">MYSQL* <span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 释放连接回池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL* conn)</span></span>;</span><br><span class="line">    <span class="comment">// 获取空闲连接数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 初始化连接池</span></span><br><span class="line"><span class="comment">     * @param host:     数据库主机地址</span></span><br><span class="line"><span class="comment">     * @param port:     端口号</span></span><br><span class="line"><span class="comment">     * @param user:     用户名</span></span><br><span class="line"><span class="comment">     * @param pwd:      密码</span></span><br><span class="line"><span class="comment">     * @param dbName:   数据库名</span></span><br><span class="line"><span class="comment">     * @param connSize: 连接池大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">uint16_t</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源在对象构造初始化 资源在对象析构时释放  RAII数据库连接管理类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *sql_;               <span class="comment">// 持有的数据库连接</span></span><br><span class="line">    SqlConnPool* connpool_;    <span class="comment">// 关联的连接池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造函数获取连接</span></span><br><span class="line"><span class="comment">     * @param sql:     输出参数，用于返回获得的连接</span></span><br><span class="line"><span class="comment">     * @param connpool: 连接池实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool *connpool)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(connpool);</span><br><span class="line">        *sql = connpool-&gt;<span class="built_in">GetConn</span>();   <span class="comment">// 从池中获取连接</span></span><br><span class="line">        sql_ = *sql;                  <span class="comment">// 保存连接指针</span></span><br><span class="line">        connpool_ = connpool;         <span class="comment">// 保存连接池引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构时自动释放连接</span></span><br><span class="line">    ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(sql_) &#123; connpool_-&gt;<span class="built_in">FreeConn</span>(sql_); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SQLCONNPOOL_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单例实例（线程安全）</span></span><br><span class="line"><span class="function">SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> SqlConnPool pool; <span class="comment">// C++11保证静态变量初始化线程安全</span></span><br><span class="line">    <span class="keyword">return</span> &amp;pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数据库连接池</span></span><br><span class="line"><span class="comment"> * @param host     : 数据库主机名/IP</span></span><br><span class="line"><span class="comment"> * @param port     : 端口号（无符号16位）</span></span><br><span class="line"><span class="comment"> * @param user     : 用户名</span></span><br><span class="line"><span class="comment"> * @param pwd      : 密码</span></span><br><span class="line"><span class="comment"> * @param dbName   : 数据库名称</span></span><br><span class="line"><span class="comment"> * @param connSize : 连接池容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">uint16_t</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>); <span class="comment">// connSize 连接池容量 得大于 0 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;connSize;i++)&#123;   <span class="comment">// 创建连接</span></span><br><span class="line">        MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">        conn = <span class="built_in">mysql_init</span>(conn);   <span class="comment">// 初始化MYSQL结构体</span></span><br><span class="line">        <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);     <span class="comment">// 记录错误日志</span></span><br><span class="line">            <span class="built_in">assert</span>(conn);                       <span class="comment">// 调试模式终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立实际连接</span></span><br><span class="line">        conn = <span class="built_in">mysql_real_connect</span>(conn, host, user, pwd, dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);   <span class="comment">// 连接失败记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        connQue_.<span class="built_in">emplace</span>(conn);   <span class="comment">// 将连接加入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    MAX_CONN_ = connSize;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);  <span class="comment">// 初始化信号量（进程间不共享，初始值为MAX_CONN_）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取数据库连接</span></span><br><span class="line"><span class="comment"> * @return: 可用MYSQL连接指针，无可用时返回nullptr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);    <span class="comment">// 记录警告日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;                   <span class="comment">// 无可用时返回nullptr </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);                    <span class="comment">// P操作（信号量-1），阻塞直到&gt;0</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;       <span class="comment">// 加锁</span></span><br><span class="line">    conn = connQue_.<span class="built_in">front</span>();              <span class="comment">// 获取队首连接</span></span><br><span class="line">    connQue_.<span class="built_in">pop</span>();                       <span class="comment">// 移除队列元素</span></span><br><span class="line">    <span class="keyword">return</span> conn;                          <span class="comment">// 可用MYSQL连接指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放连接回池（实际上没有释放，只是放到池子里面去了）</span></span><br><span class="line"><span class="comment"> * @param conn: 要释放的数据库连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* conn)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(conn);                       <span class="comment">// 确保连接有效</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    connQue_.<span class="built_in">push</span>(conn);                <span class="comment">// 将连接放回队列</span></span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);                  <span class="comment">// V操作（信号量+1）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接池（释放所有连接）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!connQue_.<span class="built_in">empty</span>()) &#123;    <span class="comment">// 关闭数据库连接</span></span><br><span class="line">        <span class="keyword">auto</span> conn = connQue_.<span class="built_in">front</span>(); </span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">mysql_close</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_library_end</span>();  <span class="comment">// 清理MySQL库资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前空闲连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>这里主要是针对HTTP的一些操作，注意学习一下HTTP报本的一些基本结构，包括请求报文以及响应报文</p>
<p>我在 <a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/">https://blog.zqzhang2025.com/2025/04/13/tinyhttpd/</a> 里面做了一些基本介绍</p>
<p>在这里再说一下 报文结构</p>
<p><img src="/img/load4.gif" data-original="/../0_images/tinyWebServer/3_HTTP%E6%8A%A5%E6%96%87.png" alt="alt text"></p>
<p>那么我们举个例子：</p>
<p>以下是百度的请求包</p>
<pre><code>&gt; GET / HTTP/1.1\r\n
&gt; Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n
&gt; Accept-Encoding: gzip, deflate, br\r\n
&gt; Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n
&gt; Connection: keep-alive\r\n
&gt; Host: www.baidu.com\r\n
&gt; Sec-Fetch-Dest: document\r\n
&gt; Sec-Fetch-Mode: navigate\r\n
&gt; Sec-Fetch-Site: none\r\n
&gt; Sec-Fetch-User: ?1\r\n
&gt; Upgrade-Insecure-Requests: 1\r\n
&gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.41 Safari/537.36 Edg/101.0.1210.32\r\n
&gt; sec-ch-ua: &quot; Not A;Brand&quot;;v=“99”, “Chromium”;v=“101”, “Microsoft Edge”;v=“101”\r\n
&gt; sec-ch-ua-mobile: ?0\r\n
&gt; sec-ch-ua-platform: “Windows”\r\n
</code></pre>
<p>上面只包括请求行、请求头和空行，请求数据为空。请求方法是GET，协议版本是HTTP&#x2F;1.1；请求头是键值对的形式。（注意哈，上面的\r\n是我自己添加的哈，去掉才是正常的，我添加上只是为了表示，每一行的结尾是\r\n）</p>
<p>响应报文：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK\r\n</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT\r\n</span><br><span class="line">Content-Type: text/html; charset=UTF-8\r\n</span><br><span class="line">\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--body goes here--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="httprequest"><a href="#httprequest" class="headerlink" title="httprequest"></a>httprequest</h3><p>这个class主要是针对http请求的，所以看这部分代码之前务必要先了解HTTP请求，了解请求报文的基本结构</p>
<p>注意这里不做逻辑处理哈，比如一个get请求一个页面，这里只是找到这个html，不会返回给客户，只有post的登陆和注册会在这做逻辑处理，但是也是只处理，相当于处理出来一个结果，保存下来。到这里就这个class的任务就结束了，剩下的响应就交给httpresponse了</p>
<p>这里有个很重要的概念：有限状态机</p>
<p>我们再来看一下请求报文。第一行为请求行，往后为请求头，再后面就是请求数据了</p>
<p>因此一般是按照顺序来解析这个请求报文</p>
<ul>
<li>先解析请求行 获取 请求方法，版本号 以及请求的url等</li>
<li>再解析请求头</li>
<li>最后看有没有请求体，有的话就需要解析了</li>
</ul>
<p>因此这个有限状态机就是这样的：</p>
<p><img src="/img/load4.gif" data-original="/../0_images/tinyWebServer/4_%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="alt text"></p>
<p>来看一下代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_REQUEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_REQUEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span>          <span class="comment">// 正则表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>        <span class="comment">// 错误号处理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span>  <span class="comment">//mysql</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义HTTP解析状态机的状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PARSE_STATE</span> &#123;</span><br><span class="line">        REQUEST_LINE,  <span class="comment">// 正在解析请求行（如 GET / HTTP/1.1）</span></span><br><span class="line">        HEADERS,       <span class="comment">// 正在解析请求头部</span></span><br><span class="line">        BODY,          <span class="comment">// 正在解析请求体</span></span><br><span class="line">        FINISH,        <span class="comment">// 解析完成</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HttpRequest</span>() &#123; <span class="built_in">Init</span>(); &#125;  <span class="comment">// 构造函数初始化解析状态</span></span><br><span class="line">    ~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;  <span class="comment">// 默认析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;               <span class="comment">// 初始化/重置解析器状态</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;  <span class="comment">// 主解析函数，传入数据缓冲区</span></span><br><span class="line">    <span class="comment">// 获取解析结果的访问方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">path</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 获取请求路径（常量）</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;           <span class="comment">// 获取请求路径（可修改）</span></span><br><span class="line">    <span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="function">std::string <span class="title">version</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 获取HTTP版本</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;   <span class="comment">// 获取POST表单值</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;           <span class="comment">// 重载版本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 判断是否保持连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;    <span class="comment">// 处理请求行</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;         <span class="comment">// 处理请求头</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;           <span class="comment">// 处理请求体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;                                  <span class="comment">// 处理请求路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;                                  <span class="comment">// 处理Post事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;                        <span class="comment">// 从url种解析编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户验证（静态方法，与具体请求实例无关）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd, <span class="type">bool</span> isLogin)</span></span>;  <span class="comment">// 用户验证</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    PARSE_STATE state_;                        <span class="comment">// 当前解析状态</span></span><br><span class="line">    std::string method_,path_,version_,body_;  <span class="comment">// 请求方法（GET/POST等） 请求路径  HTTP版本（如HTTP/1.1） 请求体内容</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; header_;   <span class="comment">// 请求头键值对</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; post_;     <span class="comment">// POST表单键值对</span></span><br><span class="line">    <span class="comment">// 静态常量：预定义的HTML页面和标签</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DEFAULT_HTML;   <span class="comment">// 默认支持的页面</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFAULT_HTML_TAG; <span class="comment">// 页面类型标记</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ConverHex</span><span class="params">(<span class="type">char</span> ch)</span></span>;  <span class="comment">// 十六进制字符转换辅助函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 定义HTTP解析状态机的状态</span></span><br><span class="line"><span class="comment">// enum PARSE_STATE &#123;</span></span><br><span class="line"><span class="comment">//     REQUEST_LINE,  // 正在解析请求行（如 GET / HTTP/1.1）</span></span><br><span class="line"><span class="comment">//     HEADERS,       // 正在解析请求头部</span></span><br><span class="line"><span class="comment">//     BODY,          // 正在解析请求体</span></span><br><span class="line"><span class="comment">//     FINISH,        // 解析完成</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义的默认支持HTML页面（自动添加.html后缀）</span></span><br><span class="line"><span class="type">const</span> unordered_set&lt;string&gt; HttpRequest::DEFAULT_HTML &#123;</span><br><span class="line">    <span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;/video&quot;</span>, <span class="string">&quot;/picture&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面类型映射（登录页为1，注册页为0）</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, <span class="type">int</span>&gt; HttpRequest::DEFAULT_HTML_TAG &#123;</span><br><span class="line">    &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化HTTP请求解析器状态 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state_ = REQUEST_LINE;                    <span class="comment">// 初始状态为解析请求行</span></span><br><span class="line">    method_ = path_ = version_= body_ = <span class="string">&quot;&quot;</span>;   <span class="comment">// 清空请求方法 请求路径 HTTP版本  请求体</span></span><br><span class="line">    header_.<span class="built_in">clear</span>();    <span class="comment">// 清空请求头</span></span><br><span class="line">    post_.<span class="built_in">clear</span>();      <span class="comment">// 清空POST数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主解析函数（核心状态机）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> END[] = <span class="string">&quot;\r\n&quot;</span>;      <span class="comment">// HTTP换行符定义  HTTP每一行都是以 &quot;\r\n&quot; 结尾的 (请求体不是哈)</span></span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() == <span class="number">0</span>)&#123;  <span class="comment">// 没有可读的字节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取数据开始 当缓冲区有数据且未完成解析时循环处理</span></span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_!= FINISH)&#123;</span><br><span class="line">        <span class="comment">// 从buff中的读指针开始到读指针结束，这块区域是未读取得数据并去处&quot;\r\n&quot;，返回有效数据得行末指针</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineend = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), END, END<span class="number">+2</span>);  <span class="comment">//查找子串 返回第一个子串的首地址</span></span><br><span class="line">        <span class="function">string <span class="title">line</span><span class="params">(buff.Peek(),lineend)</span></span>; <span class="comment">// 提取当前行内容（不包含换行符）这样就是一个完整的报文行了</span></span><br><span class="line">        <span class="keyword">switch</span> (state_)&#123; <span class="comment">// 根据当前状态处理不同部分</span></span><br><span class="line">            <span class="keyword">case</span> REQUEST_LINE:&#123;</span><br><span class="line">                <span class="type">bool</span> res = <span class="built_in">ParseRequestLine_</span>(line); <span class="comment">//解析请求行，返返回解析结果</span></span><br><span class="line">                <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">ParsePath_</span>();   <span class="comment">// 处理请求路径（添加.html后缀等）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> HEADERS:&#123;</span><br><span class="line">                <span class="built_in">ParseHeader_</span>(line);  <span class="comment">// 解析头部字段</span></span><br><span class="line">                <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;  <span class="comment">// 说明是get请求，后面为\r\n 如果剩余数据&lt;=2字节（只剩\r\n），说明没有请求体，直接完成</span></span><br><span class="line">                    state_ = FINISH;   <span class="comment">// 提前结束</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BODY:&#123;</span><br><span class="line">                <span class="built_in">ParseBody_</span>(line);  <span class="comment">// 处理请求体</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理缓冲区：移动读指针到下一行开始</span></span><br><span class="line">        <span class="comment">// 处理缓冲区：移动读指针到下一行开始</span></span><br><span class="line">        <span class="keyword">if</span>(lineend == buff.<span class="built_in">BeginWrite</span>()) &#123;  <span class="comment">// 读完了</span></span><br><span class="line">            buff.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineend + <span class="number">2</span>);        <span class="comment">// 跳过已处理的\r\n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>()); <span class="comment">//这就是之前提的带参的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析请求行（格式：方法 路径 HTTP/版本） // 注意一正则操作哈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParseRequestLine_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^ ]*) ([^ ]*) HTTP/([^ ]*)$&quot;</span>)</span></span>;  <span class="comment">//  // 正则表达式匹配三部分</span></span><br><span class="line">    smatch Match;   <span class="comment">// 用来匹配patten得到结果</span></span><br><span class="line">    <span class="comment">// 在匹配规则中，以括号()的方式来划分组别 一共三个括号 [0]表示整体</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, Match, patten)) &#123;  <span class="comment">// 匹配指定字符串整体是否符合</span></span><br><span class="line">        method_ = Match[<span class="number">1</span>];  <span class="comment">// 第1组：方法（GET/POST）</span></span><br><span class="line">        path_ = Match[<span class="number">2</span>];    <span class="comment">// 第2组：请求路径</span></span><br><span class="line">        version_ = Match[<span class="number">3</span>]; <span class="comment">// 第3组：HTTP版本</span></span><br><span class="line">        state_ = HEADERS;    <span class="comment">// 状态转移到解析头部</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析路径，统一一下path名称,方便后面解析资源（添加默认页面或后缀）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path_ == <span class="string">&quot;/&quot;</span>) &#123; <span class="comment">//说明刚来请求，还没请求东西，先来给个首页</span></span><br><span class="line">        path_ = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否是预定义的页面，自动添加.html后缀</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML.<span class="built_in">find</span>(path_) != DEFAULT_HTML.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            path_ += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析单个请求头字段（格式：Key: Value）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^:]*): ?(.*)$&quot;</span>)</span></span>; <span class="comment">// 匹配键值对</span></span><br><span class="line">    smatch Match;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, Match, patten)) &#123;</span><br><span class="line">        header_[Match[<span class="number">1</span>]] = Match[<span class="number">2</span>];   <span class="comment">// 存储到header_哈希表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 匹配失败说明首部行匹配完了，状态变化</span></span><br><span class="line">        state_ = BODY;  <span class="comment">// 转移到解析请求体状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求体（目前直接存储，后续处理由ParsePost_完成）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    body_ = line;       <span class="comment">// 暂存请求体内容</span></span><br><span class="line">    <span class="built_in">ParsePost_</span>();       <span class="comment">// 解析POST数据</span></span><br><span class="line">    state_ = FINISH;    <span class="comment">// 状态转换为下一个状态</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制转化为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpRequest::ConverHex</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;     <span class="comment">// A(10) ~ F(15)</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;f&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;     <span class="comment">// a(10) ~ f(15)</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;0&#x27;</span>;          <span class="comment">// 0(0) ~9(9)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 非法字符可返回0或抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理POST请求（表单数据解析和用户验证）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否为表单提交</span></span><br><span class="line">    <span class="keyword">if</span>(method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp; header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析URL编码的表单数据（处理%编码和键值对） 比如：name=John%20Doe&amp;age=25%26under20</span></span><br><span class="line">        <span class="built_in">ParseFromUrlencoded_</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前路径是否需要验证（登录/注册）</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML_TAG.<span class="built_in">count</span>(path_))&#123; <span class="comment">// 如果是登录/注册的path</span></span><br><span class="line">            <span class="type">int</span> tag = DEFAULT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;   <span class="comment">// 获取页面类型标记</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Tag:%d&quot;</span>, tag);</span><br><span class="line">            <span class="keyword">if</span>(tag==<span class="number">0</span>||tag==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);  <span class="comment">// 为1则是登录，处理登陆（数据库select，处理注册的话数据库得insert 无论是登陆还是注册，数据库都得select哈，毕竟得确认用户名未被使用）</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin)) &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/welcome.html&quot;</span>;  <span class="comment">//匹配成功则path_改成welcome</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/error.html&quot;</span>;    <span class="comment">//匹配不成功则path_改成error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析URL编码的表单数据（处理%编码和键值对）</span></span><br><span class="line"><span class="comment">// 比如：name=John%20Doe%26age=25</span></span><br><span class="line"><span class="comment">// 处理name=John%20Doe %20解码为空格，键值对变为name=John Doe。</span></span><br><span class="line"><span class="comment">// %26解码为&amp;，键值对变为name=John Doe&amp;age=25</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(body_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;  <span class="comment">//空则return</span></span><br><span class="line"></span><br><span class="line">    string key, value;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">char</span> ch = body_[i];</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="comment">// 键值分隔符</span></span><br><span class="line">            key = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 空格替换</span></span><br><span class="line">            body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: <span class="comment">// 处理%编码（如%20为空格）</span></span><br><span class="line">            num = <span class="built_in">ConverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">ConverHex</span>(body_[i + <span class="number">2</span>]);</span><br><span class="line">            body_[i + <span class="number">2</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            body_[i + <span class="number">1</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i += <span class="number">2</span>; <span class="comment">// 跳过两个十六进制字符</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:  <span class="comment">// 键值对分隔符</span></span><br><span class="line">            value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            post_[key] = value; <span class="comment">//存储一下</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(j &lt;= i);</span><br><span class="line">    <span class="comment">// 处理最后一个键值对</span></span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">        post_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户验证（查询数据库）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;pwd, <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;  <span class="comment">//为空直接返回</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从连接池获取数据库连接（RAII方式自动释放）</span></span><br><span class="line">    MYSQL* sql;</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(&amp;sql, SqlConnPool::<span class="built_in">Instance</span>()); <span class="comment">// SqlConnRAII Name(&amp;sql, SqlConnPool::Instance()); 只不过这里不需要name来操作</span></span><br><span class="line">    <span class="built_in">assert</span>(sql);  <span class="comment">//判断是拿到正常的sql</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//这个flag 前边表示是否需要执行注册(insert) 后面表示执行的结果 成功与否</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> order[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MYSQL_FIELD *fields = <span class="literal">nullptr</span>;</span><br><span class="line">    MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isLogin)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//说明是注册操作 数据库得 insert 登陆的话 数据库只需要select  无论是登陆还是注册，数据库都得select哈，毕竟得确认用户名未被使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询用户及密码</span></span><br><span class="line">    <span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;SELECT username, password FROM user WHERE username=&#x27;%s&#x27; LIMIT 1&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql,order))&#123;</span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">mysql_store_result</span>(sql);</span><br><span class="line">    j = <span class="built_in">mysql_num_fields</span>(res);</span><br><span class="line">    fields = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">    <span class="keyword">while</span>(MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res))&#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>; <span class="comment">// 数据库中的密码</span></span><br><span class="line">        <span class="keyword">if</span>(isLogin)&#123;  <span class="comment">//登陆表单 比对一下密码</span></span><br><span class="line">            <span class="keyword">if</span>(pwd == password) &#123; </span><br><span class="line">                flag = <span class="literal">true</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">LOG_INFO</span>(<span class="string">&quot;pwd error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//注册表单 //既然能够查询到用户名和密码，那么说明用户名已经存在了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;user used!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册行为 且 用户名未被使用</span></span><br><span class="line">    <span class="keyword">if</span>(!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;regirster!&quot;</span>);</span><br><span class="line">        <span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(order, <span class="number">256</span>,<span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;Insert error!&quot;</span>);</span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;UserVerify success!!&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里要注意哈， SqlConnRAII 会自动释放，执行析构函数，也就是说自动释放sql资源到池子里面，注意回去看看这个是怎么操作的 </span></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">HttpRequest::path</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> version_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否保持连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> header_.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>)-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp; version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="httpresponse"><a href="#httpresponse" class="headerlink" title="httpresponse"></a>httpresponse</h3><p>这里就很常规了，和之前的httprequest类似，主要是组合响应报文，并不会将响应报文返回给客户端,这里一定要注意一下响应报文的格式</p>
<p>这里一定要注意，组合响应报文，并不会将响应报文返回给客户端</p>
<p>我举个例子：</p>
<ul>
<li><p>比如httprequest解析了一个GET请求的，请求的是一个index.html的文件</p>
</li>
<li><p>那么httpresponse任务就是组合响应报文，比如响应报文的状态行  响应头 以及 添加响应内容</p>
</li>
<li><p>其中涉及到一些判断，比如状态行，如果发现没有index.html那个就是404 如果发现有但是咱们没有操作的权限就是403等。</p>
</li>
<li><p>这里会把状态行以及响应头放在一个buffer里面方便后面httpconn取</p>
</li>
<li><p>响应内容 是一个文件，那么就会把这个文件放到内存映射里面，这里不会放在buffer里面哈，毕竟文件很大，就是映射到内存，方便后面httpconn取</p>
<ul>
<li>简单介绍一下内存映射，比如一个文件里面存储abcd，内存映射就是把文件映射到内存里面，分配一个连续的空间存储abcd，给一个首地址，指向a，那么后续咱们要拿就直接操作这个地址就行了。</li>
<li>这个就是简单理解哈，想要搞懂可以取网上搜一下，有很多的介绍。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// mmap, munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="type">int</span> code_;                           <span class="comment">// HTTP状态码</span></span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;                   <span class="comment">// 是否保持长连接</span></span><br><span class="line">    std::string path_;                   <span class="comment">// 也就是文件名</span></span><br><span class="line">    std::string srcDir_;                 <span class="comment">// 资源的根目录（绝对）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mmFile_;                       <span class="comment">// 内存映射的文件指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;             <span class="comment">// 文件状态信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;  <span class="comment">// 后缀类型集</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;          <span class="comment">// 编码状态集</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;            <span class="comment">// 编码路径集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;    <span class="comment">// 添加状态行到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;       <span class="comment">// 添加响应头到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer &amp;buff)</span></span>;      <span class="comment">// 添加响应内容到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;                   <span class="comment">// 处理错误页面路径</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;          <span class="comment">// 获取文件类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">HttpResponse</span>(); <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化HTTP响应对象</span></span><br><span class="line">    <span class="comment">// 参数: srcDir-资源根目录，path-请求路径，isKeepAlive-是否保持连接，code-初始状态码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 构建完整的HTTP响应到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="comment">// 获取内存映射的文件指针</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 解除内存映射</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取文件长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 生成错误内容到缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="comment">// 获取当前状态码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_RESPONSE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP/1.1 200 OK\r\n</span></span><br><span class="line"><span class="comment">// Date: Fri, 22 May 2009 06:07:21 GMT\r\n</span></span><br><span class="line"><span class="comment">// Content-Type: text/html; charset=UTF-8\r\n</span></span><br><span class="line"><span class="comment">// \r\n</span></span><br><span class="line"><span class="comment">// &lt;html&gt;</span></span><br><span class="line"><span class="comment">//       &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">//       &lt;body&gt;</span></span><br><span class="line"><span class="comment">//             &lt;!--body goes here--&gt;</span></span><br><span class="line"><span class="comment">//       &lt;/body&gt;</span></span><br><span class="line"><span class="comment">// &lt;/html&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件后缀到MIME类型的映射</span></span><br><span class="line"><span class="comment">// 告诉浏览器如何处理文件</span></span><br><span class="line"><span class="comment">// 例如：text/html 表示 HTML 文档，浏览器会渲染它；application/pdf 表示 PDF 文件，浏览器可能会调用 PDF 阅读器。</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态码到状态描述的映射</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123; <span class="number">200</span>, <span class="string">&quot;OK&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态码到错误页面路径的映射</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数初始化成员变量</span></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    code_ = <span class="number">-1</span>;              <span class="comment">// 初始无效状态码</span></span><br><span class="line">    path_ = srcDir_ = <span class="string">&quot;&quot;</span>;    <span class="comment">// 清空路径</span></span><br><span class="line">    isKeepAlive_ = <span class="literal">false</span>;    <span class="comment">// 默认关闭长连接</span></span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>;       <span class="comment">// 初始无内存映射</span></span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;     <span class="comment">// 清空文件状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数确保解除内存映射</span></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> string&amp; srcDir, string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);             <span class="comment">// 确保资源目录有效</span></span><br><span class="line">    <span class="keyword">if</span>(mmFile_)&#123;</span><br><span class="line">        <span class="built_in">UnmapFile</span>();                  <span class="comment">// 首先解除之前的内存映射</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置成员变量</span></span><br><span class="line">    code_ = code;</span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建HTTP响应主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="comment">// 检查文件是否存在且不是目录</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;</span><br><span class="line">        code_ = <span class="number">404</span>;   <span class="comment">// 不存在或为目录</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH))&#123;</span><br><span class="line">        code_ = <span class="number">403</span>;   <span class="comment">// 无读取权限</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>)&#123; </span><br><span class="line">        code_ = <span class="number">200</span>;   <span class="comment">// 未指定状态码时默认成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();           <span class="comment">// 处理错误页面路径 这里相当于先判断一下是否存在错误(400,403,404)，如果存在的话就把文件换成响应的错误的页面</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);    <span class="comment">// 构建状态行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);       <span class="comment">// 构建头部</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);      <span class="comment">// 构建内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内存映射文件指针\r\n</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;  <span class="comment">// 从文件状态获取大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误页面路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态码有对应错误页面</span></span><br><span class="line">    <span class="keyword">if</span>(CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;         <span class="comment">// 更新路径为错误页面</span></span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);  <span class="comment">// 重新获取文件状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加状态行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    string status;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;  <span class="comment">// 已知状态码</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        code_ = <span class="number">400</span>;    <span class="comment">// 未知状态码默认400</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(<span class="number">400</span>)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 格式：HTTP/1.1 200 OK\r\n</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + <span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接状态</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(isKeepAlive_)&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容类型</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcFd &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);  <span class="comment">// 文件打开失败</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件映射到内存提高文件的访问速度  MAP_PRIVATE 建立一个写入时拷贝的私有映射</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">        <span class="comment">// mmap 是一个系统调用，用于将文件或设备映射到进程的地址空间，从而可以通过指针操作来访问文件内容。</span></span><br><span class="line">    <span class="comment">// 表示映射的地址由系统选择。 mmFileStat_.st_size：表示映射的长度，即文件的大小。mmFileStat_ 是一个 struct stat 类型的变量，st_size 是文件的大小。</span></span><br><span class="line">    <span class="comment">// PROT_READ表示映射区域的保护属性，只允许读取。  MAP_PRIVATE表示映射是私有的，对映射区域的修改不会写回文件。 文件描述符，表示要映射的文件。0 表示从文件的偏移量为 0 的位置开始映射。</span></span><br><span class="line">    <span class="comment">// 返回一个指向映射区域的指针。如果映射失败，返回 (void*)-1。 这里将返回值强制转换为 int* 类型，并赋值给 mmRet。</span></span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*mmRet == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);   <span class="comment">// 映射失败</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;  <span class="comment">// 保存映射指针</span></span><br><span class="line">    <span class="built_in">close</span>(srcFd);</span><br><span class="line">    <span class="comment">// 添加内容长度头</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>); <span class="comment">//注意看上面的HTTP响应报文格式，就知道这里为啥会有两个&quot;\r\n\r\n&quot;了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除内存映射</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size); <span class="comment">// 释放映射内存</span></span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件类型 </span></span><br><span class="line"><span class="function">string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找最后一个.的位置 得找到后缀，然后查表</span></span><br><span class="line">    string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos) &#123;   <span class="comment">// 最大值 find函数在找不到指定值得情况下会返回string::npos 这个说明没有 .  也就是说没有后缀</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;    <span class="comment">// 默认纯文本</span></span><br><span class="line">    &#125;</span><br><span class="line">    string suffix = path_.<span class="built_in">substr</span>(idx);   <span class="comment">// 提取后缀</span></span><br><span class="line">    <span class="keyword">if</span>(SUFFIX_TYPE.<span class="built_in">count</span>(suffix)==<span class="number">1</span>)&#123;    <span class="comment">// 查找已知类型</span></span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;    <span class="comment">// 默认纯文本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成错误内容HTML</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, string message)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string body;</span><br><span class="line">    string status;</span><br><span class="line">    <span class="comment">// 构建HTML结构</span></span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充错误信息</span></span><br><span class="line">    body += <span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status  + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    <span class="comment">// 添加内容长度和内容本身</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="httpconn"><a href="#httpconn" class="headerlink" title="httpconn"></a>httpconn</h3><p>这里是综合了前面 httprequest 与 httpresponse</p>
<p>什么意思呢？就是向外面提供一些接口，这个类里面会存储客户端的文件描述符(fd)，以及相应的客户端的地址（sockaddr_in），里面实现了读fd内容的操作，向fd里面写的操作，等。</p>
<p>httprequest 负责解析 请求内容</p>
<p>httpresponse 负责生成 响应内容</p>
<p>整体大概的流程：</p>
<p>相当于将 请求内容 读取到 readBuff_ 之中 然后 httprequest 负责解析 后面 httpresponse 负责生成响应的内容，写到 writeBuff_ 里面 然后再写到 fd 里面</p>
<p>1.这里简单介绍一下ET和LT，简单解释一下：</p>
<ul>
<li>相当于通知我们有数据来了</li>
<li>LT模式下如果缓冲区里面有数据就会一直不停的通知，一直到咱们把缓冲区里面的数据全部读完才会停止通知。因此LT模式下支持分次读或者写，因为如果咱们一次没读完，后面还会不停的继续通知咱们。这样虽然有效，但是确实会浪费系统资源，因为要不停通知</li>
<li>ET模式下只有缓冲区里面来数据了才会通知一次，也只会通知一次。因此，咱们在进行读写的时候必须要保证一次性读完才可以。</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>       <span class="comment">//  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接相关成员</span></span><br><span class="line">    <span class="type">int</span> fd_;                      <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_;     <span class="comment">// 客户端地址结构</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                <span class="comment">// 连接是否已关闭标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作相关</span></span><br><span class="line">    <span class="type">int</span> iovCnt_;                  <span class="comment">// iov数组有效元素个数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];         <span class="comment">// 分散写结构数组</span></span><br><span class="line">    Buffer readBuff_;             <span class="comment">// 读缓冲区    读缓冲区（存储客户端请求数据）</span></span><br><span class="line">    Buffer writeBuff_;            <span class="comment">// 写缓冲区    写缓冲区（存储生成的响应头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP处理对象</span></span><br><span class="line">    HttpRequest request_;         <span class="comment">// HTTP请求解析器</span></span><br><span class="line">    HttpResponse response_;       <span class="comment">// HTTP响应生成器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 &amp; 析构函数</span></span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                   <span class="comment">// 从socket读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                  <span class="comment">// 向socket写入数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                   <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;                              <span class="comment">// 获取文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// 获取客户端端口</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// 获取客户端IP字符串</span></span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 获取客户端地址结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;                                 <span class="comment">// 处理HTTP请求生成响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写的总长度              // 计算待发送数据总长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否保持连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员（类级别共享）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;                    <span class="comment">// 标记是否使用ET（边沿触发）模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;           <span class="comment">// 服务器资源目录路径</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;   <span class="comment">// 原子计数器，记录当前连接数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;         <span class="comment">// 资源目录路径（由外部设置）</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount; <span class="comment">// 原子连接计数器初始化为0</span></span><br><span class="line"><span class="type">bool</span> HttpConn::isET;                  <span class="comment">// ET模式标记（默认false，需外部设置）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;                <span class="comment">// 初始无效文件描述符</span></span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 清空地址结构</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;         <span class="comment">// 初始为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>();                 <span class="comment">// 确保连接关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化新连接</span></span><br><span class="line"><span class="comment"> * @param fd 客户端socket描述符</span></span><br><span class="line"><span class="comment"> * @param addr 客户端地址结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);        <span class="comment">// 确保有效fd</span></span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();  <span class="comment">// 清空写缓冲区</span></span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空读缓冲区</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;          <span class="comment">// 标记为打开状态</span></span><br><span class="line">    <span class="comment">// 记录日志：客户端IP、端口和当前连接数</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();     <span class="comment">// 释放内存映射文件（如果有）</span></span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>;      <span class="comment">// 标记为已关闭</span></span><br><span class="line">        userCount--;          <span class="comment">// 连接数-1</span></span><br><span class="line">        <span class="built_in">close</span>(fd_);           <span class="comment">// 关闭socket</span></span><br><span class="line">        <span class="comment">// 记录客户端退出日志</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取客户端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端IP字符串（点分十进制）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);  <span class="comment">//还有记得大端转小端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端端口号（网络字节序）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取数据到读缓冲区</span></span><br><span class="line"><span class="comment"> * @param saveErrno 用于保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 读取的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 使用Buffer的ReadFd读取数据到读缓冲区</span></span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 出错或读完了,关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET); <span class="comment">// ET模式需一次性读完所有数据 //这里要理解一下为什么ET模式要一次性读完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写数据到socket（使用writev聚合写）</span></span><br><span class="line"><span class="comment"> * @param saveErrno 保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 写入的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_,iov_,iovCnt_); <span class="comment">// writev将iov数组内容写入socket</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数据是否全部写完</span></span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 传输结束 */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len)&#123;  <span class="comment">// 处理部分写入情况（先写iov[0]响应头，再写iov[1]文件内容）</span></span><br><span class="line">            <span class="comment">// 这里详细解释一下,很容易搞不懂(先看下面那个else)</span></span><br><span class="line">            <span class="comment">// OK 这里仿照 下面那个else就好理解了</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len); <span class="comment">// iov_[0]已写完，调整iov_[1]的指针和长度</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="comment">// 但是着一块又难理解了</span></span><br><span class="line">            <span class="comment">// 首先咱们要知道一点 writeBuff_ 里面存储的是响应头部分,刚开始被赋予了iov_[0].iov_base,因此当iov_[0]写完了那么writeBuff_就没有用了,就清空一下就好了</span></span><br><span class="line">            <span class="comment">// 我们主要理解一下为什么到这个位置了iov_[0].iov_len还不为0</span></span><br><span class="line">            <span class="comment">// 举个例子好理解,比如原始的iov_[0].iov_len = 100 原始的iov_[1].iov_len = 1000 那么第一次写的时候len为200,那么是不是就理解了,这个时候不会进入下面那个else,只会进入这个,因此我们需要处理iov_[0]</span></span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;</span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>(); <span class="comment">// 清空写缓冲区</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;      <span class="comment">// iov_[0]长度置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// iov_[0]未写完，调整其指针和长度</span></span><br><span class="line">            <span class="comment">// 里详细解释一下,很容易搞不懂</span></span><br><span class="line">            <span class="comment">// 写的时候总得知道写的其实地址和写的总长度把</span></span><br><span class="line">            <span class="comment">// 刚开始第一个缓冲区的起始地址是 iov_[0].iov_base 和 长度是 iov_[0].iov_len  这个没的说</span></span><br><span class="line">            <span class="comment">// 到这里表示前面的 len = writev(fd_,iov_,iovCnt_);  正常执行了,并且已经写进入len这么多了,而且len要小于iov_[0].iov_len表示iov_[0]还没写完</span></span><br><span class="line">            <span class="comment">// 这个时候就需要调整一下后面写的其实地址和写的总长度了</span></span><br><span class="line">            <span class="comment">// 那么后面就好理解了 起始地址不就是 iov_base往后移动 len 个位置马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len; </span><br><span class="line">            <span class="comment">// 剩下的长度不就是iov_len减去len马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len); <span class="comment">// 更新写缓冲区读指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>); <span class="comment">// ET模式或数据量大时循环写 这里同样理解一下为什么T模式要一次性写完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理HTTP请求生成响应</span></span><br><span class="line"><span class="comment"> * @return 处理是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    request_.<span class="built_in">Init</span>();    <span class="comment">// 初始化请求对象</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 无数据可处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))&#123;     <span class="comment">// 解析请求（成功则生成200响应，失败400）</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成响应到写缓冲区</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_); <span class="comment">// 生成响应报文放入writeBuff_中</span></span><br><span class="line">    <span class="comment">// 设置iov[0]指向响应头数据</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;  <span class="comment">// 默认只有响应头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在内存映射文件（如请求的文件），设置iov[1]</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>先说一下为什么要有这个，有些socket连接很长事件不进行操作，还白白占用一个连接，这就很不合理，因此设置一个计时器，当超过一定时间之后就断开连接</p>
<p>通过小顶堆来实现，放在最前面的永远是最早就要超时的，对于超时的就调用回调函数来处理（一般情况下这里的回调函数就是断开连接了）</p>
<p>时钟操作，小根堆的实现，小根堆的下沉与上浮，小根堆的删除与添加</p>
<p>下面是代码：（务必注意一下回调函数是怎么搞的以及回调函数是什么时候调用的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义超时回调函数类型</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="comment">// 使用高精度时钟</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;</span><br><span class="line"><span class="comment">// 毫秒时间单位</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;</span><br><span class="line"><span class="comment">// 时间点类型</span></span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;             <span class="comment">// 节点唯一标识</span></span><br><span class="line">    TimeStamp expires;  <span class="comment">// 超时的时间点</span></span><br><span class="line">    TimeoutCallBack cb; <span class="comment">// 回调function&lt;void()&gt;</span></span><br><span class="line">    <span class="comment">// 重载小于运算符，用于比较两个节点的超时时间</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;    <span class="comment">// 重载比较运算符</span></span><br><span class="line">        <span class="keyword">return</span> expires &lt; t.expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载大于运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> TimerNode&amp; t) &#123;    <span class="comment">// 重载比较运算符</span></span><br><span class="line">        <span class="keyword">return</span> expires &gt; t.expires;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆定时器类（最小堆实现）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;TimerNode&gt; heap_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;   <span class="comment">// id对应的在heap_中的下标，方便用heap_的时候查找</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;                    <span class="comment">// 删除指定位置的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;                 <span class="comment">// 将节点上浮以维护堆结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> n)</span></span>;     <span class="comment">// 将节点下沉，返回是否进行了下沉</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;     <span class="comment">// 交换两个节点的位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;      <span class="comment">// 预分配空间以减少扩容开销</span></span><br><span class="line">    ~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;    <span class="comment">// 调整指定id节点的超时时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span></span>;     <span class="comment">// 添加新节点或更新已有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;                    <span class="comment">// 执行指定id节点的回调并删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                           <span class="comment">// 清空所有节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;                            <span class="comment">// 心跳，很重要很重要！！！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                             <span class="comment">// 删除堆顶节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;                      <span class="comment">// 获取下一个即将超时节点的剩余时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAP_TIMER_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个节点的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt;heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt;heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">swap</span>(heap_[i], heap_[j]);</span><br><span class="line">    <span class="comment">// 更新交换后的id索引映射</span></span><br><span class="line">    ref_[heap_[i].id] = i;    <span class="comment">// 结点内部id所在索引位置也要变化</span></span><br><span class="line">    ref_[heap_[j].id] = j;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> parent = (i<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">// 父节点下标计算</span></span><br><span class="line">    <span class="keyword">while</span>(parent &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[parent] &gt; heap_[i])&#123;  <span class="comment">//如果父节点比较大，那么就交换一下，让现在的节点上浮</span></span><br><span class="line">            <span class="built_in">SwapNode_</span>(i, parent);</span><br><span class="line">            i = parent;</span><br><span class="line">            parent = (i<span class="number">-1</span>)/<span class="number">2</span>;          <span class="comment">//继续判断需不需要上浮动</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉调整</span></span><br><span class="line"><span class="comment">// false：不需要下滑  true：下滑成功</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());    <span class="comment">// n:共几个结点</span></span><br><span class="line">    <span class="keyword">auto</span> index = i;</span><br><span class="line">    <span class="keyword">auto</span> child = <span class="number">2</span> * index + <span class="number">1</span>;             <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 选择较小的子节点 child+1为右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(child<span class="number">+1</span> &lt; n &amp;&amp; heap_[child<span class="number">+1</span>] &lt; heap_[child]) &#123;</span><br><span class="line">            child++;<span class="comment">//右子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap_[child] &lt; heap_[index]) &#123; <span class="comment">//当前节点比子结点要大，则需要下沉</span></span><br><span class="line">            <span class="built_in">SwapNode_</span>(index, child);</span><br><span class="line">            index = child;</span><br><span class="line">            child = <span class="number">2</span> * child + <span class="number">1</span>;        <span class="comment">//继续看孩子节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 需要跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index &gt; i; <span class="comment">//说明有下沉，如果index == i 便是没有变动 不需要下沉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 将要删除的结点换到队尾，然后调整堆</span></span><br><span class="line">    <span class="type">size_t</span> tmp = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">assert</span>(tmp &lt;= n);</span><br><span class="line">    <span class="comment">// 如果就在队尾，就不用移动了,反之就需要交换了</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; heap_.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(tmp, heap_.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 尝试下沉新节点</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(tmp, n))&#123;</span><br><span class="line">            <span class="built_in">siftup_</span>(tmp); <span class="comment">// 若不需要下沉则尝试上浮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除末尾节点</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整指定id的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id));</span><br><span class="line">    heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(newExpires);</span><br><span class="line">    <span class="comment">// 同理，修改完之后要调整堆</span></span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">        <span class="built_in">siftup_</span>(i);  <span class="comment">// 若不需要下沉则尝试上浮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新节点或者调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有，则调整</span></span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id))&#123;</span><br><span class="line">        <span class="type">int</span> tmp = ref_[id];</span><br><span class="line">        heap_[tmp].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeOut);</span><br><span class="line">        heap_[tmp].cb = cb;</span><br><span class="line">        <span class="comment">//同理，修改完之后要调整堆</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(tmp, heap_.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="built_in">siftup_</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = n;</span><br><span class="line">        <span class="comment">// 这里应该算是结构体的默认构造</span></span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeOut), cb&#125;);  <span class="comment">// 右值</span></span><br><span class="line">        <span class="built_in">siftup_</span>(n);  <span class="comment">// 上浮新节点 因为已经是在最后了，不需要下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定id，并触发回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123; <span class="comment">//heap_是空的或者id不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    <span class="keyword">auto</span> node = heap_[i];</span><br><span class="line">    node.<span class="built_in">cb</span>();  <span class="comment">// 触发回调函数</span></span><br><span class="line">    <span class="built_in">del_</span>(i);    <span class="comment">// 删除节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有超时节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环检查堆顶节点</span></span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();  <span class="comment">//取堆顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;   <span class="comment">// 未超时则停止</span></span><br><span class="line">        node.<span class="built_in">cb</span>(); <span class="comment">// 执行超时回调</span></span><br><span class="line">        <span class="built_in">pop</span>();     <span class="comment">// 删除堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除堆顶节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个超时时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">tick</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 计算堆顶节点的剩余时间</span></span><br><span class="line">        res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; res = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>这里就是最后把所有的模块综合在一起的地方了</p>
<h3 id="epoller"><a href="#epoller" class="headerlink" title="epoller"></a>epoller</h3><p>这里要注意IO多路复用的概念</p>
<p>我在 <a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a> 做了一些基本的介绍</p>
<p>这里就说一下为什么要有这个技术</p>
<ul>
<li>socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。</li>
<li>有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程</li>
<li>而且每一次切换线程 可能会需要 进行上下文操作，这就会很大的限制运行速度</li>
</ul>
<p>因此引入了IO多路复用的技术，相当于咱们把咱们的socket连接之后的文件描述符交给epoll托管，每当有事件发生的时候，epoll就会向咱们发送通知，咱们可以获取那些发生事件的fd，从而执行操作。</p>
<p>（这里还是建议先学习一下IO多路复用的概念，以及epoll的基本操作，学习完之后就会发现这个epoller特别简单，就是把epoll的命令封装一下）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：创建 epoll 实例并初始化事件数组</span></span><br><span class="line">    <span class="comment">// 参数 maxEvent: 预分配的事件数组大小（默认 1024）</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 析构函数：关闭 epoll 文件描述符</span></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加文件描述符到 epoll 实例的监控列表中</span></span><br><span class="line">    <span class="comment">// 参数 fd: 要监控的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 events: 监控的事件类型（如 EPOLLIN、EPOLLOUT、EPOLLET 等）</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功（true 成功，false 失败）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改已监控文件描述符的事件类型</span></span><br><span class="line">    <span class="comment">// 参数 fd: 已监控的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 events: 新的事件类型</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 epoll 实例中删除文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 fd: 要删除的文件描述符</span></span><br><span class="line">    <span class="comment">// 返回值: 操作是否成功</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件就绪（核心函数）</span></span><br><span class="line">    <span class="comment">// 参数 timeoutMs: 超时时间（毫秒，-1 表示阻塞等待）</span></span><br><span class="line">    <span class="comment">// 返回值: 就绪的事件数量（出错时返回 -1）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第 i 个就绪事件对应的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 i: 事件数组的索引</span></span><br><span class="line">    <span class="comment">// 返回值: 文件描述符（需确保 i 在有效范围内）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第 i 个就绪事件的事件类型</span></span><br><span class="line">    <span class="comment">// 参数 i: 事件数组的索引</span></span><br><span class="line">    <span class="comment">// 返回值: 事件类型（如 EPOLLIN、EPOLLOUT 等）</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;   <span class="comment">// epoll 实例的文件描述符</span></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;   <span class="comment">// 存储就绪事件的数组 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="comment">// 参数 maxEvent: 预分配事件数组的大小</span></span><br><span class="line"><span class="comment">// 创建 epoll 实例，参数 512 是历史遗留值（内核自动调整） 现在可以使用epoll_create1(0) 来创建</span></span><br><span class="line"><span class="comment">// 初始化事件数组大小为 maxEvent</span></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;</span><br><span class="line">    <span class="comment">// 断言检查：确保 epoll 实例创建成功且事件数组非空</span></span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);  <span class="comment">// 关闭 epoll 文件描述符，释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文件描述符到 epoll 监控列表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;     <span class="comment">// 初始化事件结构体（清零防止脏数据）</span></span><br><span class="line">    ev.data.fd = fd;          <span class="comment">// 关联目标文件描述符</span></span><br><span class="line">    ev.events = events;       <span class="comment">// 设置监控的事件类型</span></span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 添加监控（EPOLL_CTL_ADD 模式）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改已监控文件描述符的事件类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 修改事件（EPOLL_CTL_MOD 模式）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 epoll 监控列表中删除文件描述符</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 检查文件描述符有效性</span></span><br><span class="line">    <span class="comment">// 调用 epoll_ctl 删除监控（EPOLL_CTL_DEL 模式，最后一个参数可忽略）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回事件数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 epoll_wait 获取就绪事件</span></span><br><span class="line">    <span class="comment">// 参数 1: epoll 实例的文件描述符</span></span><br><span class="line">    <span class="comment">// 参数 2: 事件数组首地址（底层数组需连续，vector 保证这一点）</span></span><br><span class="line">    <span class="comment">// 参数 3: 最多返回的事件数（设为数组大小避免溢出）</span></span><br><span class="line">    <span class="comment">// 参数 4: 超时时间（-1 表示无限等待）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">    <span class="comment">// 返回值:</span></span><br><span class="line">    <span class="comment">// - 正数: 就绪事件数</span></span><br><span class="line">    <span class="comment">// - 0: 超时无事件</span></span><br><span class="line">    <span class="comment">// - -1: 出错（需检查 errno）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件的fd // 获取第 i 个事件关联的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言确保索引 i 在合法范围内（注意实际就绪事件数可能小于数组大小）</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件属性 // 获取第 i 个事件的事件类型</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h3><p>最后的所有模块的封装，前面咱们已经把所有的功能实现了，这里就吧前面所有的功能组合在一起，拼接成咱们的服务器。</p>
<p>初始化任务：</p>
<ul>
<li>初始化日志系统（log模块）</li>
<li>初始化数据库连接池 （pool&#x2F;sqlconnpool模块）</li>
<li>辅助功能的初始化（HeapTimer，ThreadPool，Epoller）</li>
<li>开启服务器，socket套接字创建，绑定，监听</li>
<li>获取资源的位置(resources文件夹的位置)</li>
</ul>
<p>服务器运行的函数（Start函数流程，也就是那个主循环的流程）</p>
<ul>
<li>开始的时候先让timer tick一下并获取下一次超时的时间，tick会这里就是处理那些长时间不干活的client</li>
<li>调用epoller的Wait，设置超时事件为上面获取的下一次超时的时间（这里挺巧妙的，可以想一下为啥）</li>
<li>后面正常执行的话，就会获取那些就绪client的fd，然后分事件执行就好<ul>
<li>如果是服务器收到消息，那么一定是来新的连接了 那么 accept 一下，添加新客户就好</li>
<li>如果是异常事件就直接断开连接就好</li>
<li>如果是读事件就 为线程池添加读任务，线程池会自动分配线程来执行读任务</li>
<li>如果是写事件就 为线程池添加读任务，线程池会自动分配线程来执行写任务</li>
</ul>
</li>
</ul>
<p>这里要注意读写的整体的过程，也就是webserver设计的核心：</p>
<p>（这段来源于 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51322383/article/details/130545172">https://blog.csdn.net/weixin_51322383/article/details/130545172</a> ）</p>
<p>浏览器向服务器发出request的时候，epoll会接收到EPOLL_IN读事件，此时调用OnRead去解析，将fd(浏览器)的request内容放到读缓冲区，并且把响应报文写到写缓冲区，这个时候调用OnProcess()是为了把该事件变为EPOLL_OUT，让epoll下一次检测到写事件，把写缓冲区的内容写到fd。当EPOLL_OUT写完后，整个流程就结束了，此时需要再次把他置回原来的EPOLL_IN去检测新的读事件到来。</p>
<p>理解了这段话就理解了整个webserver的设计</p>
<p>这里我还是想再解释解释epoll的机制，虽然在 <a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/2025/04/15/chatRoom/">https://blog.zqzhang2025.com/2025/04/15/chatRoom/</a> 里面已经解释过了，这里就当成补充吧。</p>
<p>1.socket收发信息</p>
<ul>
<li>这个大家应该都知道，我再废话说一遍</li>
<li>对于socket中的recv和send 这些函数，都有响应的缓冲区</li>
<li>比如：recv，外面的数据来了，会先放在内核之中的读缓冲区里面，然后咱们调用recv才能拿到数据</li>
<li>相应的send的时候，咱们会把数据发送到内核的写缓冲区里面，然后内核会调用网络操作把东西给发出去</li>
</ul>
<p>2.epoll的触发</p>
<p>前面也提到了epoll的触发有两种模式：水平触发（LT）与边缘触发（ET）这里就详细的解释一下怎么触发的</p>
<ul>
<li>水平触发（LT）<ul>
<li>对于读（EPOLLIN）事件：当内核之中的读缓冲区存在数据的时候，就会一直触发，就是不停的向用户通知，还有东西可以读。</li>
<li>对于写（EPOLLOUT）事件：当内核之中的写缓冲区还可以写，也就是说写缓冲区还没满的时候就会不停的触发</li>
<li>所以对于LT，并不会要求一次必须要把事情处理完，比如读的话，如果这次没读完，下次还可以继续读，因为epoll会一直通知我们读事件</li>
</ul>
</li>
<li>边缘触发（ET）<ul>
<li>对于读（EPOLLIN）事件：内核之中的读缓冲区状态变化的时候才会触发，比如：有新的数据来了，就会触发一次，但也只会触发这一次，如果这次你读不完数据也没办法，后续也不会触发。</li>
<li>对于写（EPOLLOUT）事件：内核之中的写缓冲区状态变化的时候才会触发，这个状态变化指的是 不可写-&gt;可写，就是缓冲区满-&gt;缓冲区不满。如果缓冲区满了的话会出现errno事件，事件为EAGAIN。</li>
<li>对于写（EPOLLOUT）事件：还有另外一种情况，就是第一次绑定EPOLLOUT事件的时候会触发，这个时候写缓冲区肯定是可写的，因此先触发一次，让用户先写。</li>
</ul>
</li>
</ul>
<p>这样的话就很好理解了吧</p>
<p>再把上面那句话拷贝下来看一看，是不是就理解了</p>
<p>浏览器向服务器发出request的时候，epoll会接收到EPOLL_IN读事件，此时调用OnRead去解析，将fd(浏览器)的request内容放到读缓冲区（这里不是内核里面的哈，指的是咱们写的那个buffer），并且把响应报文写到写缓冲区这里不是内核里面的哈，指的是咱们写的那个buffer），这个时候调用OnProcess()是为了把该事件变为EPOLL_OUT，让epoll下一次检测到写事件，把写缓冲区的内容写到fd。当EPOLL_OUT写完后，整个流程就结束了，此时需要再次把他置回原来的EPOLL_IN去检测新的读事件到来。</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>       <span class="comment">//  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连接相关成员</span></span><br><span class="line">    <span class="type">int</span> fd_;                      <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_;     <span class="comment">// 客户端地址结构</span></span><br><span class="line">    <span class="type">bool</span> isClose_;                <span class="comment">// 连接是否已关闭标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作相关</span></span><br><span class="line">    <span class="type">int</span> iovCnt_;                  <span class="comment">// iov数组有效元素个数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];         <span class="comment">// 分散写结构数组</span></span><br><span class="line">    Buffer readBuff_;             <span class="comment">// 读缓冲区    读缓冲区（存储客户端请求数据）</span></span><br><span class="line">    Buffer writeBuff_;            <span class="comment">// 写缓冲区    写缓冲区（存储生成的响应头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP处理对象</span></span><br><span class="line">    HttpRequest request_;         <span class="comment">// HTTP请求解析器</span></span><br><span class="line">    HttpResponse response_;       <span class="comment">// HTTP响应生成器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 &amp; 析构函数</span></span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心接口方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                   <span class="comment">// 从socket读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;                  <span class="comment">// 向socket写入数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                                   <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;                              <span class="comment">// 获取文件描述符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;                            <span class="comment">// 获取客户端端口</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;                      <span class="comment">// 获取客户端IP字符串</span></span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;                    <span class="comment">// 获取客户端地址结构</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;                                 <span class="comment">// 处理HTTP请求生成响应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写的总长度              // 计算待发送数据总长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否保持连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员（类级别共享）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;                    <span class="comment">// 标记是否使用ET（边沿触发）模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;           <span class="comment">// 服务器资源目录路径</span></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;   <span class="comment">// 原子计数器，记录当前连接数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;         <span class="comment">// 资源目录路径（由外部设置）</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount; <span class="comment">// 原子连接计数器初始化为0</span></span><br><span class="line"><span class="type">bool</span> HttpConn::isET;                  <span class="comment">// ET模式标记（默认false，需外部设置）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;                <span class="comment">// 初始无效文件描述符</span></span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;           <span class="comment">// 清空地址结构</span></span><br><span class="line">    isClose_ = <span class="literal">true</span>;         <span class="comment">// 初始为关闭状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>();                 <span class="comment">// 确保连接关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化新连接</span></span><br><span class="line"><span class="comment"> * @param fd 客户端socket描述符</span></span><br><span class="line"><span class="comment"> * @param addr 客户端地址结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);        <span class="comment">// 确保有效fd</span></span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();  <span class="comment">// 清空写缓冲区</span></span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();   <span class="comment">// 清空读缓冲区</span></span><br><span class="line">    isClose_ = <span class="literal">false</span>;          <span class="comment">// 标记为打开状态</span></span><br><span class="line">    <span class="comment">// 记录日志：客户端IP、端口和当前连接数</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();     <span class="comment">// 释放内存映射文件（如果有）</span></span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>;      <span class="comment">// 标记为已关闭</span></span><br><span class="line">        userCount--;          <span class="comment">// 连接数-1</span></span><br><span class="line">        <span class="built_in">close</span>(fd_);           <span class="comment">// 关闭socket</span></span><br><span class="line">        <span class="comment">// 记录客户端退出日志</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取客户端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端IP字符串（点分十进制）</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);  <span class="comment">//还有记得大端转小端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取客户端端口号（网络字节序）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取数据到读缓冲区</span></span><br><span class="line"><span class="comment"> * @param saveErrno 用于保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 读取的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 使用Buffer的ReadFd读取数据到读缓冲区</span></span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 出错或读完了,关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET); <span class="comment">// ET模式需一次性读完所有数据 //这里要理解一下为什么ET模式要一次性读完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写数据到socket（使用writev聚合写）</span></span><br><span class="line"><span class="comment"> * @param saveErrno 保存错误码的输出参数</span></span><br><span class="line"><span class="comment"> * @return 写入的字节数（-1表示错误）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_,iov_,iovCnt_); <span class="comment">// writev将iov数组内容写入socket</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数据是否全部写完</span></span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 传输结束 */</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len)&#123;  <span class="comment">// 处理部分写入情况（先写iov[0]响应头，再写iov[1]文件内容）</span></span><br><span class="line">            <span class="comment">// 这里详细解释一下,很容易搞不懂(先看下面那个else)</span></span><br><span class="line">            <span class="comment">// OK 这里仿照 下面那个else就好理解了</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len); <span class="comment">// iov_[0]已写完，调整iov_[1]的指针和长度</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="comment">// 但是着一块又难理解了</span></span><br><span class="line">            <span class="comment">// 首先咱们要知道一点 writeBuff_ 里面存储的是响应头部分,刚开始被赋予了iov_[0].iov_base,因此当iov_[0]写完了那么writeBuff_就没有用了,就清空一下就好了</span></span><br><span class="line">            <span class="comment">// 我们主要理解一下为什么到这个位置了iov_[0].iov_len还不为0</span></span><br><span class="line">            <span class="comment">// 举个例子好理解,比如原始的iov_[0].iov_len = 100 原始的iov_[1].iov_len = 1000 那么第一次写的时候len为200,那么是不是就理解了,这个时候不会进入下面那个else,只会进入这个,因此我们需要处理iov_[0]</span></span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;</span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>(); <span class="comment">// 清空写缓冲区</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;      <span class="comment">// iov_[0]长度置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// iov_[0]未写完，调整其指针和长度</span></span><br><span class="line">            <span class="comment">// 里详细解释一下,很容易搞不懂</span></span><br><span class="line">            <span class="comment">// 写的时候总得知道写的其实地址和写的总长度把</span></span><br><span class="line">            <span class="comment">// 刚开始第一个缓冲区的起始地址是 iov_[0].iov_base 和 长度是 iov_[0].iov_len  这个没的说</span></span><br><span class="line">            <span class="comment">// 到这里表示前面的 len = writev(fd_,iov_,iovCnt_);  正常执行了,并且已经写进入len这么多了,而且len要小于iov_[0].iov_len表示iov_[0]还没写完</span></span><br><span class="line">            <span class="comment">// 这个时候就需要调整一下后面写的其实地址和写的总长度了</span></span><br><span class="line">            <span class="comment">// 那么后面就好理解了 起始地址不就是 iov_base往后移动 len 个位置马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len; </span><br><span class="line">            <span class="comment">// 剩下的长度不就是iov_len减去len马</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len); <span class="comment">// 更新写缓冲区读指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>); <span class="comment">// ET模式或数据量大时循环写 这里同样理解一下为什么T模式要一次性写完</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理HTTP请求生成响应</span></span><br><span class="line"><span class="comment"> * @return 处理是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    request_.<span class="built_in">Init</span>();    <span class="comment">// 初始化请求对象</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 无数据可处理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_))&#123;     <span class="comment">// 解析请求（成功则生成200响应，失败400）</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成响应到写缓冲区</span></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_); <span class="comment">// 生成响应报文放入writeBuff_中</span></span><br><span class="line">    <span class="comment">// 设置iov[0]指向响应头数据</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">    iovCnt_ = <span class="number">1</span>;  <span class="comment">// 默认只有响应头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在内存映射文件（如请求的文件），设置iov[1]</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="github链接"><a href="#github链接" class="headerlink" title="github链接"></a>github链接</h1><p>我平时比较喜欢用cmake，感觉这个比较方便一些，因此就整了两个版本，一个是cmake版本一个是makefile版本（原来的是makefile版本）</p>
<p>cmake 版本运行：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_tinyWebServer</a></p>
<p>（刚开始记得先把build里面东西给删除掉）</p>
<p>cd build</p>
<p>cmake ..</p>
<p>make</p>
<p>cd ..&#x2F;</p>
<p>sudo .&#x2F;main</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1:1316/">http://127.0.0.1:1316/</a></p>
<p>makefile版本：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile">https://github.com/zqzhang2023/zzqStudy/tree/main/project/5_TinyWebServer_makefile</a></p>
<p>make</p>
<p>sudo ..&#x2F;bin&#x2F;server</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51322383/article/details/130464403">https://blog.csdn.net/weixin_51322383/article/details/130464403</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44184756/article/details/130140778">https://blog.csdn.net/qq_44184756/article/details/130140778</a></p>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>我自己的学习用的github仓库：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy">https://github.com/zqzhang2023/zzqStudy</a></p>
<p>我的个人博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.zqzhang2025.com/">https://blog.zqzhang2025.com/</a></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>里面有很多都是我自己的理解，作为初学者，文章里面肯定会有一些错误。大家看的时候记得加上自己的理解去看，如果发现我那里理解有问题，非常欢迎大家能够指出来，咱们共同进步。非常感谢大家。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张振强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/15/tinyWebServer/">http://example.com/2025/04/15/tinyWebServer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">张振强的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/15/chatRoom/" title="chatRoom"><img class="cover" src="/img/load4.gif" data-original="/img/cover/9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">chatRoom</div></div><div class="info-2"><div class="info-item-1">chatRoom 项目git:https://github.com/zqzhang2023/zzqStudy 简单介绍：socket的简单应用，简单来说，就是一个服务端：server 许多个客户端：client1 client2 client3 client4… 现在要把这么多客户端拉到一个聊天室里面，实现群聊通信 实现方式：其实思想很简单，就是 client_i 向 server发送消息，然后server接收到消息之后，把消息转发给除却 client_i 之外的所有的 客户 这里主要学习 I&#x2F;O多路复用技术 之前学习的基础的 socket 是客户端 服务器 一对一的，现在需要服务器接收多个客户端的连接，因此需要用到 I&#x2F;O多路复用技术 I&#x2F;O多路复用技术为什么使用socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。 有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程 而且每一次切换线程...</div></div></div></a><a class="pagination-related" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img class="cover" src="/img/load4.gif" data-original="/img/cover/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ffmpeg</div></div><div class="info-2"><div class="info-item-1">C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/13/ThreadPool/" title="ThreadPool"><img class="cover" src="/img/load4.gif" data-original="/img/cover/9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">ThreadPool</div></div><div class="info-2"><div class="info-item-1">线程池项目基本概念线程池的概念： 线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。 说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程 那么我们就可以想到一个线程池的最基础的构造 变量：  一个vector 用来存储构造好的线程 一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 ) mutex  有了queue自然得考虑到互斥的问题 condition_variable 条件变量 同mutex理 flag   停止标识  函数：  首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数) 其次得有线程的释放join 的函数  （此处可以使用类的析构函数） 还有得有添加任务的函数  ThreadPool声明通过前面描述来声明一下CLASS class ThreadPool&#123;private:    std::vector&lt;std::thread&gt; workers;        // 工作线程集合   ...</div></div></div></a><a class="pagination-related" href="/2025/04/15/chatRoom/" title="chatRoom"><img class="cover" src="/img/load4.gif" data-original="/img/cover/9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">chatRoom</div></div><div class="info-2"><div class="info-item-1">chatRoom 项目git:https://github.com/zqzhang2023/zzqStudy 简单介绍：socket的简单应用，简单来说，就是一个服务端：server 许多个客户端：client1 client2 client3 client4… 现在要把这么多客户端拉到一个聊天室里面，实现群聊通信 实现方式：其实思想很简单，就是 client_i 向 server发送消息，然后server接收到消息之后，把消息转发给除却 client_i 之外的所有的 客户 这里主要学习 I&#x2F;O多路复用技术 之前学习的基础的 socket 是客户端 服务器 一对一的，现在需要服务器接收多个客户端的连接，因此需要用到 I&#x2F;O多路复用技术 I&#x2F;O多路复用技术为什么使用socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。 有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程 而且每一次切换线程...</div></div></div></a><a class="pagination-related" href="/2025/04/13/tinyhttpd/" title="Tinyhttpd"><img class="cover" src="/img/load4.gif" data-original="/img/cover/11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">Tinyhttpd</div></div><div class="info-2"><div class="info-item-1">tinyhttpd 项目写在前面：这个项目是  J. David 大佬 在1999年做出来的，虽然很老旧, 而且手打一遍之后也感觉有些地方可能不适合这么写，但是做完这个项目之后学到的东西有很多很多，如果大家有时间的话，不妨跟着做一做，相信一定会有很大的收获 膜拜大佬！！！ GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 我这边加上注释的代码： 运行起来做之前需要先确定自己的环境能够正常把项目运行起来，要不然做的过程之中不知道是自己代码的问题还是环境的问题 我用的Linux ubuntu 提前安装了perl 地址在 &#x2F;usr&#x2F;bin&#x2F;perl(这个可以通过 which perl 命令得到) GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 1.克隆下来，解压 这个不必对多说 2.执行make命令  会生成 httpd 与 client (会有一些警告，不必在意)  3.执行httpd(.&#x2F;httpd)  这个时候浏览器输入...</div></div></div></a><a class="pagination-related" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img class="cover" src="/img/load4.gif" data-original="/img/cover/11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">ffmpeg</div></div><div class="info-2"><div class="info-item-1">C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++...</div></div></div></a><a class="pagination-related" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img class="cover" src="/img/load4.gif" data-original="/img/cover/4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-07</div><div class="info-item-2">基于IPV4的流媒体广播</div></div><div class="info-2"><div class="info-item-1">基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃） 运行起来原项目git：https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4 环境: Ubuntu 20.04...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张振强</div><div class="author-info-description">咱们都是最棒的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zqzhang2023"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zqzhang2023" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_45769058" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1611379529&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:bzzhenqiang@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#tinyWebServer-%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">tinyWebServer 项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8C"><span class="toc-number">3.</span> <span class="toc-text">快速运行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">项目文件作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">项目复现流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">项目复现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer"><span class="toc-number">6.1.</span> <span class="toc-text">buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log"><span class="toc-number">6.2.</span> <span class="toc-text">log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blockqueue"><span class="toc-number">6.2.1.</span> <span class="toc-text">blockqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pool"><span class="toc-number">6.3.</span> <span class="toc-text">pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpool"><span class="toc-number">6.3.1.</span> <span class="toc-text">threadpool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sqlconnpool"><span class="toc-number">6.3.2.</span> <span class="toc-text">sqlconnpool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http"><span class="toc-number">6.4.</span> <span class="toc-text">http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#httprequest"><span class="toc-number">6.4.1.</span> <span class="toc-text">httprequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#httpresponse"><span class="toc-number">6.4.2.</span> <span class="toc-text">httpresponse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#httpconn"><span class="toc-number">6.4.3.</span> <span class="toc-text">httpconn</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#timer"><span class="toc-number">6.5.</span> <span class="toc-text">timer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#server"><span class="toc-number">6.6.</span> <span class="toc-text">server</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoller"><span class="toc-number">6.6.1.</span> <span class="toc-text">epoller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webserver"><span class="toc-number">6.6.2.</span> <span class="toc-text">webserver</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#github%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">github链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">参考：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">友情链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number">10.</span> <span class="toc-text">结束</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/muduo/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/07/17/muduo/" title="chatRoom">chatRoom</a><time datetime="2025-07-17T02:05:26.162Z" title="发表于 2025-07-17 10:05:26">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img src="/img/load4.gif" data-original="/img/cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于IPV4的流媒体广播"/></a><div class="content"><a class="title" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播">基于IPV4的流媒体广播</a><time datetime="2025-05-07T09:43:42.756Z" title="发表于 2025-05-07 17:43:42">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img src="/img/load4.gif" data-original="/img/cover/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ffmpeg"/></a><div class="content"><a class="title" href="/2025/04/17/ffmpeg/" title="ffmpeg">ffmpeg</a><time datetime="2025-04-17T14:51:36.000Z" title="发表于 2025-04-17 22:51:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img src="/img/load4.gif" data-original="/img/cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tinyWebServer"/></a><div class="content"><a class="title" href="/2025/04/15/tinyWebServer/" title="tinyWebServer">tinyWebServer</a><time datetime="2025-04-15T14:58:54.000Z" title="发表于 2025-04-15 22:58:54">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/chatRoom/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/04/15/chatRoom/" title="chatRoom">chatRoom</a><time datetime="2025-04-15T14:57:54.000Z" title="发表于 2025-04-15 22:57:54">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 张振强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>