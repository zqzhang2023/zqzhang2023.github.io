<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>My New Post | 张振强的个人博客</title><meta name="author" content="张振强"><meta name="copyright" content="张振强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程池项目基本概念线程池的概念： 线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。 说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程 那么我们就可以想到一个线程池的最基础的构造 变量：  一个vector 用来存储构造好的线程 一个queue 用来存储task (利用">
<meta property="og:type" content="article">
<meta property="og:title" content="My New Post">
<meta property="og:url" content="http://example.com/2025/04/13/My-New-Post/index.html">
<meta property="og:site_name" content="张振强的个人博客">
<meta property="og:description" content="线程池项目基本概念线程池的概念： 线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。 说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程 那么我们就可以想到一个线程池的最基础的构造 变量：  一个vector 用来存储构造好的线程 一个queue 用来存储task (利用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-12T16:09:22.000Z">
<meta property="article:modified_time" content="2025-04-12T16:09:47.737Z">
<meta property="article:author" content="张振强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "My New Post",
  "url": "http://example.com/2025/04/13/My-New-Post/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-04-12T16:09:22.000Z",
  "dateModified": "2025-04-12T16:09:47.737Z",
  "author": [
    {
      "@type": "Person",
      "name": "张振强",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/13/My-New-Post/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'My New Post',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> 搜索</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">张振强的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">My New Post</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/search/"><i class="fa-fw fas fa-search"></i><span> 搜索</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">My New Post</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-12T16:09:22.000Z" title="发表于 2025-04-13 00:09:22">2025-04-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-12T16:09:47.737Z" title="更新于 2025-04-13 00:09:47">2025-04-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="线程池项目"><a href="#线程池项目" class="headerlink" title="线程池项目"></a>线程池项目</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>线程池的概念：</p>
<p>线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。</p>
<p>说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程</p>
<p>那么我们就可以想到一个线程池的最基础的构造</p>
<p>变量：</p>
<ul>
<li>一个vector 用来存储构造好的线程</li>
<li>一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 )</li>
<li>mutex  有了queue自然得考虑到互斥的问题</li>
<li>condition_variable 条件变量 同mutex理</li>
<li>flag   停止标识</li>
</ul>
<p>函数：</p>
<ul>
<li>首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数)</li>
<li>其次得有线程的释放join 的函数  （此处可以使用类的析构函数）</li>
<li>还有得有添加任务的函数</li>
</ul>
<h2 id="ThreadPool声明"><a href="#ThreadPool声明" class="headerlink" title="ThreadPool声明"></a>ThreadPool声明</h2><p>通过前面描述来声明一下CLASS</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;        <span class="comment">// 工作线程集合</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列（存储无参void函数）</span></span><br><span class="line">    std::mutex queue_mutex;                  <span class="comment">// 保护任务队列的互斥锁</span></span><br><span class="line">    std::condition_variable condition;       <span class="comment">// 线程间通信的条件变量</span></span><br><span class="line">    <span class="type">bool</span> stop;                               <span class="comment">// 停止标志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span>); <span class="comment">// 构造函数，参数为线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>; <span class="comment">// 任务入队方法</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>(); <span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里其他的都比较好理解，主要是enqueue函数难以理解，这个先放一放，后面再详细解释</p>
<h2 id="ThreadPool构造函数，初始化函数的实现"><a href="#ThreadPool构造函数，初始化函数的实现" class="headerlink" title="ThreadPool构造函数，初始化函数的实现"></a>ThreadPool构造函数，初始化函数的实现</h2><p>这个其实没啥说的，很常规的东西</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="type">size_t</span> threadsNum)</span>:stop(false)&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;threadsNum; i++)&#123;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>( <span class="comment">// 创建线程并绑定到Lambda</span></span><br><span class="line">            [<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;      <span class="comment">// 无限循环，直到线程池停止</span></span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;condition.<span class="built_in">wait</span>(lock,[<span class="keyword">this</span>]&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop||!<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();</span><br><span class="line">                        &#125;);<span class="comment">// 等待任务或停止信号（如果任务列表为空或者是stop为true的话，就会一直等待）</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                           <span class="keyword">return</span>;   <span class="comment">// 停止且无任务时退出线程</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());  <span class="comment">//取任务</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125; <span class="comment">//这里会自动释放锁</span></span><br><span class="line">                    <span class="built_in">task</span>(); <span class="comment">//执行任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPool析构函数，函数的释放"><a href="#ThreadPool析构函数，函数的释放" class="headerlink" title="~ThreadPool析构函数，函数的释放"></a>~ThreadPool析构函数，函数的释放</h2><p>emmm 这个也常规</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;stop = <span class="literal">true</span>;  <span class="comment">// 设置停止标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    condition.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="keyword">for</span>(std::thread&amp; worker:<span class="keyword">this</span>-&gt;workers)&#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();      <span class="comment">// 等待所有线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="enqueue-添加任务功能的实现"><a href="#enqueue-添加任务功能的实现" class="headerlink" title="enqueue 添加任务功能的实现"></a>enqueue 添加任务功能的实现</h2><p>这里就是最为复杂的地方，本来也是挺常规的，正常的传入（无参void函数）就行了，但是确实会出现问题，这样的话就只能处理 无参void函数 这一种类型了，这显然很有局限性。因此便有了这样一种书写方式</p>
<p>基本思想：将一个带参数的有返回值的函数，转化一下，转化为 无参void函数 就行了</p>
<p>先把代码发放上来，稍后一句一句分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看一下函数的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义的是一个模板，template &lt;class F, class… Args&gt;  两个参数</p>
<ul>
<li>class F：接受任意类型的可调用对象（函数、Lambda、函数对象等）。</li>
<li>class… Args：接受任意数量和类型的参数包。</li>
</ul>
<p>函数参数</p>
<ul>
<li>F&amp;&amp; f：万能引用（不是右值引用！），可以绑定到任意类型的可调用对象（左值或右值）。</li>
<li>Args&amp;&amp;… args：参数包的万能引用，保留参数的原始值类别（左值&#x2F;右值）。</li>
</ul>
<p>注意：这里的返回值是auto 是根据箭头后面的来推理出来的</p>
<ul>
<li>-&gt; std::future&lt;typename std::result_of&lt;F(Args…)&gt;::type&gt;</li>
<li>future用于异步获取进程的返回值</li>
<li>result_of获取函数 F(Args…) 的返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">    std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>packaged_task包装，这个下面解释，先解释一下bind函数</p>
<p>bind函数，这里使用的很巧妙</p>
<p>这里可以看一下bind的用法，这个挺重要的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p>
<p>这里就介绍一下bind在这里的用法</p>
<p>对于一个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print: x = &quot;</span> &lt;&lt; x </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y </span><br><span class="line">        &lt;&lt; <span class="string">&quot;, z = &quot;</span> &lt;&lt; z </span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是有三个参数的，x y z ，我们通过 bind 来做处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别由调用 f2 的第一，二个参数指定</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(fun_1, std::placeholders::_1, std::placeholders::_2, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样的话：绑定函数 fun 的第一，二，三个参数值为： 1 2 3</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(fun_1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); 	</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">f2</span>();     <span class="comment">//print: x=1,y=2,z=3 默认第三个参数为3</span></span><br></pre></td></tr></table></figure>
<p>这里的用法是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br></pre></td></tr></table></figure>
<p>实现了从有参到无参数的转化</p>
<p>继续:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure>

<p>这里解释一下上面说的 packaged_task </p>
<p>std::packaged_task&lt;return_type()&gt; 的核心目的是将任意函数 ​​包装成异步任务​​，并自动关联一个 std::future 用于获取结果。</p>
<ul>
<li>std::packaged_task&lt;return_type()&gt; task(func); &#x2F;&#x2F; 包装为 packaged_task<ul>
<li>此时，task 的签名是 return_type()，即调用 task() 会执行 func 并返回结果。</li>
<li>packaged_task 内部维护一个 ​​共享状态​​（shared state），当调用 task() 执行函数时：<ul>
<li>执行绑定的函数 func</li>
<li>将函数返回值存入共享状态</li>
<li>唤醒通过 future 等待该结果的线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么上面的语句 未执行就能获取 future</p>
<p>std::future<return_type> res &#x3D; task-&gt;get_future();</p>
<ul>
<li>future 是一个 ​​结果的占位符​​，它的有效性从 packaged_task 创建时就开始，与任务执行时机无关。调用 res.get() 时：<ul>
<li>若任务已执行：立即返回结果</li>
<li>若任务未执行：阻塞等待结果</li>
</ul>
</li>
</ul>
<p>为什么要用make_shared管理</p>
<p>auto task &#x3D; std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(…);</p>
<ul>
<li>确保 packaged_task 存活至任务被执行</li>
<li>不用手动释放(只能指针的妙用嘛)</li>
</ul>
<p>继续：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面不用多说，主要是最后一行</p>
<p>task经过之前的处理，已经相当于一个 函数指针 了，这里直接调用 (*task)() 他的返回值由 packaged_task 管理</p>
<p>我们整体来看：Lambda  表达式 <a href="">task</a> { (*task)(); } 就是一个无参数，无返回值的函数 因此 可以正常的 放到 this-&gt;tasks里面</p>
<p>继续：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<p>我们最后再整体看一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span> </span></span><br><span class="line"><span class="function">    -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 获取 F 用 Args... 调用后的返回类型。</span></span><br><span class="line">    <span class="keyword">using</span> return_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type;  <span class="comment">//若 F 是 int foo(double), Args 是 double，则 return_type 是 int。</span></span><br><span class="line">    <span class="comment">// 将用户任务转换为 return_type() 签名（无参数，返回 return_type）</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">return_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 packaged_task 中提取 future，用户可通过 res.get() 获取最终结果。</span></span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tasks.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);  <span class="comment">// 将任务包装为 void() 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒一个正在等待的 worker 线程来处理新任务。</span></span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整理流程：</p>
<ul>
<li>用户调用 enqueue​<ul>
<li>提交函数 f 和参数 args，要求返回 future。</li>
</ul>
</li>
<li>创建 packaged_task​<ul>
<li>将 f(args…) 绑定为 return_type() 类型的任务。</li>
</ul>
</li>
<li>获取 future​<ul>
<li>立即通过 task-&gt;get_future() 获取结果占位符。</li>
</ul>
</li>
<li>​​封装为 void() 任务​<ul>
<li>将任务包装为 <a href="">task</a>{ (*task)(); }，符合队列类型。</li>
</ul>
</li>
<li>​​任务入队与通知​<ul>
<li>唤醒线程池中的工作线程。</li>
</ul>
</li>
<li>​​任务执行​<ul>
<li>工作线程调用 (*task)()，执行用户函数并存储结果到共享状态。</li>
</ul>
</li>
<li>​​用户获取结果​<ul>
<li>用户通过 future.get() 等待或获取结果。</li>
</ul>
</li>
</ul>
<h2 id="main测试"><a href="#main测试" class="headerlink" title="main测试"></a>main测试</h2><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;include/threadPool.h&quot;
using namespace std;

int main()&#123;
    // 测试1：基本任务执行和返回值
    &#123;
        ThreadPool pool(2);
        auto future_add = pool.enqueue([](int a, int b) &#123;
            return a + b;
        &#125;, 2, 3);
        int result = future_add.get();
        std::cout &lt;&lt; &quot;Test 1: 2 + 3 = &quot; &lt;&lt; result &lt;&lt; std::endl;  // 预期输出5
    &#125;

    // 测试2：并行执行多个任务
    &#123;
        const int num_tasks = 8;
        ThreadPool pool(4);
        std::vector&lt;std::future&lt;int&gt;&gt; futures;
        
        for (int i = 0; i &lt; num_tasks; ++i) &#123;
            futures.emplace_back(pool.enqueue([i] &#123;
                std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟耗时操作
                return i * i;
            &#125;));
        &#125;

        std::cout &lt;&lt; &quot;Test 2: Results: &quot;;
        for (auto&amp; fut : futures) &#123;
            std::cout &lt;&lt; fut.get() &lt;&lt; &quot; &quot;;  // 预期输出0 1 4 9 16 25 36 49（顺序可能不同）
        &#125;
        std::cout &lt;&lt; &quot;\n&quot;;
    &#125;

    // 测试3：异常传播
    &#123;
        ThreadPool pool(2);
        auto future_exception = pool.enqueue([] &#123;
            throw std::runtime_error(&quot;Intentional exception&quot;);
            return 0;
        &#125;);

        try &#123;
            future_exception.get();
        &#125; catch (const std::exception&amp; e) &#123;
            std::cout &lt;&lt; &quot;Test 3: Caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        &#125;
    &#125;

    // 测试4：线程池自动回收（通过作用域生命周期）
    &#123;
        std::cout &lt;&lt; &quot;Test 4: Creating nested thread pool...&quot; &lt;&lt; std::endl;
        &#123;
            ThreadPool inner_pool(2);
            inner_pool.enqueue([] &#123;
                std::cout &lt;&lt; &quot;Task executed in inner pool&quot; &lt;&lt; std::endl;
            &#125;);
        &#125;  // 此处inner_pool析构，自动等待任务完成
        std::cout &lt;&lt; &quot;Inner pool destroyed&quot; &lt;&lt; std::endl;
    &#125;

    std::cout &lt;&lt; &quot;All tests completed successfully.&quot; &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p>cd build</p>
<p>cmake .. </p>
<p>make</p>
<p>.&#x2F;threadPool</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张振强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/13/My-New-Post/">http://example.com/2025/04/13/My-New-Post/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">张振强的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/12/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张振强</div><div class="author-info-description">咱们都是最棒的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">线程池项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPool%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">ThreadPool声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPool%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">ThreadPool构造函数，初始化函数的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPool%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">1.4.</span> <span class="toc-text">~ThreadPool析构函数，函数的释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enqueue-%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">enqueue 添加任务功能的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E6%B5%8B%E8%AF%95"><span class="toc-number">1.6.</span> <span class="toc-text">main测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/13/My-New-Post/" title="My New Post">My New Post</a><time datetime="2025-04-12T16:09:22.000Z" title="发表于 2025-04-13 00:09:22">2025-04-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/12/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-12T15:06:42.946Z" title="发表于 2025-04-12 23:06:42">2025-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 张振强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>