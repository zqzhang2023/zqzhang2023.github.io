<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ffmpeg | 张振强的个人博客</title><meta name="author" content="张振强"><meta name="copyright" content="张振强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平">
<meta property="og:type" content="article">
<meta property="og:title" content="ffmpeg">
<meta property="og:url" content="http://example.com/2025/04/17/ffmpeg/index.html">
<meta property="og:site_name" content="张振强的个人博客">
<meta property="og:description" content="C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/11.jpg">
<meta property="article:published_time" content="2025-04-17T14:51:36.000Z">
<meta property="article:modified_time" content="2025-04-17T14:58:05.157Z">
<meta property="article:author" content="张振强">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/11.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ffmpeg",
  "url": "http://example.com/2025/04/17/ffmpeg/",
  "image": "http://example.com/img/cover/11.jpg",
  "datePublished": "2025-04-17T14:51:36.000Z",
  "dateModified": "2025-04-17T14:58:05.157Z",
  "author": [
    {
      "@type": "Person",
      "name": "张振强",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_1.png"><link rel="canonical" href="http://example.com/2025/04/17/ffmpeg/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ffmpeg',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/index_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/11.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">张振强的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">ffmpeg</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ffmpeg</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-17T14:51:36.000Z" title="发表于 2025-04-17 22:51:36">2025-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-17T14:58:05.157Z" title="更新于 2025-04-17 22:58:05">2025-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%A1%B9%E7%9B%AE/">C++ 项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-FFMPEG-项目"><a href="#C-FFMPEG-项目" class="headerlink" title="C++ FFMPEG 项目"></a>C++ FFMPEG 项目</h1><p>这个项目主要是为了学习FFMPEG</p>
<p>完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放</p>
<p>这里做了一些简化操作</p>
<p>完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件</p>
<p>整体的框架是这样的：</p>
<p><img src="/img/load4.gif" data-original="/../0_images/ffmpeg/day3-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="alt text"></p>
<h1 id="FFMPEG介绍"><a href="#FFMPEG介绍" class="headerlink" title="FFMPEG介绍"></a>FFMPEG介绍</h1><p>对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++ FFMPEG的一些API</p>
<p>我们先来介绍一下一般FFMPEG的一些整体的流程，如下图所示：</p>
<p><img src="/img/load4.gif" data-original="/../0_images/ffmpeg/day4_FFMPEG.png" alt="alt text"></p>
<h2 id="基本流程介绍"><a href="#基本流程介绍" class="headerlink" title="基本流程介绍"></a>基本流程介绍</h2><p>我们一般拿到一个音视频文件，首先需要对其进行拆分，得到音频和视频对应的包。</p>
<p>这里要注意，我们平时所接触到的视频都是以某一种封装格式封装压缩好的一些比如（视频H264,音频AAC等），所以我们得到的音频和视频对应的包都是编码之后的。</p>
<p>因此后面我们需要对其进行解码，然后得到相应的结果解码之后的视频帧(YUV数据)与音频帧（PCM数据）。</p>
<p>在这里我们就可以对原始的视频数据和音频数据进行处理了，比如加一些滤镜等操作。</p>
<p>后面我们将处理之后的原始数据再重新编码，在得到编码之后的视频包和音频包</p>
<p>最后我们可以把音视频包组合在一起，输出为最后的音视频文件。</p>
<p>所以使用C++调用FFMPEG API的时候一般都会有一些基本流程的</p>
<h2 id="基本API介绍"><a href="#基本API介绍" class="headerlink" title="基本API介绍"></a>基本API介绍</h2><h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1.打开文件"></a>1.打开文件</h3><h4 id="涉及到的结构："><a href="#涉及到的结构：" class="headerlink" title="涉及到的结构："></a>涉及到的结构：</h4><p><strong>AVFormatContext</strong></p>
<p>这个是管理媒体文件格式（容器格式）的核心结构体</p>
<p>下面是精简版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFormatContext</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *av_class;          <span class="comment">// FFmpeg内部使用的类信息</span></span><br><span class="line">    AVInputFormat *iformat;           <span class="comment">// 输入格式（如MP4、FLV等）</span></span><br><span class="line">    AVOutputFormat *oformat;          <span class="comment">// 输出格式（用于写入文件）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键成员</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nb_streams;          <span class="comment">// 流的数量（视频/音频/字幕等）</span></span><br><span class="line">    AVStream **streams;               <span class="comment">// 流数组指针（核心！）</span></span><br><span class="line">    <span class="type">int64_t</span> duration;                <span class="comment">// 媒体时长（微秒）</span></span><br><span class="line">    <span class="type">int64_t</span> bit_rate;                <span class="comment">// 全局比特率（bps）</span></span><br><span class="line">    AVDictionary *metadata;          <span class="comment">// 元数据（作者、标题等）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">    </span><br><span class="line">&#125; AVFormatContext;</span><br></pre></td></tr></table></figure>

<p>这个里面存储的数据信息有很多，上面只是列出一些基本的信息</p>
<p>有两个比较重要的值是：unsigned int nb_streams; 与 AVStream **streams; </p>
<ul>
<li>unsigned int nb_streams 存储的是流的数量</li>
<li>AVStream **streams用来存储流的数组，里面有很多流。比如视频流[AVStream1]，音频流[AVStream2]，字幕流[AVStream3]</li>
</ul>
<p>我们来介绍一下 AVStream 流 </p>
<p>流里面存储的一些视频与音频等的元数据，比如编码器参数AVCodecParameters等</p>
<p>我们来看一下 AVStream 一些基本结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVStream</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;  <span class="comment">// 流的索引号</span></span><br><span class="line">    AVCodecParameters *codecpar; <span class="comment">// 编解码参数</span></span><br><span class="line">    AVRational time_base; <span class="comment">// 时间基(time base)</span></span><br><span class="line">    AVRational avg_frame_rate; <span class="comment">// 平均帧率(视频流)</span></span><br><span class="line">    AVDictionary *metadata; <span class="comment">// 元数据</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他的就不多介绍了，主要是index和codecpar比较重要</p>
<ul>
<li>index是流的索引，也就是AVStream **streams 数组对应的下标</li>
<li>AVCodecParameters 是编码器参数，主要标注一些视频或者音频等的信息，下面来看一下基本结构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecParameters</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type; <span class="comment">// 流类型(视频/音频/字幕等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span>   codec_id;   <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 视频相关</span></span><br><span class="line">    <span class="type">int</span> width, height;          <span class="comment">// 视频宽高</span></span><br><span class="line">    <span class="comment">// 音频相关</span></span><br><span class="line">    <span class="type">int</span> sample_rate;            <span class="comment">// 采样率</span></span><br><span class="line">    <span class="type">int</span> channels;               <span class="comment">// 声道数</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;    <span class="comment">// 声道布局</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，流里面存储的是元数据或者是信息数据，那么视频包音频包存在那里，怎么区分这是视频包还是音频包？</p>
<p>首先视频包和音频包肯定不是存在流里面的，这样的话流就太大了。视频包和音频包还是存储在文件里面，只不过包里面有一个 stream_index 用来指示对应的那一个流（流里面的index），这样的话就可以区分视频包和音频包或者其他包了。（AVPacket咱们后面介绍）</p>
<p>这样抛析来讲是不是就理解AVFormatContext了</p>
<h4 id="涉及到的API"><a href="#涉及到的API" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_open_input</strong></p>
<p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param ps   指向AVFormatContext指针的指针</span></span><br><span class="line"><span class="comment"> *  @param url  输入媒体文件的路径或URL（如文件路径、网络流地址等）。</span></span><br><span class="line"><span class="comment"> *  @param fmt  指定的输入格式（AVInputFormat）。若为NULL，则自动检测文件格式；</span></span><br><span class="line"><span class="comment"> *  @param options   额外选项的字典（如协议参数、解封装器选项等）</span></span><br><span class="line"><span class="comment"> *  @return 成功返回0，失败返回负的错误码（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="type">const</span> <span class="type">char</span> *url, ff_const59 AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个就是用来打开文件的，具体怎么做的就不多介绍了（我没看源码），咱们先知道其作用就好</p>
<p>一般在使用的时候都会把后面两个参数设成NULL除非有特殊的需求</p>
<p>比如在这个项目里面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开输入文件</span></span><br><span class="line"><span class="type">int</span> openResult = <span class="built_in">avformat_open_input</span>(&amp;formatCtx,filePath,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (openResult!=<span class="number">0</span>) &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;不可以打开视频文件&quot;</span>&lt;&lt;filePath&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-获取流信息"><a href="#2-获取流信息" class="headerlink" title="2.获取流信息"></a>2.获取流信息</h3><h4 id="涉及到的API-1"><a href="#涉及到的API-1" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_find_stream_info</strong></p>
<p>这个函数主要是为了确定文件的流信息的完整性</p>
<p>在调用 avformat_open_input 后，文件的流信息可能不完整，此时调用avformat_find_stream_info 可以获取更完整的流信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param ic      指向AVFormatContext的指针，表示已经打开的媒体文件上下文。</span></span><br><span class="line"><span class="comment"> * @param options 额外选项的字典，用于为每个流的解码器传递选项。</span></span><br><span class="line"><span class="comment"> * @return 成功返回非负值，表示获取到的流信息的数量；失败返回负的错误码（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说一下咱们一般会怎么用：</p>
<p>在打开文件之后，调用这个确保流信息完整，然后在遍历整个 AVStream 数组得到视频流和音频流的index</p>
<p>(这里就单处理音视频哈，其他的字幕流啥的就不处理了)</p>
<p>通过上面对流的介绍，那么就很容易写代码了，咱们来看一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vsIndex,asIndex;</span><br><span class="line">vsIndex = asIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 获取流信息</span></span><br><span class="line"><span class="type">int</span> findStreaResuly = <span class="built_in">avformat_find_stream_info</span>(formatCtx,<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span>(findStreaResuly&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到流信息&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找视频流   AVMEDIA_TYPE_VIDEO 为视频流 AVMEDIA_TYPE_AUDIO 音频流</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;formatCtx-&gt;nb_streams;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        vsIndex = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vsIndex==<span class="number">-1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到视频流&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找音频流   AVMEDIA_TYPE_VIDEO 为视频流 AVMEDIA_TYPE_AUDIO 音频流</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;formatCtx-&gt;nb_streams;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        asIndex = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asIndex==<span class="number">-1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法找到音频流&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-拆分视频包与音频包"><a href="#3-拆分视频包与音频包" class="headerlink" title="3.拆分视频包与音频包"></a>3.拆分视频包与音频包</h3><h4 id="涉及到的结构"><a href="#涉及到的结构" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVPacket</strong></p>
<p>用于存储压缩后的媒体数据（如 H.264 视频帧、AAC 音频帧等）的结构体</p>
<p>这个是GPT生成的，不一定对，还是要看源码的哈。这里咱们主要讲主要的东西</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPacket</span> &#123;</span><br><span class="line">    <span class="comment">// 数据缓冲区（存储压缩后的数据，如 H.264 NAL 单元、AAC 帧等）</span></span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">    <span class="type">int</span>      size;          <span class="comment">// 数据大小（字节数）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所属的流索引（对应 AVFormatContext-&gt;streams 的下标）</span></span><br><span class="line">    <span class="type">int</span>      stream_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳（单位：流的时间基 time_base）</span></span><br><span class="line">    <span class="type">int64_t</span>  pts;           <span class="comment">// 显示时间戳（Presentation TimeStamp）</span></span><br><span class="line">    <span class="type">int64_t</span>  dts;           <span class="comment">// 解码时间戳（Decoding TimeStamp）</span></span><br><span class="line">    <span class="type">int</span>      duration;      <span class="comment">// 持续时间（单位：time_base）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位置信息（用于字节流或文件定位）</span></span><br><span class="line">    <span class="type">int64_t</span>  pos;           <span class="comment">// 数据在文件中的偏移量（字节）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志位（如关键帧、损坏数据等）</span></span><br><span class="line">    <span class="type">int</span>      flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_PKT_FLAG_KEY     0x0001  <span class="comment">// 关键帧（I帧）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_PKT_FLAG_CORRUPT 0x0002  <span class="comment">// 数据可能损坏</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加数据（如 SEI、编解码器私有数据）</span></span><br><span class="line">    <span class="type">uint8_t</span> *side_data;     <span class="comment">// 额外数据（如 H.264 SEI）</span></span><br><span class="line">    <span class="type">int</span>      side_data_elems; <span class="comment">// 附加数据数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数（用于内存管理）</span></span><br><span class="line">    AVPacketSideData *side_data; <span class="comment">// 更详细的附加数据</span></span><br><span class="line">    <span class="type">int</span>      side_data_elems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配信息</span></span><br><span class="line">    <span class="type">void</span>    *opaque;        <span class="comment">// 私有数据，由 FFmpeg 内部使用</span></span><br><span class="line">    <span class="built_in">void</span>    (*destruct)(<span class="keyword">struct</span> AVPacket *); <span class="comment">// 释放数据的回调函数</span></span><br><span class="line">    <span class="type">void</span>    *priv;          <span class="comment">// 内部使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间基（通常由流决定，但可能被修改）</span></span><br><span class="line">    AVRational time_base;   <span class="comment">// 时间基（pts/dts 的单位）</span></span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure>

<p>主要的东西</p>
<ul>
<li>缓冲区数据, 这个理解一下，就是包里面的数据<ul>
<li>uint8_t *data;</li>
<li>int      size;          &#x2F;&#x2F; 数据大小（字节数）</li>
</ul>
</li>
<li>流索引 int stream_index;<ul>
<li>这个就是咱们之前说的，指向对应类型的包的索引，这个很重要，可以区分这个包属于什么流（音频流视频流）</li>
</ul>
</li>
</ul>
<h4 id="涉及到的API-2"><a href="#涉及到的API-2" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>av_packet_alloc</strong></p>
<p>一般咱们获取包都是使用从音视频文件之中解析下来的，但是解析下来的时候咱们总得有个空的来接收把。</p>
<p>因此就需要申请一个空的AVPacket，这个函数就是用来干这件事的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVPacket 并初始化其字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVPacket 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>av_read_frame</strong></p>
<p>这个函数是用来读取包的，这个我觉得有点变态了，读包的函数名字是读帧，当时我还搞混了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从媒体文件中读取下一个数据包，并将其存储到提供的AVPacket中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s    指向AVFormatContext的指针，表示已经打开的媒体文件上下文。</span></span><br><span class="line"><span class="comment"> * @param pkt  指向AVPacket的指针，用于存储读取到的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回0，表示成功读取了一个数据包。</span></span><br><span class="line"><span class="comment"> *  - 如果已到达文件末尾或没有更多数据包可读，返回AVERROR_EOF。</span></span><br><span class="line"><span class="comment"> *  - 其他负的错误码表示读取过程中发生错误（参考AVERROR宏）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>av_packet_ref</strong></p>
<p>复制包的函数，很好理解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 AVPacket 的内容复制到另一个 AVPacket 中，并增加引用计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dst 目标 AVPacket，即要复制到的 AVPacket。</span></span><br><span class="line"><span class="comment"> * 在调用此函数之前，dst 应该已经通过 av_packet_alloc 或其他方式分配好内存。</span></span><br><span class="line"><span class="comment"> * @param src 源 AVPacket，即要从中复制内容的 AVPacket。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_packet_ref</span><span class="params">(AVPacket *dst, <span class="type">const</span> AVPacket *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>av_packet_unref</strong></p>
<p>注意哈，咱们调用av_read_frame之后获取一个包，做了处理之后，要清空一下包里面的东西，以便于下一次再存储新的包，这个函数就是这么用的，就是清空包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 AVPacket 中的内容，并将其字段重置为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要释放内容的 AVPacket。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_unref</span><span class="params">(AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>av_packet_free</strong></p>
<p>同理，最后咱们用完了这个临时的包，后面不需要再用了，就得释放掉咱们申请的空间，于是就有了av_packet_free</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放整个 AVPacket 对象及其内部资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 指针的指针，表示要释放的 AVPacket 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么到这里咱们来看一下拆分整个包的过程(这个项目是使用一个线程来进行操作的，所以会涉及到一些线程的操作，大家看一看，能理解就好)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配包</span></span><br><span class="line">AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"><span class="comment">//一直读包</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(formatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;stream_index == vsIndex) &#123;        <span class="comment">// 处理视频包</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(videoMtx)</span></span>;         <span class="comment">//上锁</span></span><br><span class="line">        AVPacket* videoPkt = <span class="built_in">av_packet_alloc</span>();   <span class="comment">//这里要注意，packet一直在被使用，不能直接push，否则会和解析的线程抢占这个packet</span></span><br><span class="line">        <span class="built_in">av_packet_ref</span>(videoPkt, packet);          <span class="comment">//复制一份再push进去</span></span><br><span class="line">        videoPacketQueue.<span class="built_in">push</span>(videoPkt);          <span class="comment">//push</span></span><br><span class="line">        videoCV.<span class="built_in">notify_one</span>();                     <span class="comment">//唤醒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;stream_index == asIndex) &#123; <span class="comment">// 处理音频包</span></span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">lock</span>(audioMtx);         <span class="comment">//上锁</span></span><br><span class="line">        AVPacket* audioPkt = <span class="built_in">av_packet_alloc</span>();   <span class="comment">//这里要注意，packet一直在被使用，不能直接push，否则会和解析的线程抢占这个packet</span></span><br><span class="line">        <span class="built_in">av_packet_ref</span>(audioPkt, packet);          <span class="comment">//复制一份再push进去</span></span><br><span class="line">        audioPacketQueue.<span class="built_in">push</span>(audioPkt);          <span class="comment">//push</span></span><br><span class="line">        audioCV.<span class="built_in">notify_one</span>();                     <span class="comment">//唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(packet); <span class="comment">//释放当前包的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;packet);     <span class="comment">//循环结束后释放packet</span></span><br><span class="line"><span class="built_in">av_packet_free</span>(&amp;packet);     <span class="comment">//循环结束后释放packet</span></span><br><span class="line">doneVideoReading = <span class="literal">true</span>;     <span class="comment">//视频读完了</span></span><br><span class="line">videoCV.<span class="built_in">notify_all</span>();        <span class="comment">//唤醒</span></span><br><span class="line">doneAudioReading = <span class="literal">true</span>;     <span class="comment">//音频读完了</span></span><br><span class="line">audioCV.<span class="built_in">notify_all</span>();        <span class="comment">//唤醒</span></span><br></pre></td></tr></table></figure>

<p>这里留个小问题哈，为啥要复制一下包av_packet_ref</p>
<h3 id="4-解码包"><a href="#4-解码包" class="headerlink" title="4.解码包"></a>4.解码包</h3><p>这里要注意哈，咱们得到的包是编码之后的结果，到这里才是解码的过程</p>
<p>这里以视频为例哈，音频是同样的操作</p>
<h4 id="涉及到的结构-1"><a href="#涉及到的结构-1" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVCodecParameters</strong></p>
<p>既然要解码，咱们就得获取一下<strong>编解码器</strong>的参数，获取参数之后才能做解码操作</p>
<p>这个咱们前面在介绍流的时候已经做了介绍，现在再拿下来说一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecParameters</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type; <span class="comment">// 流类型(视频/音频/字幕等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span>   codec_id;   <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 视频相关</span></span><br><span class="line">    <span class="type">int</span> width, height;          <span class="comment">// 视频宽高</span></span><br><span class="line">    <span class="comment">// 音频相关</span></span><br><span class="line">    <span class="type">int</span> sample_rate;            <span class="comment">// 采样率</span></span><br><span class="line">    <span class="type">int</span> channels;               <span class="comment">// 声道数</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;    <span class="comment">// 声道布局</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里要特别注意哈，这里是一个结构体，里面存储的是<strong>编解码器</strong>的参数，不是所谓的<strong>编解码器</strong></p>
<p>注意这里比较重要的是 enum AVCodecID   codec_id;   &#x2F;&#x2F; <strong>编解码器</strong>ID</p>
<p>它是<strong>编解码器</strong>对应的id，我们点进去可以看到，这是一个枚举类型的数据，里面有好多比那解码器的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AVCodecID</span> &#123;</span><br><span class="line">    AV_CODEC_ID_NONE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* video codecs */</span></span><br><span class="line">    AV_CODEC_ID_MPEG1VIDEO,</span><br><span class="line">    AV_CODEC_ID_MPEG2VIDEO, <span class="comment">///&lt; preferred ID for MPEG-1/2 video decoding</span></span><br><span class="line">    AV_CODEC_ID_H261,</span><br><span class="line">    AV_CODEC_ID_H263,</span><br><span class="line">    <span class="comment">//其他....</span></span><br><span class="line">    <span class="comment">/* various PCM &quot;codecs&quot; */</span></span><br><span class="line">    AV_CODEC_ID_FIRST_AUDIO = <span class="number">0x10000</span>,     <span class="comment">///&lt; A dummy id pointing at the start of audio codecs</span></span><br><span class="line">    AV_CODEC_ID_PCM_S16LE = <span class="number">0x10000</span>,</span><br><span class="line">    AV_CODEC_ID_PCM_S16BE,</span><br><span class="line">    AV_CODEC_ID_PCM_U16LE,</span><br><span class="line">    <span class="comment">//其他....</span></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">/*其他*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AVCodec</strong></p>
<p>这个才是相应的<strong>编解码器</strong>，为什么我老是加粗这个<strong>编解码器</strong>，因为AVCodec这个结构既可以表示编码器又可以表示解码器！！！这里一定要注意，非常非常容易搞混乱</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodec</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;          <span class="comment">// 编解码器的简短名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *long_name;     <span class="comment">// 编解码器的描述性名称</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type;     <span class="comment">// 媒体类型(AVMEDIA_TYPE_VIDEO/AVMEDIA_TYPE_AUDIO等)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id;         <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="type">const</span> AVRational *supported_framerates; <span class="comment">// 支持的帧率(视频)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> *pix_fmts;     <span class="comment">// 支持的像素格式(视频)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *supported_samplerates;       <span class="comment">// 支持的采样率(音频)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> *sample_fmts; <span class="comment">// 支持的采样格式(音频)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> *channel_layouts;        <span class="comment">// 支持的声道布局(音频)</span></span><br><span class="line">    <span class="type">int</span> priv_data_size;        <span class="comment">// 私有数据大小</span></span><br><span class="line">    <span class="comment">// 各种函数指针(init, encode, decode, close等)</span></span><br><span class="line">&#125; AVCodec;</span><br></pre></td></tr></table></figure>
<p>上面是一些常规的内容，区分编码器与解码器主要靠着下面两个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encode data to an AVPacket.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param      avctx          codec context</span></span><br><span class="line"><span class="comment"> * @param      avpkt          output AVPacket</span></span><br><span class="line"><span class="comment"> * @param[in]  frame          AVFrame containing the raw data to be encoded</span></span><br><span class="line"><span class="comment"> * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a</span></span><br><span class="line"><span class="comment"> *                            non-empty packet was returned in avpkt.</span></span><br><span class="line"><span class="comment"> * @return 0 on success, negative error code on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">int</span> (*encode2)(<span class="keyword">struct</span> AVCodecContext *avctx, <span class="keyword">struct</span> AVPacket *avpkt,</span><br><span class="line">                   <span class="type">const</span> <span class="keyword">struct</span> AVFrame *frame, <span class="type">int</span> *got_packet_ptr);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decode picture or subtitle data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param      avctx          codec context</span></span><br><span class="line"><span class="comment"> * @param      outdata        codec type dependent output struct</span></span><br><span class="line"><span class="comment"> * @param[out] got_frame_ptr  decoder sets to 0 or 1 to indicate that a</span></span><br><span class="line"><span class="comment"> *                            non-empty frame or subtitle was returned in</span></span><br><span class="line"><span class="comment"> *                            outdata.</span></span><br><span class="line"><span class="comment"> * @param[in]  avpkt          AVPacket containing the data to be decoded</span></span><br><span class="line"><span class="comment"> * @return amount of bytes read from the packet on success, negative error</span></span><br><span class="line"><span class="comment"> *         code on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">int</span> (*decode)(<span class="keyword">struct</span> AVCodecContext *avctx, <span class="type">void</span> *outdata,</span><br><span class="line">                  <span class="type">int</span> *got_frame_ptr, <span class="keyword">struct</span> AVPacket *avpkt);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (codec-&gt;encode2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是一个编码器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (codec-&gt;decode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是一个解码器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意哈，这里只是简单的区分，其实在用的时候总得初始化吧，初始化的时候会针对编码器和解码器会调用不同的函数来做</p>
<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找解码器</span></span><br><span class="line">AVCodec *decoder = <span class="built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);</span><br><span class="line"><span class="comment">// 查找编码器</span></span><br><span class="line">AVCodec *encoder = <span class="built_in">avcodec_find_encoder</span>(AV_CODEC_ID_H264);</span><br></pre></td></tr></table></figure>


<p><strong>AVCodecContext</strong></p>
<p>AVCodec是<strong>编解码器</strong> 那么这个AVCodecContext就是*<em>编解码器的上下文</em></p>
<p>这是<strong>编解码器</strong>的上下文，保存了编解码过程中的所有状态信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVCodecContext</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> codec_type;  <span class="comment">// 编解码器类型</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVCodec</span> *codec;  <span class="comment">// 使用的AVCodec</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> codec_id;      <span class="comment">// 编解码器ID</span></span><br><span class="line">    <span class="comment">// 各种编解码参数...</span></span><br><span class="line">    <span class="type">int</span> bit_rate;                 <span class="comment">// 比特率</span></span><br><span class="line">    <span class="type">int</span> width, height;            <span class="comment">// 图像尺寸(视频)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> pix_fmt;   <span class="comment">// 像素格式(视频)</span></span><br><span class="line">    <span class="type">int</span> sample_rate;              <span class="comment">// 采样率(音频)</span></span><br><span class="line">    <span class="type">int</span> channels;                 <span class="comment">// 声道数(音频)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> sample_fmt; <span class="comment">// 采样格式(音频)</span></span><br><span class="line">    <span class="type">uint64_t</span> channel_layout;      <span class="comment">// 声道布局(音频)</span></span><br><span class="line">    <span class="comment">// 更多字段...</span></span><br><span class="line">&#125; AVCodecContext;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意区分一下AVCodec与AVCodecContext哈，咱们来对比一下</p>
<p>你看上面的AVCodec的结构，一般里面是不是有很多的指针也就是数组的类型，这里表示这个<strong>编解码器</strong>锁支持的，举个简单的例子，比如对于与编码格式 支持 [A,B,C,D…G]编码格式</p>
<p>VCodecContext里面一般都是非常具体的值，比如还用那个例子，编码格式所对应的状态是<strong>A</strong> 具体的A</p>
<p>因此，咱们在后面进行编解码操作的时候使用的都是VCodecContext</p>
<p><strong>AVFrame</strong></p>
<p>咱们已经介绍了AVPacket，也就是咱们上一步所获取的压缩状态的数据包，那么AVFrame就是解码之后的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFrame</span> &#123;</span><br><span class="line">    <span class="comment">// 数据存储（核心字段）</span></span><br><span class="line">    <span class="type">uint8_t</span> *data[AV_NUM_DATA_POINTERS];      <span class="comment">// 数据指针数组（多平面存储）</span></span><br><span class="line">    <span class="type">int</span> linesize[AV_NUM_DATA_POINTERS];       <span class="comment">// 每个平面的行字节数（含对齐填充）</span></span><br><span class="line">    <span class="type">int</span> width, height;                        <span class="comment">// 视频帧尺寸</span></span><br><span class="line">    <span class="type">int</span> nb_samples;                           <span class="comment">// 音频样本数</span></span><br><span class="line">    <span class="type">int</span> format;                               <span class="comment">// 格式标识（对应 AVPixelFormat 或 AVSampleFormat）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间信息</span></span><br><span class="line">    <span class="type">int64_t</span> pts;                              <span class="comment">// 显示时间戳</span></span><br><span class="line">    <span class="type">int64_t</span> duration;                         <span class="comment">// 帧持续时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];   <span class="comment">// 数据缓冲引用</span></span><br><span class="line">    AVBufferRef *hw_frames_ctx;               <span class="comment">// 硬件加速上下文</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元数据</span></span><br><span class="line">    AVDictionary *metadata;                   <span class="comment">// 附加信息字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他字段（色彩空间、音频声道布局等）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; AVFrame;</span><br></pre></td></tr></table></figure>

<p>这里咱们就先知道AVFrame就是解码之后的数据就好了，里面涉及到一些平面存储的概念这个感兴趣的可以取搜索一下学习学习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：分辨率为 1280x720 的 YUV420P 视频帧 (可以想一想，这个存储会压缩多少)</span></span><br><span class="line"><span class="comment">// 原来是1280x720 现在是1280 + 640 + 640 </span></span><br><span class="line">linesize[<span class="number">0</span>] = <span class="number">1280</span>;  <span class="comment">// Y平面每行字节数</span></span><br><span class="line">linesize[<span class="number">1</span>] = <span class="number">640</span>;   <span class="comment">// U平面每行字节数（宽度减半）</span></span><br><span class="line">linesize[<span class="number">2</span>] = <span class="number">640</span>;   <span class="comment">// V平面每行字节数</span></span><br></pre></td></tr></table></figure>

<h4 id="涉及到的API-3"><a href="#涉及到的API-3" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p>首先要获取<strong>编解码器</strong>的参数吧（这里不涉及API哈，别激动）就是从咱们刚得到的流中拿哈</p>
<p>这里以视频为例哈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取视频流的编解码器参数</span></span><br><span class="line">videoCodecParams = formatCtx-&gt;streams[vsIndex]-&gt;codecpar;</span><br><span class="line"><span class="keyword">if</span> (!videoCodecParams) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法获取解码器参数-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emmm就这么简单，哈哈哈哈</p>
<p><strong>avcodec_find_decoder</strong></p>
<p>那么获取之后就要创建一个<strong>编解码器</strong>了，也就是一个 AVCodec 这里主要是解码，所以用decoder</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据编解码器ID查找解码器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param id 编解码器ID，是一个枚举值，例如 AV_CODEC_ID_H264 表示 H.264 编解码器。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回指向找到的解码器的 AVCodec 结构体指针。</span></span><br><span class="line"><span class="comment"> *  - 如果未找到匹配的解码器，返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>avcodec_find_decoder 只是创建的一种哈，还有很多其他的函数比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么这里咱们再和之前获取的videoCodecParams结合再一起，那就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodec* videoCodec = <span class="built_in">avcodec_find_decoder</span>(videoCodecParams-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (!videoCodec) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法识别解码器-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得回想一下videoCodecParams-&gt;codec_id是什么，上面介绍了</p>
<p><strong>avcodec_alloc_context3</strong></p>
<p>那么创建完了之后就需要 创建AVCodecContext 保存咱们上面所创建的<strong>解码器</strong>（这里不是编解码器了哈，上面调用的是avcodec_find_decoder，创建的是解码器）上下文了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVCodecContext，并将其初始化为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param codec 指向 AVCodec 的指针，表示要使用的编解码器。如果为 NULL，则分配一个未绑定编解码器的 AVCodecContext。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVCodecContext 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodecContext* videoCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(videoCodec);</span><br></pre></td></tr></table></figure>


<p><strong>avcodec_parameters_to_context</strong></p>
<p>注意哈，上面创建只是创建一个空壳子，意味着videoCodecCtx可以保存videoCodec的状态，这里就需要给他赋值了，那么想到状态是不是就想到了之前提到的AVCodecParameters </p>
<p>没错，看看下面的函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AVCodecParameters 中的参数复制到 AVCodecContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param codec_ctx 目标 AVCodecContext，即要将参数复制到的解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param codec_par 源 AVCodecParameters，即要从中复制参数的结构体。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_parameters_to_context</span><span class="params">(AVCodecContext *codec_ctx, <span class="type">const</span> AVCodecParameters *codec_par)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以咱们就这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P2CResultVi = <span class="built_in">avcodec_parameters_to_context</span>(videoCodecCtx, videoCodecParams);</span><br><span class="line"><span class="keyword">if</span> (P2CResultVi&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法将解码器参数复制到解码器上下文之中-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>avcodec_open2</strong></p>
<p>OK,到这里就把所有的东西都初始化好了，最后一步就是打开解码器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开一个编解码器，并将其与指定的 AVCodecContext 绑定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示要绑定的编解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param codec 指向 AVCodec 的指针，表示要使用的编解码器。</span></span><br><span class="line"><span class="comment"> * @param options 指向 AVDictionary 的指针，表示编解码器的选项。如果为 NULL，则不传递任何选项。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> openAvcodecResultVi = <span class="built_in">avcodec_open2</span>(videoCodecCtx, videoCodec, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (openAvcodecResultVi&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法打开解码器-视频&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>av_frame_alloc</strong></p>
<p>仿照之前的av_packet_alloc，这里就不过多介绍了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配一个新的 AVFrame，并将其初始化为默认值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回一个指向新分配的 AVFrame 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL（例如内存分配失败）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同样的还有 <strong>av_frame_unref</strong> 与 <strong>av_frame_free</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 AVFrame 中的引用，并将其重置为初始状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，表示要释放引用的 AVFrame。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_unref</span><span class="params">(AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放整个 AVFrame 对象及其内部资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 指针的指针，表示要释放的 AVFrame 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span>;</span><br></pre></td></tr></table></figure>

<p>OK,下面是两个非常关键的函数</p>
<p><strong>avcodec_send_packet</strong></p>
<p>第一个是 把文件packet放进解码器里面解码,然后解码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供原始数据包数据作为解码器的输入。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param avpkt 指向 AVPacket 的指针，表示要解码的数据包。通常是一个视频帧或多个音频帧。</span></span><br><span class="line"><span class="comment"> *              如果为 NULL 或数据为空，则视为刷新数据包，用于通知解码器流结束。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 0：成功，数据包被接受。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avcodec_receive_frame() 读取输出。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：解码器已被刷新，无法再发送新数据包。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EINVAL)：编解码器未打开，或为编码器，或需要刷新。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(ENOMEM)：内部队列添加数据包失败，或其他类似错误。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：合法的解码错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_send_packet</span>(videoCodecCtx, packet)</span><br></pre></td></tr></table></figure>

<p><strong>avcodec_receive_frame</strong></p>
<p>解码之后，咱们得拿一下所得到的解码帧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从解码器中获取一个已解码的帧。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示解码器上下文。</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，用于存储解码后的帧。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0，表示成功获取了一个解码后的帧。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：解码器需要更多输入数据才能产生输出，需要先调用 avcodec_send_packet。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：解码器已处理完所有输入数据，没有更多输出。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：解码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_receive_frame</span>(videoCodecCtx, frame)</span><br></pre></td></tr></table></figure>

<p>这里就要注意理解一下哈，avcodec_send_packet解码之后会放入一个缓冲区里面，avcodec_receive_frame会来取</p>
<p>avcodec_receive_frame的返回值里面会有一个AVERROR(EAGAIN)：解码器需要更多输入数据才能产生输出，需要先调用 avcodec_send_packet。这里做一下简单的介绍</p>
<ul>
<li>关键帧（I帧）：通常一个AVPacket对应一个AVFrame。</li>
<li>B&#x2F;P帧：可能需要参考前后帧，解码器可能缓存多个AVPacket后才输出AVFrame。</li>
<li>分包处理：某些编码格式（如H.264）可能将一个帧拆分到多个AVPacket中。</li>
</ul>
<p>一般的使用的格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    <span class="built_in">avcodec_send_packet</span>(codec_ctx, packet); <span class="comment">// 将AVPacket送入解码器</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(codec_ctx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理AVFrame</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里再说一下为什么会有第二个循环，其实上面的已经可以解释了，这里再说一下音频</p>
<p>音频解码的典型场景，音频帧打包：一个AVPacket可能包含多个音频帧（如AAC每个包含1024帧）。解码时需循环调用avcodec_receive_frame()直到返回AVERROR(EAGAIN)，表示需要新输入。</p>
<p>到这里解码就结束了，那么来看一下这个项目里面完整的处理流程(初始化就不说了，这里还是涉及到一些线程安全的操作哈，记得理解一下)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processVideoPackets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化临时的负责接收的包和帧</span></span><br><span class="line">    AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果还在push视频或者videoPacketQueue还没有空，就要一直执行</span></span><br><span class="line">    <span class="keyword">while</span> (!doneVideoReading || !videoPacketQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(videoMtx)</span></span>;   <span class="comment">//上锁（队列）</span></span><br><span class="line">        videoCV.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !videoPacketQueue.<span class="built_in">empty</span>() || doneVideoReading; &#125;);  <span class="comment">//等待（队列）</span></span><br><span class="line">        <span class="keyword">if</span> (!videoPacketQueue.<span class="built_in">empty</span>()) &#123;              <span class="comment">//videoPacketQueue还没空</span></span><br><span class="line">            *packet = *videoPacketQueue.<span class="built_in">front</span>();      <span class="comment">//并且取头pop出去</span></span><br><span class="line">            videoPacketQueue.<span class="built_in">pop</span>();</span><br><span class="line">            lock.<span class="built_in">unlock</span>();                            <span class="comment">//用完了解锁</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">avcodec_send_packet</span>(videoCodecCtx, packet) == <span class="number">0</span>) &#123;      </span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">avcodec_receive_frame</span>(videoCodecCtx, frame) == <span class="number">0</span>)&#123;</span><br><span class="line">                    AVFrame* frameCopy = <span class="built_in">av_frame_alloc</span>();  <span class="comment">// 复制帧数据到新帧 防止当前帧正在使用出现资源争夺</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">av_frame_ref</span>(frameCopy, frame) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">av_frame_free</span>(&amp;frameCopy);</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;视频 复制失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// 复制失败则跳过该帧</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将复制的帧推入环形缓冲区</span></span><br><span class="line">                    <span class="function">unique_lock&lt;mutex&gt; <span class="title">frameLock</span><span class="params">(videoFrameMtx)</span></span>;</span><br><span class="line">                    <span class="comment">//这里是用来输出查看环形缓冲区是不是正常的</span></span><br><span class="line">                    <span class="comment">//if (videoFrameBuffer.full())&#123;</span></span><br><span class="line">                        <span class="comment">//cout&lt;&lt;&quot;视频环形缓冲区满了，一直等待&quot;&lt;&lt;endl;</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">                    <span class="comment">//等待缓冲区有空位  </span></span><br><span class="line">                    videoFrameCV.<span class="built_in">wait</span>(frameLock, [&amp;] &#123;</span><br><span class="line">                        <span class="keyword">return</span> !videoFrameBuffer.<span class="built_in">full</span>();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    videoFrameBuffer.<span class="built_in">push</span>(frameCopy);</span><br><span class="line">                    videoFrameCV.<span class="built_in">notify_all</span>(); <span class="comment">// 有新帧 唤醒</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doneVideoFrameReading = <span class="literal">true</span>;</span><br><span class="line">    videoFrameCV.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">//关文件，放资源</span></span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;packet);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--线程解析视频包完成！--&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-处理解码之后的数据"><a href="#5-处理解码之后的数据" class="headerlink" title="5.处理解码之后的数据"></a>5.处理解码之后的数据</h3><p>这里的操作有很多，主要是为解码之后的数据添加滤镜，比如旋转，倍速，变声等操作都是在这里完成的</p>
<p>你看上面的代码我是不是就只是单纯的拿到解码之后的数据，然后放在一个环形缓冲区里面，其实这里放在环形缓冲区之前还可以做我上面所说的加滤镜的操作，然后再放进去。</p>
<p>这里太多了，就不一一介绍了，感兴趣的可以搜一下，学习一下，很有意思的。</p>
<h3 id="6-再编码回去"><a href="#6-再编码回去" class="headerlink" title="6.再编码回去"></a>6.再编码回去</h3><p>哈哈哈哈，好不容易做了解码这里咋又编码回去了</p>
<p>我们看一下前面的 FFMPEG介绍 里面的那个图，我们可以看到，再解码之后我们再加上一些同步的机制就可以分别调用视频和音频的驱动进行播放了</p>
<p>这里之前做过安卓的 native C++的项目 是这样处理的</p>
<p>但是我们这里主要是工作是 解码之后 做出处理（比如添加滤镜等功能） 然后再合成最后输出的mp4</p>
<p>所以我们还得再编码回去</p>
<p>这里编码就会简单了</p>
<p>因为编码也是用的  AVCodec 这个东西咱们之前已经介绍了，这里就不多说了</p>
<p>这里主要说一下编码器的初始化的操作，这里使用不同的方式进行初始化</p>
<p>之前咱们做解码的时候直接使用的是AVCodecParameters里面参数（解码器这样处理是必须的，毕竟不使用原始音视频文件之中的参数进行初始化的话就无法解码了）</p>
<p>咱们再编码的时候就可以自己定制编码器的参数了（这里需要有一些专业的视频编码的一些知识，我也没有这个知识，我写的时候是GPT生成了，哈哈哈哈）</p>
<p>这边要一定要搞懂 AVCodec 与 AVCodecContext的关系哈，一定要清楚，不然就会糊里糊涂的，用的时候根本搞不明白</p>
<h4 id="涉及到的结构-2"><a href="#涉及到的结构-2" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p><strong>AVCodec</strong></p>
<p>看前面的介绍</p>
<p><strong>AVCodecContext</strong></p>
<p>看前面的介绍</p>
<h4 id="涉及到的API-4"><a href="#涉及到的API-4" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avcodec_find_encoder_by_name</strong></p>
<p>这里咱们前面其实也介绍了 avcodec_find_<strong>decoder</strong>_by_name</p>
<p>这个和那个是一样的，只不过这里是 avcodec_find_<strong>encoder</strong>_by_name</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据编码器名称查找编码器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name 编码器的名称，例如 &quot;libx264&quot; 或 &quot;aac&quot;。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回指向找到的编码器的 AVCodec 结构体指针。</span></span><br><span class="line"><span class="comment"> *  - 如果未找到匹配的编码器，返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">const</span> AVCodec *<span class="title">avcodec_find_encoder_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以通过这个来获取咱们指定的编码器格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用的是 mpeg4 编码器</span></span><br><span class="line"><span class="type">const</span> AVCodec* videoEncoder = <span class="built_in">avcodec_find_encoder_by_name</span>(<span class="string">&quot;mpeg4&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>avcodec_alloc_context3</strong></p>
<p>后面就是创建编器的上下文状态（AVCodecContext）了</p>
<p>这个函数和之前的一样，就不介绍了哈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVCodecContext* videoEncoderCtx = <span class="built_in">avcodec_alloc_context3</span>(videoEncoder);</span><br></pre></td></tr></table></figure>

<p>这里要注意了哈，之前 咱们是用的 avcodec_parameters_to_context 给 AVCodecContext赋值的</p>
<p>这里可以回头到前面看看，是咋处理的</p>
<p>在这里咱们需要手动赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">videoEncoderCtx-&gt;width = <span class="number">1024</span>;                     <span class="comment">// 视频宽度</span></span><br><span class="line">videoEncoderCtx-&gt;height = <span class="number">436</span>;                     <span class="comment">// 视频高度</span></span><br><span class="line">videoEncoderCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;     <span class="comment">// MPEG4 标准支持的像素格式</span></span><br><span class="line">videoEncoderCtx-&gt;time_base = &#123;<span class="number">1</span>, <span class="built_in">int</span>(<span class="number">25</span> * playSpeed)&#125;; <span class="comment">// 25 FPS</span></span><br><span class="line">videoEncoderCtx-&gt;bit_rate = <span class="number">2500000</span>;               <span class="comment">// 2.5 Mbps 码率</span></span><br><span class="line">videoEncoderCtx-&gt;gop_size = <span class="number">12</span>;                    <span class="comment">// 关键帧间隔</span></span><br><span class="line">videoEncoderCtx-&gt;max_b_frames = <span class="number">10</span>;                <span class="comment">// B帧最大数量</span></span><br><span class="line">videoEncoderCtx-&gt;level = <span class="number">5</span>;                        <span class="comment">// Level 5</span></span><br></pre></td></tr></table></figure>

<p>说实话有些参说我也搞不动，我这个是GPT生成的</p>
<p>大概意思就是把那些重要的参数给赋值了，后面就直接用就好了</p>
<p><strong>avcodec_open2</strong></p>
<p>后面就是打开编码器了，这个前面已经说过了，就不再赘述了。</p>
<p><strong>avcodec_send_frame</strong></p>
<p>咱们之前已经说了解码的时候的 avcodec_send_packet 函数</p>
<p>packet是封住之后的包，那么咱们现在需要对原始数据frame做处理，自然就是 avcodec_send_frame</p>
<p>这个用法和avcodec_send_packet是一样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个 AVFrame 发送到编码器进行编码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示编码器上下文。</span></span><br><span class="line"><span class="comment"> * @param frame 指向 AVFrame 的指针，表示要编码的帧。如果为 NULL，则表示刷新编码器。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avcodec_receive_packet 读取输出。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：编码器已被刷新，无法再发送新帧。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EINVAL)：输入参数无效，或编码器未打开。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：编码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_send_frame</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVFrame *frame)</span></span>;</span><br></pre></td></tr></table></figure>


<p><strong>avcodec_receive_packet</strong></p>
<p>同理哈，就和前面的一样， avcodec_send_packet 与  avcodec_receive_frame 配套出现</p>
<p>这里就是 avcodec_send_frame 与 avcodec_receive_packet 配套出现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从编码器中获取一个已编码的数据包。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param avctx 指向 AVCodecContext 的指针，表示编码器上下文。</span></span><br><span class="line"><span class="comment"> * @param avpkt 指向 AVPacket 的指针，用于存储编码后的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0，表示成功获取了一个编码后的数据包。</span></span><br><span class="line"><span class="comment"> *  - AVERROR(EAGAIN)：编码器需要更多输入帧才能产生输出，需要先调用 avcodec_send_frame。</span></span><br><span class="line"><span class="comment"> *  - AVERROR_EOF：编码器已处理完所有输入帧，没有更多输出。</span></span><br><span class="line"><span class="comment"> *  - 其他负值：编码过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_receive_packet</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里做一下说明哈，这里面的一些处理的操作基本上都是配套出现的，就比如咱们上面的所说的</p>
<p>avcodec_send_packet 与 avcodec_receive_frame</p>
<p>avcodec_send_frame 与 avcodec_receive_packet</p>
<p>还有其他的操作，比如说 滤镜 也是先把帧send进入，然后再receive一下</p>
<p>再比如音频的重定向 也是这样的。</p>
<p>那么咱们再来看一下视频部分的整体操作（同样的哈，我这里面有一些线程的操作，清稍微忽略一下哈）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int64_t</span> frame_pts = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//还在处理视频帧，或者videoFrameBuffer非空</span></span><br><span class="line"><span class="keyword">while</span> (!doneVideoFrameReading||!videoFrameBuffer.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">// 从队列中区取帧</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">frameLock</span><span class="params">(videoFrameMtx)</span></span>;    <span class="comment">//上锁</span></span><br><span class="line">    videoFrameCV.<span class="built_in">wait</span>(frameLock, [&amp;] &#123;<span class="keyword">return</span> !videoFrameBuffer.<span class="built_in">empty</span>() || doneVideoFrameReading;&#125;);  <span class="comment">//空等待</span></span><br><span class="line">    <span class="keyword">if</span>(!videoFrameBuffer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        AVFrame* frame = videoFrameBuffer.<span class="built_in">front</span>();</span><br><span class="line">        videoFrameBuffer.<span class="built_in">pop</span>();</span><br><span class="line">        frame-&gt;pts = frame_pts++;        <span class="comment">//！！！很关键的pts设置</span></span><br><span class="line">        frameLock.<span class="built_in">unlock</span>();</span><br><span class="line">        videoFrameCV.<span class="built_in">notify_all</span>();       <span class="comment">//环形缓冲区有空间了</span></span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">lock</span>();       <span class="comment">//videoEncoderCtxMtx的锁，防止和输出的部分有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avcodec_send_frame</span>(videoEncoderCtx,frame)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;视频，发送帧到编码器失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame); <span class="comment">//释放帧资源</span></span><br><span class="line">        </span><br><span class="line">        AVPacket* encodedPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">int</span> receivePacketResult = <span class="built_in">avcodec_receive_packet</span>(videoEncoderCtx, encodedPacket);</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">while</span> (receivePacketResult == <span class="number">0</span>) &#123;</span><br><span class="line">            AVPacket* pkt = <span class="built_in">av_packet_clone</span>(encodedPacket);     <span class="comment">//克隆包并存入队列</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">encLock</span><span class="params">(videoFrameEncoderMtx)</span></span>;   <span class="comment">//上锁</span></span><br><span class="line">            videoFrameEncoderQueue.<span class="built_in">push</span>(pkt);                   <span class="comment">//push   结束了开锁</span></span><br><span class="line">            encLock.<span class="built_in">unlock</span>();</span><br><span class="line">            videoFrameEncoderCV.<span class="built_in">notify_all</span>();                    <span class="comment">// 通知有新包</span></span><br><span class="line">            <span class="built_in">av_packet_unref</span>(encodedPacket);</span><br><span class="line">            videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">            receivePacketResult = <span class="built_in">avcodec_receive_packet</span>(videoEncoderCtx, encodedPacket);</span><br><span class="line">            videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="built_in">av_packet_free</span>(&amp;encodedPacket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个点忘记说了，这里的frame_pts很重要，这是时间戳，一般会有编码时间戳和显示时间戳，这里要设置好，看这一行！frame-&gt;pts &#x3D; frame_pts++;        &#x2F;&#x2F;！！！很关键的pts设置</p>
<p>还有一点，音频在编码的时候如果像咱们这样 自己设置了编码器的参数，就需要有一个重定向的过程。</p>
<p>这个重定向的过程就不详细讲了。感兴趣的可以取搜一下</p>
<h3 id="7-最后就是封装在一起了"><a href="#7-最后就是封装在一起了" class="headerlink" title="7.最后就是封装在一起了"></a>7.最后就是封装在一起了</h3><p>这个过程就很简单了，理解了之前打开的例子，这个就好理解了</p>
<p>唯一一点需要注意的就是音视频的同步的问题</p>
<h4 id="涉及到的结构-3"><a href="#涉及到的结构-3" class="headerlink" title="涉及到的结构"></a>涉及到的结构</h4><p>没有新的结构，上面都介绍过了。</p>
<h4 id="涉及到的API-5"><a href="#涉及到的API-5" class="headerlink" title="涉及到的API"></a>涉及到的API</h4><p><strong>avformat_alloc_output_context2</strong></p>
<p>就是打开一个输出的AVFormatContext</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配并初始化一个用于输出多媒体文件的 AVFormatContext。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ctx 指向 AVFormatContext 指针的指针，用于存储分配的上下文。</span></span><br><span class="line"><span class="comment"> * @param oformat 指向 AVOutputFormat 的指针，指定输出格式。如果为 NULL，将根据 format_name 或 filename 自动推断输出格式。</span></span><br><span class="line"><span class="comment"> * @param format_name 指定输出格式的名称，例如 &quot;mp4&quot;。如果 oformat 为 NULL 且 format_name 非空，FFmpeg 会尝试根据这个名字找到合适的输出格式。</span></span><br><span class="line"><span class="comment"> * @param filename 输出文件的名称。如果 oformat 为 NULL，此参数用于根据文件扩展名自动生成输出格式。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误代码，例如 AVERROR_NOENT 或 AVERROR_INVALIDDATA。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_alloc_output_context2</span><span class="params">(AVFormatContext **ctx, <span class="type">const</span> AVOutputFormat *oformat, <span class="type">const</span> <span class="type">char</span> *format_name, <span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没啥复杂的用法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化输出 MP4 文件</span></span><br><span class="line">AVFormatContext* outFormatCtx = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">avformat_alloc_output_context2</span>(&amp;outFormatCtx, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, outFilePath);</span><br><span class="line"><span class="keyword">if</span> (!outFormatCtx) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无法创建输出上下文&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很简单</p>
<p>后面就需要创建流了，咱们前面也说了，AVFormatContext有很多的流信息，现在咱们有个空的AVFormatContext就需要先把流信息填进取。</p>
<p>咱们这里只需要视频流和音频流就可以了</p>
<p><strong>avformat_new_stream</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的 AVStream 并将其添加到 AVFormatContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要添加新流的上下文。</span></span><br><span class="line"><span class="comment"> * @param c 指向 AVCodec 的指针，表示新流的编解码器。如果为 NULL，则不设置编解码器[^61^]。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回新创建的 AVStream 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>相当于new一个</p>
<p>基本用法也很简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p><strong>avcodec_parameters_from_context</strong></p>
<p>注意哈，咱们用avformat_new_stream创建了一个流，并且放进了outFormatCtx里面，但是这个流是啥流还不知道哇，因此咱们需要给他的codecpar赋值（这里想一下前面是如何判断是啥流的的哈）</p>
<p>就是把咱们的编码器的参数给放进去哈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的 AVStream 并将其添加到 AVFormatContext 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要添加新流的上下文。</span></span><br><span class="line"><span class="comment"> * @param c 指向 AVCodec 的指针，表示新流的编解码器。如果为 NULL，则不设置编解码器[^61^]。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回新创建的 AVStream 的指针。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回 NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br></pre></td></tr></table></figure>

<p>那么咱们看一下完整的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建视频流</span></span><br><span class="line">AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br><span class="line">videoStream-&gt;time_base = videoEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建音频流</span></span><br><span class="line">AVStream* audioStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(audioStream-&gt;codecpar, audioEncoderCtx);</span><br><span class="line">audioStream-&gt;time_base = audioEncoderCtx-&gt;time_base;</span><br></pre></td></tr></table></figure>

<p><strong>avio_open</strong></p>
<p>然后就需要打开文件了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开输出文件</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_READ：以只读方式打开文件。</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_WRITE：以只写方式打开文件。</span></span><br><span class="line"><span class="comment">// AVIO_FLAG_READ_WRITE：以读写方式打开文件。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;outFormatCtx-&gt;pb, outFilePath, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;无法打开输出文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>avformat_write_header</strong></p>
<p>这些都是一些固定的操作了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写入媒体文件的头部信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要写入头部信息的上下文。</span></span><br><span class="line"><span class="comment"> * @param options 指向 AVDictionary 的指针，表示写入头部时的额外选项。如果为 NULL，则不传递任何选项。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(ENOMEM)：内存分配失败。</span></span><br><span class="line"><span class="comment"> *    - 其他负值：写入过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_write_header</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写入文件头</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(outFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无法写入文件头&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>av_packet_rescale_ts</strong></p>
<p>咱们拿到一个包之后还不能直接写，得先调用av_packet_rescale_ts转化一下时间基，就是把原来的时间其转化到对应流的时间基下，这样才能保证正常的播放那个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AVPacket 中的时间戳从一个时间基转换为另一个时间基。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要调整时间戳的数据包。</span></span><br><span class="line"><span class="comment"> * @param tb_src 源时间基，即原始时间戳所依据的时间基。</span></span><br><span class="line"><span class="comment"> * @param tb_dst 目标时间基，即要转换到的时间基。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span>;</span><br></pre></td></tr></table></figure>

<p>咱们来看一下整体的流程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*videoPacket = *videoFrameEncoderQueue.<span class="built_in">front</span>();</span><br><span class="line">videoFrameEncoderQueue.<span class="built_in">pop</span>(); </span><br><span class="line"><span class="built_in">av_packet_rescale_ts</span>(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);</span><br><span class="line">videoPacket-&gt;stream_index = videoStream-&gt;index;</span><br><span class="line">packetToWrite = videoPacket;</span><br><span class="line">streamIndex = videoStream-&gt;index;    </span><br></pre></td></tr></table></figure>
<p>其他的都不用多看哈，这里就两行比较重要，后面的都是逻辑处理的</p>
<p>1.转化时间基<br>av_packet_rescale_ts(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);</p>
<p>2.设置videoPacket的stream_index，这个非常重要，要不然不知道他是啥流</p>
<p><strong>av_interleaved_write_frame</strong></p>
<p>这里就是写的了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交错写入一个数据包到媒体文件中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 指向 AVFormatContext 的指针，表示要写入数据包的上下文。</span></span><br><span class="line"><span class="comment"> * @param pkt 指向 AVPacket 的指针，表示要写入的数据包。</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *  - 成功时返回 0。</span></span><br><span class="line"><span class="comment"> *  - 失败时返回负的错误码（参考 AVERROR 宏），例如：</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EINVAL)：输入参数无效。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(ENOMEM)：内存分配失败。</span></span><br><span class="line"><span class="comment"> *    - AVERROR(EAGAIN)：当前状态下不接受输入，需要先调用 avformat_write_header。</span></span><br><span class="line"><span class="comment"> *    - 其他负值：写入过程中发生错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_interleaved_write_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意哈，这里是交叉写入。这里可以搜一下为啥要交叉写入。</p>
<h4 id="同步的基本操作"><a href="#同步的基本操作" class="headerlink" title="同步的基本操作"></a>同步的基本操作</h4><p>后面就没啥了，但是这边还有一个比较重要的就是音频和视频的同步</p>
<p>如果不进行同步的话，就会发现 视频和音频各播各的</p>
<p>同步的思路：</p>
<p>获得到的视频和音频的 packet 先把两个包转化到同一个时间基下</p>
<p>比较一下那个时间基小，先把小的给写进取</p>
<p>（你品，你细品）</p>
<p>整体的代码(涉及的到线程的操作)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">videoOutMP4File</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* outFilePath)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//初始化输出 MP4 文件</span></span><br><span class="line">    AVFormatContext* outFormatCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">avformat_alloc_output_context2</span>(&amp;outFormatCtx, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, outFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!outFormatCtx) &#123;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法创建输出上下文&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建视频流</span></span><br><span class="line">    AVStream* videoStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">avcodec_parameters_from_context</span>(videoStream-&gt;codecpar, videoEncoderCtx);</span><br><span class="line">    videoStream-&gt;time_base = videoEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建音频流</span></span><br><span class="line">    AVStream* audioStream = <span class="built_in">avformat_new_stream</span>(outFormatCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">avcodec_parameters_from_context</span>(audioStream-&gt;codecpar, audioEncoderCtx);</span><br><span class="line">    audioStream-&gt;time_base = audioEncoderCtx-&gt;time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;outFormatCtx-&gt;pb, outFilePath, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法打开输出文件&quot;</span>&lt;&lt;endl;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入文件头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(outFormatCtx, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法写入文件头&quot;</span> &lt;&lt; endl;</span><br><span class="line">        audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">avio_closep</span>(&amp;outFormatCtx-&gt;pb);</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用完了解锁 上锁和解锁的顺序是反者的，防止死锁</span></span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临时变量</span></span><br><span class="line">    AVPacket* videoPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">    AVPacket* audioPacket = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环退出条件  只有当两个队列都是空的并且对视频和音频的编码的操作也都结束了才会停止 确保所有的数据都写进去</span></span><br><span class="line">    <span class="type">bool</span> videoDone = videoFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneVideoFrameEncoderReading;</span><br><span class="line">    <span class="type">bool</span> audioDone = audioFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneAudioFrameEncoderReading;</span><br><span class="line">    <span class="keyword">while</span> (!videoDone||!audioDone) &#123;</span><br><span class="line">        </span><br><span class="line">        AVPacket* packetToWrite = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> streamIndex = <span class="number">-1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">videoQueue</span><span class="params">(videoFrameEncoderMtx)</span></span>;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">audioQueue</span><span class="params">(audioFrameEncoderMtx)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待两个队列都有数据 或者两个队列都已经push完了，要保证两个队列之中都有数据</span></span><br><span class="line">            videoFrameEncoderCV.<span class="built_in">wait</span>(videoQueue,[]&#123;<span class="keyword">return</span> !videoFrameEncoderQueue.<span class="built_in">empty</span>()||doneVideoFrameEncoderReading; &#125;);</span><br><span class="line">            audioFrameEncoderCV.<span class="built_in">wait</span>(audioQueue,[]&#123;<span class="keyword">return</span> !audioFrameEncoderQueue.<span class="built_in">empty</span>()||doneAudioFrameEncoderReading; &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取音视频当前时间戳，要放在确定的时间基下</span></span><br><span class="line">            <span class="type">int64_t</span> video_pts = (!videoFrameEncoderQueue.<span class="built_in">empty</span>()) ? </span><br><span class="line">                <span class="built_in">av_rescale_q</span>(videoFrameEncoderQueue.<span class="built_in">front</span>()-&gt;pts,videoEncoderCtx-&gt;time_base,videoStream-&gt;time_base):INT64_MAX;</span><br><span class="line">            <span class="type">int64_t</span> audio_pts = (!audioFrameEncoderQueue.<span class="built_in">empty</span>()) ? </span><br><span class="line">                <span class="built_in">av_rescale_q</span>(audioFrameEncoderQueue.<span class="built_in">front</span>()-&gt;pts,audioEncoderCtx-&gt;time_base,audioStream-&gt;time_base):INT64_MAX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择时间戳较小的帧进行写入</span></span><br><span class="line">            <span class="keyword">if</span> (!videoFrameEncoderQueue.<span class="built_in">empty</span>()&amp;&amp;</span><br><span class="line">            (audioFrameEncoderQueue.<span class="built_in">empty</span>()||</span><br><span class="line">            <span class="built_in">av_compare_ts</span>(video_pts,videoStream-&gt;time_base,audio_pts,audioStream-&gt;time_base)&lt;=<span class="number">0</span>)) &#123;     <span class="comment">//通过av_compare_ts作比较（不同的时间基下）</span></span><br><span class="line">                *videoPacket = *videoFrameEncoderQueue.<span class="built_in">front</span>();                                         <span class="comment">//取包</span></span><br><span class="line">                videoFrameEncoderQueue.<span class="built_in">pop</span>();                                                           <span class="comment">//pop</span></span><br><span class="line">                <span class="built_in">av_packet_rescale_ts</span>(videoPacket, videoEncoderCtx-&gt;time_base, videoStream-&gt;time_base);  <span class="comment">//转化到对应的时间基下</span></span><br><span class="line">                videoPacket-&gt;stream_index = videoStream-&gt;index;                                         <span class="comment">//设置stream_index（视频的）</span></span><br><span class="line">                packetToWrite = videoPacket;                                                            <span class="comment">//拷贝过来（这里还没有写入）</span></span><br><span class="line">                streamIndex = videoStream-&gt;index;                                                       <span class="comment">//当前的index（后面是醋糊错误信息用）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!audioFrameEncoderQueue.<span class="built_in">empty</span>()) &#123;                                               <span class="comment">//下面是一样的流程</span></span><br><span class="line">                *audioPacket = *audioFrameEncoderQueue.<span class="built_in">front</span>();</span><br><span class="line">                audioFrameEncoderQueue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">av_packet_rescale_ts</span>(audioPacket, audioEncoderCtx-&gt;time_base, audioStream-&gt;time_base);</span><br><span class="line">                audioPacket-&gt;stream_index = audioStream-&gt;index;</span><br><span class="line">                packetToWrite = audioPacket;</span><br><span class="line">                streamIndex = audioStream-&gt;index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//while结束条件 只有当两个队列都是空的并且对视频和音频的编码的操作也都结束了才会停止</span></span><br><span class="line">            videoDone = videoFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneVideoFrameEncoderReading;</span><br><span class="line">            audioDone = audioFrameEncoderQueue.<span class="built_in">empty</span>() &amp;&amp; doneAudioFrameEncoderReading;</span><br><span class="line">            audioQueue.<span class="built_in">unlock</span>();</span><br><span class="line">            videoQueue.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packetToWrite) &#123;  <span class="comment">//这里一定要注意不可以视频和音频是交叉写入的，这样才是正确的效果（之前老师让我哦门使用CSV输出的信息的时候可以观察到）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_interleaved_write_frame</span>(outFormatCtx, packetToWrite) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;写入包失败: &quot;</span>&lt;&lt;streamIndex&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(packetToWrite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">avcodec_send_frame</span>(videoEncoderCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    videoEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">avcodec_send_frame</span>(audioEncoderCtx, <span class="literal">nullptr</span>);</span><br><span class="line">    audioEncoderCtxMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;videoPacket);</span><br><span class="line">    <span class="built_in">av_packet_free</span>(&amp;audioPacket);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(outFormatCtx);</span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;outFormatCtx-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(outFormatCtx);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--线程写入MP4完成！--&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>说实话有些不想写了，前面已经把所有的基本的流程给介绍过了，这里最多补充一下细节</p>
<h2 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h2><p>地址：<a target="_blank" rel="noopener" href="https://github.com/zqzhang2023/zzqStudy/tree/main/project/1_ffmpeg">https://github.com/zqzhang2023/zzqStudy/tree/main/project/1_ffmpeg</a></p>
<p>环境：</p>
<p>linux ubuntu 20.04</p>
<p>C++ 11</p>
<p>ffmpeg（这个有没有都可以）</p>
<p>cmake</p>
<p>进入根目录文件夹</p>
<p>然后</p>
<p>cd build</p>
<p>cmake ..</p>
<p>make</p>
<p>.&#x2F;transcode</p>
<p>(要处理的是视频文件在resources里面 1.mp4 输出为 2.mp4)</p>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p><strong>transcode.cpp</strong>                 为入口程序</p>
<p><strong>lib&#x2F;include&#x2F;manageAll.h</strong>       为管理全局变量和函数以及参数的头文件</p>
<p><strong>src&#x2F;initGlobalVariable.cpp</strong>    为全局变量以及参数的初始化和释放</p>
<p><strong>src&#x2F;productionPackage.cpp</strong>     实现了拆分音视频为音频包和视频包的线程</p>
<p><strong>src&#x2F;videoAnalysis.cpp</strong>         实现了对视频包进行解码成视频帧的线程</p>
<p><strong>src&#x2F;videoFrameEncoding.cpp</strong>    实现了对视频帧重新编码成为视频包的线程</p>
<p><strong>src&#x2F;audioAnalysis.cpp</strong>         实现了对音频包进行解码成音频帧的线程</p>
<p><strong>src&#x2F;audioFrameEncoding.cpp</strong>    实现了对音频帧重新编码成为音频包的线程</p>
<p><strong>src&#x2F;videoOutMP4File.cpp</strong>       实现了重新整合音频包和视频包为MP4文件的线程</p>
<p><strong>lib&#x2F;include&#x2F;queue.h</strong>           队列的声明与实现</p>
<p><strong>lib&#x2F;include&#x2F;circularbuffer.h</strong>  环形缓冲区的声明与实现</p>
<h2 id="ffmpeg-库的编译"><a href="#ffmpeg-库的编译" class="headerlink" title="ffmpeg 库的编译"></a>ffmpeg 库的编译</h2><p>就是把ffmpeg的库编译成静态库，然后后面咱们使用的话就可以直接用这个库，不需要安装ffmpeg</p>
<p>这里很方便，比如我把我写的这些东西复制给其他人，他们不需要再配置ffmpeg的环境了，可以直接运行起来</p>
<p>（我现在的机子里面就没装ffmpeg，也可以正常运行）</p>
<p>方法：</p>
<p>1.把源码下下来 <a target="_blank" rel="noopener" href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p>
<p>找一下适合的版本号就好</p>
<p>2.进入根目录创建一个build.sh的空文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PREFIX=<span class="string">&quot;/home/ubuntu2204/ffmpge/out_one&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">build</span></span>() &#123;   </span><br><span class="line">    make clean</span><br><span class="line">    ./configure \</span><br><span class="line">        --disable-shared \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --disable-doc \</span><br><span class="line">        --disable-programs \</span><br><span class="line">        --enable-avcodec \</span><br><span class="line">        --enable-avfilter \</span><br><span class="line">        --enable-avformat \</span><br><span class="line">        --enable-avutil \</span><br><span class="line">        --enable-swscale \</span><br><span class="line">        --enable-swresample \</span><br><span class="line">        --prefix=<span class="string">&quot;<span class="variable">$PREFIX</span>&quot;</span> \</span><br><span class="line">        --extra-cflags=<span class="string">&quot;-fPIC&quot;</span> \</span><br><span class="line">        --extra-ldflags=<span class="string">&quot;-Wl,-rpath=&#x27;\$ORIGIN&#x27;&quot;</span> </span><br><span class="line"></span><br><span class="line">    make -j$(<span class="built_in">nproc</span>) </span><br><span class="line">    make install</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用gcc链接共享库</span></span><br><span class="line">    gcc -shared -o libffmpeg.so \</span><br><span class="line">        -Wl,--whole-archive \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavcodec.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavfilter.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavformat.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libswscale.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libswresample.a&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$PREFIX</span>/lib/libavutil.a&quot;</span> \</span><br><span class="line">        -Wl,--no-whole-archive \</span><br><span class="line">        -Wl,-Bsymbolic -Wl,--no-undefined \</span><br><span class="line">        -lm -lz -pthread -ldl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译</span></span><br><span class="line">build</span><br></pre></td></tr></table></figure>

<p>PREFIX 是 输出的目录</p>
<p>里面会有 一个  libffmpeg.so 的文件 还有 一个include文件夹，记得把这些都复制过来</p>
<p>为什么要有include 头文件，因为libffmpeg.so相当于对头文件的实现，必须得有include文件咱们才能在代码里面用</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>先写到这吧，一天复习了整个项目的流程，实在不想写了。等下次有时间再去写吧。不说了背八股去了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张振强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/17/ffmpeg/">http://example.com/2025/04/17/ffmpeg/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">张振强的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img class="cover" src="/img/load4.gif" data-original="/img/cover/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">tinyWebServer</div></div><div class="info-2"><div class="info-item-1">tinyWebServer 项目写在前面： 学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。 刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急，可以提前了解一下项目的知识再重新来做一下。 于是就先做了三个小项目，每个项目都挺经典的，而且项目的代码量也很小。  线程池的项目：(主要学习线程池的概念和用法) 项目介绍：https://blog.zqzhang2025.com/2025/04/13/ThreadPool/ git链接：https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool   tinyhttpd...</div></div></div></a><a class="pagination-related" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img class="cover" src="/img/load4.gif" data-original="/img/cover/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">基于IPV4的流媒体广播</div></div><div class="info-2"><div class="info-item-1">基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃） 运行起来原项目git：https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4 环境: Ubuntu 20.04...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/13/C++Thread/" title="C++ Thread"><img class="cover" src="/img/load4.gif" data-original="/img/cover/3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ Thread</div></div><div class="info-2"><div class="info-item-1">C++线程基本介绍：1.多线程的含义 多线程（multithreading），是指在软件或者硬件上实现多个线程并发执行的技术。具有多核CPU的支持的计算机能够真正在同一时间执行多个程序片段，进而提升程序的处理性能。在一个程序中，这些独立运行的程序片段被称为“线程”（Thread），利用其编程的概念就叫作“多线程处理”。 2.进程与线程的区别 进程是指一个程序的运行实例，而线程是指进程中独立的执行流程。一个进程可以有多个线程，多个线程之间可以并发执行。  一个程序有且只有一个进程，但可以拥有至少一个的线程。  不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。   线程创建thread #include&lt;iostream&gt;#include&lt;thread&gt;using namespace std;void ThreadFunctionA(int A)&#123;    for(int i=0;i&lt;A;i++)&#123;        cout&lt;&lt;&quot;线程...</div></div></div></a><a class="pagination-related" href="/2025/04/13/C++STL/" title="C++ STL"><img class="cover" src="/img/load4.gif" data-original="/img/cover/8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ STL</div></div><div class="info-2"><div class="info-item-1">简单的学习以下C++的STL基本概念：STL主要分为分为三类：  algorithm（算法）  -   对数据进行处理(解决问题)步骤的有限集合  container（容器）  -   用来管理一组数据元素  Iterator  (迭代器) -   可遍历STL容器内全部或部分元素的对象   容器 &lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt;...</div></div></div></a><a class="pagination-related" href="/2025/04/13/C++base/" title="C++ base"><img class="cover" src="/img/load4.gif" data-original="/img/cover/8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ base</div></div><div class="info-2"><div class="info-item-1">C++基础资料：https://blog.csdn.net/weixin_44368437/article/details/117563488 C++与 C...</div></div></div></a><a class="pagination-related" href="/2025/04/13/C++friend/" title="C++ friend"><img class="cover" src="/img/load4.gif" data-original="/img/cover/6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ friend</div></div><div class="info-2"><div class="info-item-1">C++友元使用前提：某个类需要实现某种功能，但是这个类自身，因为各种原因，无法自己实现。 需要借助于“外力”才能实现。 友元的两种使用形式：友元函数、友元类。 友元函数使用全局函数作为友元函数全局函数可以直接访问类内的私有成员！！！！！ #include&lt;iostream&gt;#include &lt;sstream&gt;using namespace std;class Computer &#123; public:    Computer()&#123;        cpu = &quot;i7&quot;;    &#125;;    // 使用全局函数作为友元函数    friend void upgrade(Computer* computer);    string description()&#123;        stringstream ret;         ret &lt;&lt; &quot;CPU:&quot; &lt;&lt; cpu;         return ret.str();    &#125;;private:    ...</div></div></div></a><a class="pagination-related" href="/2025/04/13/C++exception/" title="C++ exception"><img class="cover" src="/img/load4.gif" data-original="/img/cover/10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ exception</div></div><div class="info-2"><div class="info-item-1">C++异常处理异常无处不在，程序随时可能误入歧途！C++ 提出了新的异常处理机制！ 异常是一种程序控制机制，与函数机制互补 函数是一种以栈结构展开的上下函数衔接的程序控制系统,异常是另一种控制结构,它可以在出现“意外”时中断当前函数,并以某种机制（类型匹配）回馈给隔代的调用者相关的信息. 传统错误处理机制通过函数返回值来处理错误 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define BUFSIZE 1024 //实现文件的二进制拷贝int copyfile(const char *dest,const char *src)&#123;	FILE *fp1 = NULL, *fp2 = NULL; 	//rb 只读方式打开一个二进制文件，只允许读取数据	fopen_s(&amp;fp1, src, &quot;rb&quot;); 	if(fp1 == NULL)&#123;		return -1;	&#125; 	//wb 以只写的方式打开或新建一个二进制文件，只允许写数据。	fopen_s(&amp;fp2,...</div></div></div></a><a class="pagination-related" href="/2025/04/13/C++operaOvlod/" title="C++ operaOvlod"><img class="cover" src="/img/load4.gif" data-original="/img/cover/3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">C++ operaOvlod</div></div><div class="info-2"><div class="info-item-1">C++运算法重载C&#x2F;C++的运算符，支持的数据类型，仅限于基本数据类型。 问题：  一头牛+一头马 &#x3D; ？（牛马神兽？）  一个圆 +一个圆 &#x3D; ？ （想要变成一个更大的圆）  一头牛 – 一只羊 &#x3D; ？ (想要变成 4 只羊，原始的以物易物：1 头牛价值 5 只羊)   解决方案：使用运算符重载 那些可以重载  为了防止对标准类型进行运算符重载，   C++规定重载运算符的操作对象至少有一个不是标准类型，而是用户自定义的类型比如不能重载 1+2 但是可以重载            cow + 2 和 2 + cow    // cow 是自定义的对象   不能改变原运算符的语法规则， 比如不能把双目运算符重载为单目运算  不能改变原运算符的优先级  不能创建新的运算符，比如 operator*就是非法的, operator是可以的  不能对以下这四种运算符，使用友元函数进行重载&#x3D; 赋值运算符，（）函数调用运算符，[...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张振强</div><div class="author-info-description">咱们都是最棒的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zqzhang2023"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zqzhang2023" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_45769058" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1611379529&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:bzzhenqiang@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-FFMPEG-%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">C++ FFMPEG 项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FFMPEG%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">FFMPEG介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">基本流程介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACAPI%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.</span> <span class="toc-text">基本API介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.打开文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">涉及到的结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E6%B5%81%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.获取流信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8B%86%E5%88%86%E8%A7%86%E9%A2%91%E5%8C%85%E4%B8%8E%E9%9F%B3%E9%A2%91%E5%8C%85"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.拆分视频包与音频包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">涉及到的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API-2"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E7%A0%81%E5%8C%85"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.解码包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">涉及到的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API-3"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%84%E7%90%86%E8%A7%A3%E7%A0%81%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.5.</span> <span class="toc-text">5.处理解码之后的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%8D%E7%BC%96%E7%A0%81%E5%9B%9E%E5%8E%BB"><span class="toc-number">2.2.6.</span> <span class="toc-text">6.再编码回去</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84-2"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">涉及到的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API-4"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9C%80%E5%90%8E%E5%B0%B1%E6%98%AF%E5%B0%81%E8%A3%85%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BA%86"><span class="toc-number">2.2.7.</span> <span class="toc-text">7.最后就是封装在一起了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84-3"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">涉及到的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API-5"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">涉及到的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">同步的基本操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">项目介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5"><span class="toc-number">3.1.</span> <span class="toc-text">运行起来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">文件说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ffmpeg-%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91"><span class="toc-number">3.3.</span> <span class="toc-text">ffmpeg 库的编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"><span class="toc-number">4.</span> <span class="toc-text">未完待续</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/muduo/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/07/17/muduo/" title="chatRoom">chatRoom</a><time datetime="2025-07-17T02:05:26.162Z" title="发表于 2025-07-17 10:05:26">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img src="/img/load4.gif" data-original="/img/cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于IPV4的流媒体广播"/></a><div class="content"><a class="title" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播">基于IPV4的流媒体广播</a><time datetime="2025-05-07T09:43:42.756Z" title="发表于 2025-05-07 17:43:42">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img src="/img/load4.gif" data-original="/img/cover/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ffmpeg"/></a><div class="content"><a class="title" href="/2025/04/17/ffmpeg/" title="ffmpeg">ffmpeg</a><time datetime="2025-04-17T14:51:36.000Z" title="发表于 2025-04-17 22:51:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img src="/img/load4.gif" data-original="/img/cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tinyWebServer"/></a><div class="content"><a class="title" href="/2025/04/15/tinyWebServer/" title="tinyWebServer">tinyWebServer</a><time datetime="2025-04-15T14:58:54.000Z" title="发表于 2025-04-15 22:58:54">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/chatRoom/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/04/15/chatRoom/" title="chatRoom">chatRoom</a><time datetime="2025-04-15T14:57:54.000Z" title="发表于 2025-04-15 22:57:54">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 张振强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>