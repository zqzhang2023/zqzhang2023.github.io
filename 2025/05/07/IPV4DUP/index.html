<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基于IPV4的流媒体广播 | 张振强的个人博客</title><meta name="author" content="张振强"><meta name="copyright" content="张振强"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收">
<meta property="og:type" content="article">
<meta property="og:title" content="基于IPV4的流媒体广播">
<meta property="og:url" content="http://example.com/2025/05/07/IPV4DUP/index.html">
<meta property="og:site_name" content="张振强的个人博客">
<meta property="og:description" content="基于IPV4的流媒体广播这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。 服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播） 客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来（是不是感觉挺高大上的，其实不是，只是简单的接收">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/1.png">
<meta property="article:published_time" content="2025-05-07T09:43:42.756Z">
<meta property="article:modified_time" content="2025-07-17T02:07:41.129Z">
<meta property="article:author" content="张振强">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基于IPV4的流媒体广播",
  "url": "http://example.com/2025/05/07/IPV4DUP/",
  "image": "http://example.com/img/cover/1.png",
  "datePublished": "2025-05-07T09:43:42.756Z",
  "dateModified": "2025-07-17T02:07:41.129Z",
  "author": [
    {
      "@type": "Person",
      "name": "张振强",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_1.png"><link rel="canonical" href="http://example.com/2025/05/07/IPV4DUP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于IPV4的流媒体广播',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/index_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">张振强的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">基于IPV4的流媒体广播</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基于IPV4的流媒体广播</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-07T09:43:42.756Z" title="发表于 2025-05-07 17:43:42">2025-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-17T02:07:41.129Z" title="更新于 2025-07-17 10:07:41">2025-07-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E9%A1%B9%E7%9B%AE/">C++ 项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="基于IPV4的流媒体广播"><a href="#基于IPV4的流媒体广播" class="headerlink" title="基于IPV4的流媒体广播"></a>基于IPV4的流媒体广播</h1><p>这个项目和webserver挺像的，但是这个是基于UDP的，实现了一个组播。有服务端和客户端两个。</p>
<p>服务端：主要是不停的向外广播自己的节目单和节目内容（没错，就算没有客户端开启，也会一直广播）</p>
<p>客户端：主要是根据自己的需求订阅服务端的节目单，然后接收相应的节目数据，传递给ffmpeg，让ffmpeg来解析一下内容，然后播放出来<br>（是不是感觉挺高大上的，其实不是，只是简单的接收所有的数据，然后判断这个数据里面的ID是不是自己选择的就好，是自己选择的就保留，不是就丢弃）</p>
<h1 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h1><p>原项目git：<a target="_blank" rel="noopener" href="https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4">https://github.com/litbubo/Streaming_media_broadcasting_system_based_on_IPv4</a></p>
<p>环境: Ubuntu 20.04 ffmpeg</p>
<p>还需要下载一个ffmepg包，这个是啥包我忘记了，但是在运行client的时候会发现只会接收一个UDP包的数据</p>
<p>这是因为缺少了这个包。接收数据之后会馈入ffmpeg里面，因为缺少了这个包，所以才会只接收一个数据之后就断掉</p>
<p>终端上会有提示，到时候直接ubuntu命令下载即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终端-1 server</span></span><br><span class="line">cd server</span><br><span class="line">make</span><br><span class="line">./server</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端-2 client</span></span><br><span class="line">cd client</span><br><span class="line">./start.<span class="built_in">sh</span></span><br><span class="line"></span><br><span class="line">(这里不是简单的接收数据，ffmpeg是可以正常播放出来音乐的，放不出来可能是虚拟机的问题，我这边是可以正常放出来的)</span><br></pre></td></tr></table></figure>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6_IPV4UDP/</span><br><span class="line">├── client</span><br><span class="line">│   ├── client.c</span><br><span class="line">│   ├── client.h</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── start.sh</span><br><span class="line">├── include</span><br><span class="line">│   └── protocol.h</span><br><span class="line">├── medialib</span><br><span class="line">│   ├── ch1</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 世界这么大还是遇见你.mp3</span><br><span class="line">│   │   └── 起风了.mp3</span><br><span class="line">│   ├── ch2</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 带你去旅行.mp3</span><br><span class="line">│   │   └── 再见只是陌生人.mp3</span><br><span class="line">│   ├── ch3</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── Summertime Sadness.mp3</span><br><span class="line">│   │   └── 学猫叫.mp3</span><br><span class="line">│   └── ch4</span><br><span class="line">├── server</span><br><span class="line">│   ├── channel.c</span><br><span class="line">│   ├── channel.h       //每个频道的广播</span><br><span class="line">│   ├── list.c</span><br><span class="line">│   ├── list.h          //节目单广播</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── medialib.c</span><br><span class="line">│   ├── medialib.h      //medialib转化为广播频道</span><br><span class="line">│   ├── server.c</span><br><span class="line">│   ├── server_conf.h   //服务端的一些基础的配置</span><br><span class="line">│   ├── threadpool.c</span><br><span class="line">│   ├── threadpool.h    //线程池</span><br><span class="line">│   ├── tokenbucket.c</span><br><span class="line">│   └── tokenbucket.h   //令牌桶，负责流量控制</span><br><span class="line">├── README.md</span><br><span class="line">├── LICENSE</span><br><span class="line">└── Streaming_media_broadcasting_system_based_on_IPv4.code-workspace</span><br></pre></td></tr></table></figure>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>protocol.h 文件，这里面定义了很多的基本的配置，比如：多播组的地址，默认的端口号，还有节目单，频道的格式等。</p>
<p>代码:这里面不涉及啥复杂的操作，看一看即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PROTOCOL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PROTOCOL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> <span class="type">chnid_t</span>;    <span class="comment">//定义频道ID类型为8位无符号整数，范围0~255，节省空间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MGROUP     <span class="string">&quot;224.2.2.2&quot;</span> <span class="comment">// 多播组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_RECVPORT   <span class="string">&quot;1989&quot;</span>      <span class="comment">// 默认端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHANNR             100         <span class="comment">// 最大频道数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTCHNID          0           <span class="comment">// 约定 0 号为节目单频道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINCHNID           1           <span class="comment">// 最小广播频道号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHNID           (CHANNR - MINCHNID)  <span class="comment">// 最大广播频道号 100 - 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_CHANNEL_MAX    (65536U - 20U - 8U)  <span class="comment">// 最大频道数据包  20U IP头   8U UDP头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CHANNEL_DATA   (MSG_CHANNEL_MAX - sizeof(chnid_t)) <span class="comment">//MSG_CHANNEL_MAX去除掉一个 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_LISTCHN_MAX     (65536U - 20U - 8U) <span class="comment">// 最大节目单数据包  20U IP头   8U UDP头</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LISTCHN_DATA    (MSG_LISTCHN_MAX - sizeof(chnid_t))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 频道包，第一字节描述频道号，data[0]在结构体最后作用为变长数组，根据malloc到的实际内存大小决定 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_channel_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;             <span class="comment">// must between MINCHNID MAXCHNID 频道号（1字节） 取值范围MINCHNID~MAXCHNID</span></span><br><span class="line">    <span class="type">uint8_t</span> data[<span class="number">0</span>];           <span class="comment">// 柔性数组，实际数据存储位置（长度由MAX_DATA决定）</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">msg_channel_t</span>;  <span class="comment">//不做对其，因为chnid就只有一个字节， data 通常会很大（这个我还不是很理解，对其的话chnid不是最多也就是4个字节码，感觉有没有这个没多大差）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单个节目信息，第一字节描述频道号，第二三字节为本条信息的总字节数，desc[0]为变长数组 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_listdesc_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;             <span class="comment">// 频道号（1字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> deslength;        <span class="comment">// 自述包长度 描述信息长度</span></span><br><span class="line">    <span class="type">uint8_t</span> desc[<span class="number">0</span>];           <span class="comment">// 柔性数组，存储频道描述文本（UTF-8格式）</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">msg_listdesc_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 节目单数据包，第一字节描述频道号，list[0]为变长数组，存储msg_listdesc_t变长内容 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msg_list_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;           <span class="comment">// 频道号（1字节）</span></span><br><span class="line">    <span class="type">msg_listdesc_t</span> list[<span class="number">0</span>];  <span class="comment">// 柔性数组，包含多个节目条目</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msg_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><p>需要完成的任务:</p>
<p>1.将medialib目录下的文件转化为广播频道  </p>
<p>2.广播节目单</p>
<p>3.广播频道内容</p>
<p>整体的复现思路：</p>
<p>1.server_conf.h 里面有一些服务端的基础配置</p>
<p>2.threadpool 这个比较独立，就是基础的线程池，用来管理线程。不依赖于其他模块</p>
<p>3.tokenbucket 令牌桶，用来控制流量，防止流量过大</p>
<p>4.medialib 主要是将medialib目录下的文件转化为广播频道，然后通过list广播节目单，通过channel广播频道内容</p>
<p>5.channel 主要是广播频道内容</p>
<p>6.list 主要是广播节目单</p>
<p>7.server 主要是管理线程池，然后调用list和channel来广播节目单和频道内容</p>
<p>按照这个思路，依次完成各个模块，然后最后整合起来，就可以完成服务端了</p>
<h3 id="server-conf-h"><a href="#server-conf-h" class="headerlink" title="server_conf.h"></a>server_conf.h</h3><p>没啥好说的，直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVER_CONF_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVER_CONF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MEDIADIR <span class="string">&quot;/var/medialib&quot;</span>    <span class="comment">// 默认本地媒体库路径</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_IF <span class="string">&quot;ens33&quot;</span>                  <span class="comment">// 默认网卡</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行模式，守护进程会把进程放到后台</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RNUMODE</span>                                <span class="comment">// 运行模式    </span></span><br><span class="line">&#123;</span><br><span class="line">    RUN_DAEMON = <span class="number">0</span>,                         <span class="comment">// 守护进程</span></span><br><span class="line">    RUN_FOREGROUND                          <span class="comment">// 前台运行</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">server_conf_t</span>                <span class="comment">// 配置文件,</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *mgroup;                           <span class="comment">// [字符串] 组播组IP地址（如：&quot;239.0.0.1&quot;）</span></span><br><span class="line">    <span class="type">char</span> *rcvport;                          <span class="comment">// [字符串] 接收端口号（如：&quot;8080&quot;）</span></span><br><span class="line">    <span class="type">char</span> *media_dir;                        <span class="comment">// [字符串] 媒体文件存储目录路径</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">RNUMODE</span> runmode;                   <span class="comment">// [字符] 运行模式（使用上述枚举值：RUN_DAEMON/RUN_FOREGROUND）</span></span><br><span class="line">    <span class="type">char</span> *ifname;                           <span class="comment">// [字符串] 网络接口名称（用于绑定组播）</span></span><br><span class="line">&#125; <span class="type">server_conf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">server_conf_t</span> server_conf;           <span class="comment">// 配置文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> serversd;                        <span class="comment">// 服务端套接字</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sndaddr;          <span class="comment">// 发送目的地址</span></span><br><span class="line"><span class="keyword">extern</span> ThreadPool_t *pool;                  <span class="comment">// 线程池对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__SERVER_CONF_H__</span></span></span><br></pre></td></tr></table></figure>

<h3 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h3><p>这个要说一下，我之前做过webserver的项目，那个里面的线程池比较简单，就是单纯的addtask，然后执行任务就可以了，但是这个项目里面的线程池构造的很巧妙，如果看了代码就可以很好理解。</p>
<p>首先最基本的功能肯定是有的，就是addTask，然后执行任务</p>
<p>这里面还附加了另外的功能，就是设置了一个管理的线程，这个管理的线程用于管理线程池中线程的数量，当任务不多的时候，没必要保存那么多线程，这个时候就可以kill掉一些，当然会有一个最小的数量。当任务很多的时候，就需要额外申请一些线程，但是这个数量也是有限制的。</p>
<p>这样来实现线程数量的动态管理，不会因为空线程而浪费太多的CPU资源</p>
<p>有几个注意的点:</p>
<p>1.NUMSTEP, 每次进行添加和删除线程都会增加或者删除 NUMSTEP 多的线程。不会说一下子减少到最少，或者是一下子添加到最大。拿减少的来举例：如果检测到很多线程空闲，我先减少NUMSTEP个线程，然后再次检测，如果还是空闲，我再减少NUMSTEP多线程。</p>
<p>2.numExit 这个设置的就很巧妙，就是如果我要删除掉一个线程，我就把numExit设置为1，并且notify一下，线程在working (在working函数里面) 的时候，先检测一下numExit是不是1 (这里肯定是要加锁的哈)，如果是1，那么我就不去task，直接退出（自杀）就好了，顺便把numExit–（上锁哈）。是不是感觉很巧妙</p>
<p>3.这里面有个独立出来的manage的线程哈，这个别忘记了，执行的是manager函数，里面就涉及到了之前说的一些线程的增加与删除等操作</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THREADPOOL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __THREADPOOL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG                                // 定义宏，DEBUG模式，打印尽可能多的的log信息，注释则不打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> ThreadPool_t;                      <span class="comment">// 对外隐藏ThreadPool_t内部实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_create</span></span><br><span class="line"><span class="comment"> * @description		: 线程池创建函数，创建一个线程池</span></span><br><span class="line"><span class="comment"> * @param - min 	: 最小线程池数</span></span><br><span class="line"><span class="comment"> * @param - max 	: 最大线程池数</span></span><br><span class="line"><span class="comment"> * @param - queueCapacity : 最大任务队列数</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 NULL，成功返回线程池对象地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadPool_t* <span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">int</span> queueCapacity)</span></span>;                     <span class="comment">// 新创建一个线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_addtask</span></span><br><span class="line"><span class="comment"> * @description		: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要添加任务的线程池</span></span><br><span class="line"><span class="comment"> * @param - function: 任务函数 void (*)(void *, volatile int *) 函数指针  【返回类型 (*指针变量名)(参数列表)】</span></span><br><span class="line"><span class="comment"> * @param - arg     : 任务函数参数</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_addtask</span><span class="params">(ThreadPool_t *, <span class="type">void</span> (*)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span> *), <span class="type">void</span> *)</span></span>;       <span class="comment">// 向任务队列添加一个任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @description		: 线程池销毁函数，销毁一个线程池</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要销毁的线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(ThreadPool_t *)</span></span>;                                                 <span class="comment">// 销毁一个线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadexit_unlock</span></span><br><span class="line"><span class="comment"> * @description		: 线程退出函数，并将该线程 ID 从工作者线程数组中删除</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadexit_unlock</span><span class="params">(ThreadPool_t *)</span></span>;                                                 <span class="comment">// 线程退出函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_live</span></span><br><span class="line"><span class="comment"> * @description		: 获取线程池中存活线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 线程池中存活线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_live</span><span class="params">(ThreadPool_t *)</span></span>;                                                   <span class="comment">// 获得线程池中的存活线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_busy</span></span><br><span class="line"><span class="comment"> * @description		: 获取线程池中忙线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 线程池中忙线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_busy</span><span class="params">(ThreadPool_t *)</span></span>;                                                   <span class="comment">// 获得线程池中的忙线程数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadpool.cs</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMSTEP 5      <span class="comment">// 线程增减步长</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024   <span class="comment">// 状态显示缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Task_t</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*function)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span> *);   <span class="comment">// 任务函数指针</span></span><br><span class="line">    <span class="type">void</span> *arg;                                  <span class="comment">// 任务参数</span></span><br><span class="line">&#125; Task_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程池类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span>&#123; </span><br><span class="line">    <span class="comment">// 任务队列相关</span></span><br><span class="line">    Task_t *taskQueue;          <span class="comment">// 任务队列数组</span></span><br><span class="line">    <span class="type">int</span> queueCapacity;          <span class="comment">// 任务队列最大容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;              <span class="comment">// 任务队列当前任务数</span></span><br><span class="line">    <span class="type">int</span> queueRear;              <span class="comment">// 队尾</span></span><br><span class="line">    <span class="type">int</span> queueFront;             <span class="comment">// 队头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程管理相关</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;        <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *workerIDs;       <span class="comment">// 工作者线程ID数组</span></span><br><span class="line">    <span class="type">int</span> numMax;                 <span class="comment">// 工作者线程最大的线程数</span></span><br><span class="line">    <span class="type">int</span> numMin;                 <span class="comment">// 工作者线程最小的线程数</span></span><br><span class="line">    <span class="type">int</span> numLive;                <span class="comment">// 工作者线程存活的线程数</span></span><br><span class="line">    <span class="type">int</span> numBusy;                <span class="comment">// 工作者线程忙的线程数</span></span><br><span class="line">    <span class="type">int</span> numExit;                <span class="comment">// 工作者线程需要退出的线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步机制</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 线程池锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 忙线程数锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 非满条件变量，用于唤醒生产者(添加任务函数)</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 非空条件变量，用于唤醒消费者(工作者线程)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> shutstatus;             <span class="comment">// 线程池状态，0 打开，-1 关闭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEBUG 模式下 调试函数：图形化显示线程状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printstatus</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> numLive, numBusy;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程状态</span></span><br><span class="line">    numLive = <span class="built_in">get_thread_live</span>(pool);</span><br><span class="line">    numBusy = <span class="built_in">get_thread_busy</span>(pool);</span><br><span class="line">    <span class="comment">// 构建状态字符串：&#x27;+&#x27;表示忙碌，&#x27;-&#x27;表示空闲</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numBusy; i++)</span><br><span class="line">        <span class="built_in">strcat</span>(buf, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numLive - numBusy; i++)</span><br><span class="line">        <span class="built_in">strcat</span>(buf, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出格式：[++++++++++-----] : busy=10, live=15</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[ %s ] : busy == %d, live == %d\n&quot;</span>, buf, numBusy, numLive);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : working</span></span><br><span class="line"><span class="comment"> * @description		: 工作者线程任务函数，负责从任务队列中取出任务并执行</span></span><br><span class="line"><span class="comment"> * @param - arg 	: 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">working</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)arg;</span><br><span class="line">    Task_t task;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line">    <span class="comment">// 阻塞所有信号，避免工作线程处理信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);  <span class="comment">// 加线程池锁</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; pool-&gt;shutstatus == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool); <span class="comment">// 阻塞直到任务队列不为空</span></span><br><span class="line">            <span class="comment">// 被唤醒后检查是否需要退出线程</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;numExit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;numExit--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;numLive &gt; pool-&gt;numMin)&#123;</span><br><span class="line">                    pool-&gt;numLive--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    <span class="built_in">threadexit_unlock</span>(pool); <span class="comment">// 执行线程退出流程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutstatus == <span class="number">-1</span>) <span class="comment">// 若线程池已经关闭，线程自杀</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="built_in">threadexit_unlock</span>(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列之中取任务</span></span><br><span class="line">        task.function = pool-&gt;taskQueue[pool-&gt;queueFront].function;      <span class="comment">// 取出任务</span></span><br><span class="line">        task.arg = pool-&gt;taskQueue[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pool-&gt;taskQueue[pool-&gt;queueFront], <span class="number">0</span>, <span class="built_in">sizeof</span>(Task_t));   <span class="comment">// 从队列取出任务后，将队列中相应任务清空</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity; <span class="comment">// 移动队头指针</span></span><br><span class="line">        pool-&gt;queueSize--;                                               <span class="comment">// 任务队列中任务数量-1</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notFull);                             <span class="comment">// 唤醒任务生产者 //取出来一个任务后有空位置了自然要处理一下</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy); <span class="comment">// 加锁，改变线程池中忙线程数</span></span><br><span class="line">        pool-&gt;numBusy++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is going to work...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">        task.<span class="built_in">function</span>(task.arg, &amp;(pool-&gt;shutstatus)); <span class="comment">// 执行任务</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is done work...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">free</span>(task.arg); <span class="comment">// 释放任务资源</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread [%ld] is free successful...&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is free successful...\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">        task.function = <span class="literal">NULL</span>;</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;numBusy--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="built_in">sched_yield</span>(); <span class="comment">// 出让调度器给其他线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : manager</span></span><br><span class="line"><span class="comment"> * @description		: 管理者线程任务函数，负责监视、增加和减少线程池中线程的存活线程数量</span></span><br><span class="line"><span class="comment"> * @param - arg 	: 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">manager</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="type">int</span> numLive, numBusy, queueSize;</span><br><span class="line">    <span class="type">int</span> i, count;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞所有信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;shutstatus == <span class="number">0</span>) &#123;  <span class="comment">// 线程池运行中循环</span></span><br><span class="line">        <span class="comment">// 定时2s，可根据实际场景改变</span></span><br><span class="line">        tv.tv_sec = <span class="number">2</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">500000</span>;</span><br><span class="line">        <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);  <span class="comment">// select作为延时函数，替换sleep，保证线程安全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前状态（减少锁持有时间）</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        numLive = pool-&gt;numLive;</span><br><span class="line">        queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        numBusy = pool-&gt;numBusy;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态扩容逻辑 </span></span><br><span class="line">        count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span> ((numLive &lt; queueSize || numBusy &gt; numLive*<span class="number">0.8</span>) &amp;&amp; numLive &lt; pool-&gt;numMax) &#123; <span class="comment">// 当存活线程数小于待取任务数量，并且小于最大线程数</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool); <span class="comment">// 添加 NUMSTEP 步长的线程</span></span><br><span class="line">            <span class="comment">// 以NUMSTEP为步长创建新线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;numMax &amp;&amp; count &lt; NUMSTEP &amp;&amp; pool-&gt;numLive &lt; pool-&gt;numMax; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;workerIDs[i] == <span class="number">0</span>) &#123;  <span class="comment">// 找到空闲位置</span></span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;workerIDs[i], <span class="literal">NULL</span>, working, pool);</span><br><span class="line">                    count++;</span><br><span class="line">                    pool-&gt;numLive++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放多余线程</span></span><br><span class="line">        <span class="keyword">if</span> (numBusy * <span class="number">2</span> &lt; numLive &amp;&amp; numLive &gt; pool-&gt;numMin) &#123; <span class="comment">// 当忙线程数 * 2小于存活线程数，并且存活的线程大于最小线程数</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;numExit = NUMSTEP;  <span class="comment">// 设置退出数量</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMSTEP; i++)&#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 唤醒工作线程，让其自杀</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printstatus</span>(pool); <span class="comment">// 打印线程池中线程信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">        <span class="built_in">sched_yield</span>();     <span class="comment">// 出让调度器  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_create</span></span><br><span class="line"><span class="comment"> * @description		: 线程池创建函数，创建一个线程池</span></span><br><span class="line"><span class="comment"> * @param - min 	: 最小线程池数</span></span><br><span class="line"><span class="comment"> * @param - max 	: 最大线程池数</span></span><br><span class="line"><span class="comment"> * @param - queueCapacity : 最大任务队列数</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 NULL，成功返回线程池对象地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadPool_t *<span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueCapacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span>* pool = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ThreadPool_t));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;threadpool malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 申请内存失败就跳过剩下的初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化任务队列</span></span><br><span class="line">        pool-&gt;taskQueue = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Task_t) * queueCapacity);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;taskQueue == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;taskQueue malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;taskQueue, <span class="number">0</span>, <span class="built_in">sizeof</span>(Task_t) * queueCapacity); <span class="comment">//清空一下</span></span><br><span class="line">        pool-&gt;queueCapacity = queueCapacity; <span class="comment">// 各个成员的初始化</span></span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化工作线程数组</span></span><br><span class="line">        pool-&gt;workerIDs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;workerIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;workerIDs malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;workerIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max); <span class="comment">//清空一下</span></span><br><span class="line">        pool-&gt;numMax = max;</span><br><span class="line">        pool-&gt;numMin = min;</span><br><span class="line">        pool-&gt;numLive = min;</span><br><span class="line">        pool-&gt;numBusy = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;numExit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> || <span class="comment">// 初始化锁和条件变量</span></span><br><span class="line">            <span class="built_in">pthread_mutex_init</span>(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;lock init failed ...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutstatus = <span class="number">0</span>;  <span class="comment">// 运行状态 // 开启线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool); <span class="comment">// 创建管理者线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;min;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;workerIDs[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">pthread_create</span>(&amp;pool-&gt;workerIDs[i], <span class="literal">NULL</span>, working, pool); <span class="comment">// 创建工作者线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;workerIDs != <span class="literal">NULL</span>) <span class="comment">// 申请内存失败跳转到这里开始，依次析构 //这边是错误处理</span></span><br><span class="line">    <span class="built_in">free</span>(pool-&gt;workerIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;taskQueue != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @description		: 线程池销毁函数，销毁一个线程池</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要销毁的线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thread pool is not existed ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;shutstatus = <span class="number">-1</span>;  <span class="comment">// 触发关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(pool-&gt;managerID, <span class="literal">NULL</span>); <span class="comment">// join掉managerID线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;numLive; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 唤醒所有存活线程，让其自杀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//信号量销毁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free掉空间</span></span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;workerIDs != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;workerIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span> &amp;&amp; pool-&gt;taskQueue != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread pool is going to be destroyed...&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread pool is going to be destroyed...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadpool_addtask</span></span><br><span class="line"><span class="comment"> * @description		: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入需要添加任务的线程池</span></span><br><span class="line"><span class="comment"> * @param - function: 任务函数</span></span><br><span class="line"><span class="comment"> * @param - arg     : 任务函数参数</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 -1，成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_addtask</span><span class="params">(ThreadPool_t *argPool, <span class="type">void</span> (*function)(<span class="type">void</span> *, <span class="keyword">volatile</span> <span class="type">int</span>*), <span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; pool-&gt;shutstatus == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool); <span class="comment">// 阻塞直到等待任务队列不为满</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;shutstatus == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread pool has been shutdown ...&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].function = function; <span class="comment">// 将任务存储到任务队列中</span></span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity; <span class="comment">// 移动队尾指针</span></span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty); <span class="comment">// 队列不为空，唤醒工作者线程</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : threadexit_unlock</span></span><br><span class="line"><span class="comment"> * @description		: 线程退出函数，并将该线程 ID 从工作者线程数组中删除</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadexit_unlock</span><span class="params">(ThreadPool_t *argPool)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">pthread_t</span> tmptid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;numMax; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;workerIDs[i] == tmptid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;workerIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;thread [%ld] is going to exit...&quot;</span>, tmptid);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;[thread = %ld] is going to exit...\n&quot;</span>, tmptid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_live</span></span><br><span class="line"><span class="comment"> * @description		: 获取线程池中存活线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 线程池中存活线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_live</span><span class="params">(ThreadPool_t *argPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    num = pool-&gt;numLive;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_thread_busy</span></span><br><span class="line"><span class="comment"> * @description		: 获取线程池中忙线程数</span></span><br><span class="line"><span class="comment"> * @param - argPool : 传入线程池对象</span></span><br><span class="line"><span class="comment"> * @return 			: 线程池中忙线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_thread_busy</span><span class="params">(ThreadPool_t *argPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadPool_t</span> *pool = (<span class="keyword">struct</span> ThreadPool_t *)argPool;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    num = pool-&gt;numBusy;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="tokenbucket"><a href="#tokenbucket" class="headerlink" title="tokenbucket"></a>tokenbucket</h3><p>令牌桶，涉及到一些流量控制，就是我们在读mp3媒体文件的时候，不是要传递一个读取多少字节的参数吗？ 这个时候咱们先从令牌桶里面取令牌，如果说令牌数量很充足，就是大于size (size是咱们想要读的字节) 的话就取出size个令牌，然后读size个字节。但是如果说令牌桶里面取令牌不足size，比如只有size1这么多了，那么咱们读数据的时候就取出size1这么多字节。</p>
<p>这里面有个计时器，每一秒会使得令牌桶里面的令牌的数量增加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> cps;                    <span class="comment">// 步长</span></span><br><span class="line">    <span class="type">int</span> burst;                  <span class="comment">// 上限</span></span><br><span class="line">    <span class="type">int</span> token;                  <span class="comment">// 拥有的令牌</span></span><br><span class="line">    <span class="type">int</span> pos;                    <span class="comment">// 自述数组下标 在全局job数组中的位置索引,不是只有一个桶</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里看一下单个令牌桶的结构</p>
<p>注意的点：</p>
<p>1.这个定时器是额外定义的线程，他不会占用主线程。</p>
<p>2.并不是只有一个令牌桶，这里设计了一个令牌桶的数组 job数组。里面存储了好多令牌桶，这样针对每个频道，我们都可以为其分配一个令牌桶。让每个频道独立起来。而不是所有的频道公用一个令牌桶。</p>
<p>3.注意这个令牌桶使用的位置哈，并不是sendto和recvfrom这两个函数用，而是在读取mp3文件的时候来用，就是通过控制文件读取的速度来控制sendto发送数据包的速度。</p>
<p>4.这里有两种类型的锁，一个是job队列的锁，就是对job队列进行操作的时候必须得加锁。还有一个是桶内部的锁，看上面的结构，是不是每个桶都有一个锁，这是为了在实现安全的修改每个桶里面的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TOKENBUCKET_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TOKENBUCKET_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKENBUCKET_MAX 1024    <span class="comment">//最大令牌桐对象数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="type">tokenbt_t</span>;         <span class="comment">//对外隐藏内部实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_init</span></span><br><span class="line"><span class="comment"> * @description		: 令牌桶初始化，初始化一个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - cps     : 步长 每一s增加多少令牌数量</span></span><br><span class="line"><span class="comment"> * @param - burst   : 上限零牌数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌桶对象，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">tokenbt_t</span> *<span class="title">tokenbt_init</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_fetchtoken</span></span><br><span class="line"><span class="comment"> * @description		: 从令牌桶对象中取令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 要取的零牌数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_fetchtoken</span><span class="params">(<span class="type">tokenbt_t</span> *, <span class="type">int</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_checktoken</span></span><br><span class="line"><span class="comment"> * @description		: 检查令牌桶对象的令牌数</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_checktoken</span><span class="params">(<span class="type">tokenbt_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_returntoken</span></span><br><span class="line"><span class="comment"> * @description		: 给令牌桶对象归还令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 令牌</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回归还的令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_returntoken</span><span class="params">(<span class="type">tokenbt_t</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy</span></span><br><span class="line"><span class="comment"> * @description		: 销毁单个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy</span><span class="params">(<span class="type">tokenbt_t</span> *)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy_all</span></span><br><span class="line"><span class="comment"> * @description		: 销毁所有令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy_all</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_shutdown</span></span><br><span class="line"><span class="comment"> * @description		: 关闭令牌流控功能模块</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_shutdown</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__TOKENBUCKET_h__</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> cps;                    <span class="comment">// 步长</span></span><br><span class="line">    <span class="type">int</span> burst;                  <span class="comment">// 上限</span></span><br><span class="line">    <span class="type">int</span> token;                  <span class="comment">// 拥有的令牌</span></span><br><span class="line">    <span class="type">int</span> pos;                    <span class="comment">// 自述数组下标 在全局job数组中的位置索引,不是只有一个桶</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在有TOKENBUCKET_MAX个桶</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *token_pool[TOKENBUCKET_MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护job数组的互斥锁，防止多线程并发修改</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_pool = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="comment">// 确保init模块只会加载一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> once_init = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="comment">// 定时器的线程ID</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : woking</span></span><br><span class="line"><span class="comment"> * @description		: 任务函数，负责固定时间给令牌桶添加令牌数</span></span><br><span class="line"><span class="comment"> * @param - arg     : NULL</span></span><br><span class="line"><span class="comment"> * @return 			: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">woking</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);     <span class="comment">// 屏蔽所有信号，只留主线程处理信号即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool); <span class="comment">//对token_pool加锁</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(token_pool[i]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">                token_pool[i]-&gt;token += token_pool[i]-&gt;cps;</span><br><span class="line">                <span class="keyword">if</span> (token_pool[i]-&gt;token &gt; token_pool[i]-&gt;burst)&#123; <span class="comment">//已经到最大值了</span></span><br><span class="line">                    token_pool[i]-&gt;token = token_pool[i]-&gt;burst;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">pthread_cond_broadcast</span>(&amp;token_pool[i]-&gt;cond); <span class="comment">//notifyAll</span></span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">        tv.tv_sec = <span class="number">1</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);       <span class="comment">// 安全定时 1 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : get_free_pos_unlocked</span></span><br><span class="line"><span class="comment"> * @description		: 任务队列添加任务函数，添加一个任务</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 失败返回 -1，成功返回 找到的空闲数组位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_free_pos_unlocked</span><span class="params">()</span></span>&#123;  <span class="comment">//找到token_pool之中第一个空闲值</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(token_pool[i]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : module_unload</span></span><br><span class="line"><span class="comment"> * @description		: 令牌桶模块卸载</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">module_unload</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_cancel</span>(tid);        <span class="comment">// 取消任务函数线程(负责固定时间给令牌桶添加令牌数)</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">tokenbt_destroy_all</span>();</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;free job is done ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : module_load</span></span><br><span class="line"><span class="comment"> * @description		: 令牌桶模块加载</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">module_load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, woking, <span class="literal">NULL</span>);  <span class="comment">//创建计时器线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_init</span></span><br><span class="line"><span class="comment"> * @description		: 令牌桶初始化，初始化一个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - cps     : 步长</span></span><br><span class="line"><span class="comment"> * @param - burst   : 上限零牌数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌桶对象，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">tokenbt_t</span> *<span class="title">tokenbt_init</span><span class="params">(<span class="type">int</span> cps, <span class="type">int</span> burst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span>* tb;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;once_init, module_load);  <span class="comment">// 任务函数只执行一次</span></span><br><span class="line">    tb = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> <span class="type">tokenbt_t</span>));  <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">if</span>(tb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    tb-&gt;cps = cps;    <span class="comment">//1s增加多少令牌数</span></span><br><span class="line">    tb-&gt;burst = burst;<span class="comment">//令牌数最大值</span></span><br><span class="line">    tb-&gt;token = <span class="number">0</span>;    <span class="comment">//初始令牌数</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;tb-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;tb-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//加锁，要处理tb里面的值了</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">    pos = <span class="built_in">get_free_pos_unlocked</span>();</span><br><span class="line">    <span class="comment">// 没有空余的空间了</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);      <span class="comment">// 获取是失败别忘了解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;tb-&gt;mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;tb-&gt;cond);</span><br><span class="line">        <span class="built_in">free</span>(tb);</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;have not any pool pos...&quot;</span>);</span><br><span class="line">        <span class="comment">// fprintf(stderr, &quot;have not any pool pos...\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把tb插入到工作队之中</span></span><br><span class="line">    tb-&gt;pos = pos;</span><br><span class="line">    token_pool[pos] = tb;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">    <span class="keyword">return</span> tb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_fetchtoken</span></span><br><span class="line"><span class="comment"> * @description		: 从令牌桶对象中取令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 要取的零牌数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_fetchtoken</span><span class="params">(<span class="type">tokenbt_t</span> *token, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || token == <span class="literal">NULL</span>)     <span class="comment">// 判断参数是否合法</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">//每一次操作tb内部的东西都要加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (tb-&gt;token &lt;= <span class="number">0</span>)&#123;  <span class="comment">//没有空余的token了，就等待</span></span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;tb-&gt;cond, &amp;tb-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    n = tb-&gt;token;</span><br><span class="line">    n = n &lt; size ? n : size;        <span class="comment">// 取得零牌数较小的那一个</span></span><br><span class="line">    tb-&gt;token -= n;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> n;   <span class="comment">//返回的并不是size，而是实际取到的令牌数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_checktoken</span></span><br><span class="line"><span class="comment"> * @description		: 检查令牌桶对象的令牌数</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_checktoken</span><span class="params">(<span class="type">tokenbt_t</span> *token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="type">int</span> token_size;</span><br><span class="line">    <span class="keyword">if</span>(tb == <span class="literal">NULL</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    token_size = tb-&gt;token;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> token_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_returntoken</span></span><br><span class="line"><span class="comment"> * @description		: 给令牌桶对象归还令牌</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - size    : 令牌</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回归还的令牌，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_returntoken</span><span class="params">(<span class="type">tokenbt_t</span> *token, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || token == <span class="literal">NULL</span>)&#123; <span class="comment">//参数正常</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    tb-&gt;token += size;</span><br><span class="line">    <span class="keyword">if</span> (tb-&gt;token &gt; tb-&gt;burst)</span><br><span class="line">        tb-&gt;token = tb-&gt;burst;</span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;tb-&gt;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy</span></span><br><span class="line"><span class="comment"> * @description		: 销毁单个令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param - token   : 令牌桶对象</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0，失败返回 -EINVAL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy</span><span class="params">(<span class="type">tokenbt_t</span> *token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tokenbt_t</span> *tb = (<span class="keyword">struct</span> <span class="type">tokenbt_t</span> *)token;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_pool);</span><br><span class="line">    token_pool[tb-&gt;pos] = <span class="literal">NULL</span>;        <span class="comment">//要把这个令牌桶从工作队列中拿出去</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_pool);</span><br><span class="line">    <span class="comment">// 然后再释放掉这个令牌桶内部的空间</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;tb-&gt;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;tb-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(tb);</span><br><span class="line">    tb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_destroy_all</span></span><br><span class="line"><span class="comment"> * @description		: 销毁所有令牌桶对象</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_destroy_all</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;TOKENBUCKET_MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (token_pool[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;token_pool[i]-&gt;mutex);</span><br><span class="line">            <span class="built_in">pthread_cond_destroy</span>(&amp;token_pool[i]-&gt;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(token_pool[i]);</span><br><span class="line">        token_pool[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : tokenbt_shutdown</span></span><br><span class="line"><span class="comment"> * @description		: 关闭令牌流控功能模块</span></span><br><span class="line"><span class="comment"> * @param           : 无</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tokenbt_shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">module_unload</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="medialib"><a href="#medialib" class="headerlink" title="medialib"></a>medialib</h3><p>这个的任务就是将我们本地的medialib文件夹里面的内容转化为广播频道</p>
<p>主要完成两项任务：</p>
<p>1.节目单的组合(mlib_getchnlist函数)</p>
<p>2.读取频道内部的数据（mlib_readchn函数）</p>
<p>这两个函数是最关键的，之前所说的令牌桶就是在mlib_readchn函数里面用的，就是读取mp3文件的操作</p>
<p>首先我们来说一下结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── medialib</span><br><span class="line">│   ├── ch1</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 世界这么大还是遇见你.mp3</span><br><span class="line">│   │   └── 起风了.mp3</span><br><span class="line">│   ├── ch2</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── 带你去旅行.mp3</span><br><span class="line">│   │   └── 再见只是陌生人.mp3</span><br><span class="line">│   ├── ch3</span><br><span class="line">│   │   ├── desc.txt</span><br><span class="line">│   │   ├── Summertime Sadness.mp3</span><br><span class="line">│   │   └── 学猫叫.mp3</span><br><span class="line">│   └── ch4</span><br></pre></td></tr></table></figure>
<p>每个ch之中都会有一个desc.txt的文件，这个里面就写的一些频道的基本的描述，比如:</p>
<p>ch1中内容就一行: pop music,起风了,世界这么大还是遇见你</p>
<p>所以我们要获取一下这个节目单的描述啥的还是很简单的，就是读取desc.txt文件就行了</p>
<p>我们看一下每个频道的管理的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">channel_context_t</span> &#123;   <span class="comment">//频道内容描述结构体</span></span><br><span class="line">    <span class="type">chnid_t</span> chnid;   <span class="comment">// 频道ID</span></span><br><span class="line">    <span class="type">char</span>* desc;      <span class="comment">// 频道描述</span></span><br><span class="line">    <span class="type">glob_t</span> globes;   <span class="comment">// 目录项</span></span><br><span class="line">    <span class="type">int</span> pos;         <span class="comment">// 当前歌曲在媒体库中的位置</span></span><br><span class="line">    <span class="type">int</span> fd;          <span class="comment">// 当前歌曲的文件描述符</span></span><br><span class="line">    <span class="type">off_t</span> offset;    <span class="comment">// 当前歌曲的读取偏移量</span></span><br><span class="line">    <span class="type">tokenbt_t</span> *tb;   <span class="comment">// 流量控制</span></span><br><span class="line">&#125; <span class="type">channel_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//   size_t   gl_pathc;    /* 匹配到的路径数目 */</span></span><br><span class="line"><span class="comment">//   char   **gl_pathv;    /* 匹配到的路径名指针数组 */ 是一个指向匹配到的路径名字符串数组的指针。数组中的每个元素是一个路径名字符串，最后一个元素为 NULL，表示数组结束。</span></span><br><span class="line"><span class="comment">//   size_t   gl_offs;     /* 起始位置索引 */ 表示起始位置索引。如果设置了 GLOB_DOOFFS 标志，glob() 函数会在 gl_pathv 的开头预留 gl_offs 个空指针，实际的匹配路径名从第 gl_offs 个位置开始。</span></span><br><span class="line"><span class="comment">// &#125; glob_t;</span></span><br></pre></td></tr></table></figure>

<p>这里主要是几个参数可能不好理解</p>
<p>1.glob_t globes 这个主要是用来搜索一下*mp3的内容的，搜索出来的文件路径会存在结构体的gl_pathv里面</p>
<p>2.pos 就是因为会有很多.mp3文件，这个就标志着这是第几个文件，从0开始，这样的话方便列表循环播放</p>
<p>3.fd 这个就是目前打开的mp3的文件描述符，用以后面读文件</p>
<p>4.offset 这个文件读到哪里了，用这个来表示，方便下次继续读</p>
<p>5.tokenbt_t *tb;   令牌桶就用在这里</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MEDIALIB_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MEDIALIB_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录每一条节目单信息：频道号chnid，描述信息char* desc</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">mlib_listdesc_t</span>&#123;</span><br><span class="line">    <span class="type">chnid_t</span> chnid;  <span class="comment">// 频道唯一标识符，使用prot.h中定义的chnid_t类型</span></span><br><span class="line">    <span class="type">char</span>* desc;     <span class="comment">// 频道描述信息，动态分配的字符串指针</span></span><br><span class="line">&#125;<span class="type">mlib_listdesc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取频道列表</span></span><br><span class="line"><span class="comment"> * @param  [输出参数] 接收频道信息结构体数组指针的地址</span></span><br><span class="line"><span class="comment"> * @param  [输出参数] 接收频道数量的指针</span></span><br><span class="line"><span class="comment"> * @return  成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_getchnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> **,<span class="type">int</span> *)</span></span>; <span class="comment">// 从媒体库获取节目单信息和频道总个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放频道列表内存</span></span><br><span class="line"><span class="comment"> * @param  要释放的频道信息结构体数组指针</span></span><br><span class="line"><span class="comment"> * @return 总是返回0表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> *)</span></span>;       <span class="comment">// 释放节目单信息存储所占的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放chn_context数组的内存 </span></span><br><span class="line"><span class="comment"> * chn_context里面存储的是所有的广播频道号</span></span><br><span class="line"><span class="comment"> * @return 总是返回0表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechncontext</span><span class="params">()</span></span>;                            <span class="comment">// 释放chn_context数组的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_readchn</span></span><br><span class="line"><span class="comment"> * @description		: 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @param - buf     : 存入流媒体内容的缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param - size    : buf的最大容量</span></span><br><span class="line"><span class="comment"> * @return 			: 返回读取到的有效内容总长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mlib_readchn</span><span class="params">(<span class="type">chnid_t</span>, <span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;        <span class="comment">// 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MEDIALIB_H__</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHSIZE 4096      <span class="comment">// 文件路径最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 256       <span class="comment">// 文件名最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINEBUFSIZE 1024   <span class="comment">// 读文件行缓冲区</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MP3_BITRATE (128 * 1024)    <span class="comment">// 128 * 1024 bps</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">channel_context_t</span> &#123;   <span class="comment">//频道内容描述结构体</span></span><br><span class="line">    <span class="type">chnid_t</span> chnid;   <span class="comment">// 频道ID</span></span><br><span class="line">    <span class="type">char</span>* desc;      <span class="comment">// 频道描述</span></span><br><span class="line">    <span class="type">glob_t</span> globes;   <span class="comment">// 目录项</span></span><br><span class="line">    <span class="type">int</span> pos;         <span class="comment">// 当前歌曲在媒体库中的位置</span></span><br><span class="line">    <span class="type">int</span> fd;          <span class="comment">// 当前歌曲的文件描述符</span></span><br><span class="line">    <span class="type">off_t</span> offset;    <span class="comment">// 当前歌曲的读取偏移量</span></span><br><span class="line">    <span class="type">tokenbt_t</span> *tb;   <span class="comment">// 流量控制</span></span><br><span class="line">&#125; <span class="type">channel_context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//   size_t   gl_pathc;    /* 匹配到的路径数目 */</span></span><br><span class="line"><span class="comment">//   char   **gl_pathv;    /* 匹配到的路径名指针数组 */ 是一个指向匹配到的路径名字符串数组的指针。数组中的每个元素是一个路径名字符串，最后一个元素为 NULL，表示数组结束。</span></span><br><span class="line"><span class="comment">//   size_t   gl_offs;     /* 起始位置索引 */ 表示起始位置索引。如果设置了 GLOB_DOOFFS 标志，glob() 函数会在 gl_pathv 的开头预留 gl_offs 个空指针，实际的匹配路径名从第 gl_offs 个位置开始。</span></span><br><span class="line"><span class="comment">// &#125; glob_t;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">channel_context_t</span> chn_context[MAXCHNID + <span class="number">1</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> total_chn = <span class="number">0</span>;           <span class="comment">// 总共的有效频道个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : getpathcontent</span></span><br><span class="line"><span class="comment"> * @description		: 从指定的路径中取得该频道所有需要的信息</span></span><br><span class="line"><span class="comment"> * @param - path    : 文件路径</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 channel_context_t 对象地址; 失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">channel_context_t</span> *<span class="title">getpathcontent</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> linebuf[LINEBUFSIZE];    <span class="comment">//行缓冲</span></span><br><span class="line">    <span class="type">char</span> pathbuf[PATHSIZE];       <span class="comment">//文件路径</span></span><br><span class="line">    <span class="type">char</span> namebuf[NAMESIZE];       <span class="comment">//文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> descfd, ret;</span><br><span class="line">    <span class="type">channel_context_t</span> *me;</span><br><span class="line">    <span class="comment">//由于是一个静态变量所以相当于一直在操作同一块内存 有叠加效果  静态频道ID计数器，初始为最小频道ID</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> curr_chnid = MINCHNID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先清空一下值</span></span><br><span class="line">    <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(linebuf));</span><br><span class="line">    <span class="built_in">memset</span>(pathbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(pathbuf));</span><br><span class="line">    <span class="built_in">memset</span>(namebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(namebuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值，字符串操作</span></span><br><span class="line">    <span class="built_in">strncpy</span>(pathbuf, path, PATHSIZE - <span class="number">1</span>);                         <span class="comment">//path</span></span><br><span class="line">    <span class="built_in">strncpy</span>(namebuf, <span class="string">&quot;/desc.txt&quot;</span>, NAMESIZE - <span class="number">1</span>);                  <span class="comment">//desc name</span></span><br><span class="line">    <span class="built_in">strncat</span>(pathbuf, namebuf, PATHSIZE - <span class="built_in">strlen</span>(pathbuf) - <span class="number">1</span>);    <span class="comment">//完整path</span></span><br><span class="line"></span><br><span class="line">    descfd = <span class="built_in">open</span>(pathbuf, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (descfd &lt; <span class="number">0</span>)&#123;   <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%s is not a lib ...&quot;</span>, pathbuf);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">read</span>(descfd, linebuf, LINEBUFSIZE);  <span class="comment">//读文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%s haven&#x27;t anything ...&quot;</span>, pathbuf);</span><br><span class="line">        <span class="built_in">close</span>(descfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(descfd);  <span class="comment">//这里要注意哈，desc文件里面本来就只有一行</span></span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">channel_context_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(me == <span class="literal">NULL</span>)&#123; <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;desc = <span class="built_in">strdup</span>(linebuf); <span class="comment">//strdup 复制字符串</span></span><br><span class="line">    <span class="comment">// 令牌桶 流量控制</span></span><br><span class="line">    me-&gt;tb = <span class="built_in">tokenbt_init</span>(MP3_BITRATE / <span class="number">8</span>, MP3_BITRATE / <span class="number">8</span> * <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;tb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;tokenbt_init() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个时候已经把 desc.txt里的内容拿到了，现在该匹配mp3了</span></span><br><span class="line">    <span class="built_in">memset</span>(pathbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(pathbuf));</span><br><span class="line">    <span class="built_in">memset</span>(namebuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(namebuf));</span><br><span class="line">    <span class="comment">// 一样的操作，path name path+name 只不过这里的是*.mp3</span></span><br><span class="line">    <span class="built_in">strncpy</span>(pathbuf, path, PATHSIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(namebuf, <span class="string">&quot;/*.mp3&quot;</span>, NAMESIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncat</span>(pathbuf, namebuf, PATHSIZE - <span class="built_in">strlen</span>(pathbuf) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">glob</span>(pathbuf, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;me-&gt;globes);  <span class="comment">//glob 匹配.mp3文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;glob() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;pos = <span class="number">0</span>;     <span class="comment">//第1个pos，第一个mp3</span></span><br><span class="line">    me-&gt;offset = <span class="number">0</span>;  <span class="comment">//还没开始读，所以就offset（文件内部偏移）就是0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开第一个mp3文件</span></span><br><span class="line">    me-&gt;fd = <span class="built_in">open</span>(me-&gt;globes.gl_pathv[me-&gt;pos], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (me-&gt;fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">free</span>(me);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录当前的 curr_chnid</span></span><br><span class="line">    me-&gt;chnid = curr_chnid;</span><br><span class="line">    curr_chnid++;</span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : open_next</span></span><br><span class="line"><span class="comment"> * @description		: 打开指定频道的下一首歌曲</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_next</span><span class="params">(<span class="type">chnid_t</span> chnid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chn_context[chnid].globes.gl_pathc; i++)&#123;</span><br><span class="line">        chn_context[chnid].pos++;</span><br><span class="line">        <span class="keyword">if</span> (chn_context[chnid].pos == chn_context[chnid].globes.gl_pathc)&#123;</span><br><span class="line">            chn_context[chnid].pos = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="comment">// 列表循环</span></span><br><span class="line">        <span class="built_in">close</span>(chn_context[chnid].fd); <span class="comment">//先关闭一下当前的</span></span><br><span class="line">        <span class="comment">// 打开下一首</span></span><br><span class="line">        chn_context[chnid].fd = <span class="built_in">open</span>(chn_context[chnid].globes.gl_pathv[chn_context[chnid].pos], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (chn_context[chnid].fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//打不开倒不至于直接退出，再继续循环打开下一首</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_getchnlist</span></span><br><span class="line"><span class="comment"> * @description		: 从媒体库获取节目单信息和频道总个数</span></span><br><span class="line"><span class="comment"> * @param - list    : 传出参数，填入节目单信息</span></span><br><span class="line"><span class="comment"> * @param - size    : 传出参数，填入频道总个数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_getchnlist</span><span class="params">(<span class="type">mlib_listdesc_t</span> **list, <span class="type">int</span> *size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,ret;</span><br><span class="line">    <span class="type">glob_t</span> globes;</span><br><span class="line">    <span class="type">char</span> path[PATHSIZE];</span><br><span class="line">    <span class="type">channel_context_t</span> *retmp;</span><br><span class="line">    <span class="type">mlib_listdesc_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(chn_context, <span class="number">0</span>, <span class="built_in">sizeof</span>(chn_context));</span><br><span class="line">    <span class="comment">//初始化频道数组 </span></span><br><span class="line">    <span class="keyword">for</span> (i = MINCHNID; i &lt; MAXCHNID + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        chn_context[i].chnid = <span class="number">-1</span>; <span class="comment">//设置为无效频道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿到medialib path  /*表示medialib下面所有的文件夹(ch1 ch2 ch3 ch4....)</span></span><br><span class="line">    <span class="built_in">snprintf</span>(path, PATHSIZE, <span class="string">&quot;%s/*&quot;</span>, server_conf.media_dir);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">glob</span>(path, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;globes);  <span class="comment">//匹配一下</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;glob() : failed ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配一下空间</span></span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">mlib_listdesc_t</span>) * globes.gl_pathc);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; globes.gl_pathc; i++)&#123;       <span class="comment">// 分别获取 ch1 ch2 ch3 ch4 中的频道内容并保存在 chn_context 中</span></span><br><span class="line">        retmp = <span class="built_in">getpathcontent</span>(globes.gl_pathv[i]);</span><br><span class="line">        <span class="keyword">if</span> (retmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//注意这里会把retmp放到全局静态的chn_context之中</span></span><br><span class="line">            <span class="built_in">memcpy</span>(chn_context + retmp-&gt;chnid, retmp, <span class="built_in">sizeof</span>(*retmp));</span><br><span class="line">            tmp[total_chn].chnid = retmp-&gt;chnid;</span><br><span class="line">            tmp[total_chn].desc = <span class="built_in">strdup</span>(retmp-&gt;desc);</span><br><span class="line">            total_chn++;</span><br><span class="line">            <span class="built_in">free</span>(retmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *list = <span class="built_in">realloc</span>(tmp, <span class="built_in">sizeof</span>(<span class="type">mlib_listdesc_t</span>) * total_chn);      <span class="comment">// 给 *list 重新分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;realloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *size = total_chn;</span><br><span class="line">    <span class="built_in">globfree</span>(&amp;globes);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_freechnlist</span></span><br><span class="line"><span class="comment"> * @description		: 释放节目单信息存储所占的内存</span></span><br><span class="line"><span class="comment"> * @param - list    : </span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechnlist</span><span class="params">(<span class="keyword">struct</span> <span class="type">mlib_listdesc_t</span> *list)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_chn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(list[i].desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_freechncontext</span></span><br><span class="line"><span class="comment"> * @description		: 释放chn_context数组的内存</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlib_freechncontext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = MINCHNID; i &lt; MAXCHNID + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chn_context[i].chnid != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(chn_context[i].desc);</span><br><span class="line">            <span class="built_in">globfree</span>(&amp;chn_context[i].globes);</span><br><span class="line">            <span class="built_in">close</span>(chn_context[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : mlib_readchn</span></span><br><span class="line"><span class="comment"> * @description		: 按频道读取对应媒体库流媒体内容</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @param - buf     : 存入流媒体内容的缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param - size    : buf的最大容量</span></span><br><span class="line"><span class="comment"> * @return 			: 返回读取到的有效内容总长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">mlib_readchn</span><span class="params">(<span class="type">chnid_t</span> chnid, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> token, len;</span><br><span class="line">    <span class="comment">//获取一下令牌桶之中的令牌，返回的是实际获取的令牌数量，因为可能不够size这么多令牌</span></span><br><span class="line">    token = <span class="built_in">tokenbt_fetchtoken</span>(chn_context[chnid].tb, size);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//  从指定的偏移量处开始读取 read的话是从当前文件偏移量开始读取(当前文件偏移量存储再文件描述符之中)</span></span><br><span class="line">        <span class="comment">//  pread 1是可以指定偏移两 2是线程安全，不会引文其他线程读取了文件改变了文件偏移</span></span><br><span class="line">        len = <span class="built_in">pread</span>(chn_context[chnid].fd, buf, token, chn_context[chnid].offset);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;pread() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">open_next</span>(chnid);       <span class="comment">// 如果这首歌曲读取失败了，那就切换下一首歌曲播放</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;song: %s is over&quot;</span>, chn_context[chnid].globes.gl_pathv[chn_context[chnid].pos]);</span><br><span class="line">            <span class="built_in">open_next</span>(chnid);       <span class="comment">// 这首歌曲读取结束了，那就切换下一首歌曲播放</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chn_context[chnid].offset += len;  <span class="comment">//正常读取了就加offset</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; token)                <span class="comment">// 令牌没用完，归还令牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tokenbt_returntoken</span>(chn_context[chnid].tb, token - len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>之前不是medialib把咱么medialib文件夹里面的东西转化为频道了吗</p>
<p>这里就是组装一下，节目单频道，用来发送节目单的数据，代码很简单，看一下就好。</p>
<p>就是，拿到组装号的 节目点list，然后处理一下，然后发送就好。</p>
<p>这里的发送时调用的线程池（addtask）</p>
<p>就是一直发，1s发一次。另外频道号之前在protocol.h已经定义好了，频道列表的频道号固定是0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_list_create</span><span class="params">(<span class="type">mlib_listdesc_t</span> *, <span class="type">int</span>)</span></span>;   <span class="comment">// 节目单频道任务创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__LIST_H__</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要发送的节目信息内容和内容的长度打包，传给线程池任务</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">send_list_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">msg_list_t</span> msg[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="type">send_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : sendlist</span></span><br><span class="line"><span class="comment"> * @description		: 定时发送节目单信息</span></span><br><span class="line"><span class="comment"> * @param - arg     : send_list_t类型</span></span><br><span class="line"><span class="comment"> * @param - shut    : 线程池当前开启状态</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendlist</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">volatile</span> <span class="type">int</span> *shut)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">send_list_t</span> *info = (<span class="type">send_list_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (*shut == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">sendto</span>(serversd, info-&gt;msg, info-&gt;len, <span class="number">0</span>, (<span class="type">void</span> *)&amp;sndaddr, <span class="built_in">sizeof</span>(sndaddr));</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%7s thread sendto %5d bytes, pool status is %d&quot;</span>, <span class="string">&quot;list&quot;</span>, len, *shut);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : thr_list_create</span></span><br><span class="line"><span class="comment"> * @description		: 节目单频道任务创建</span></span><br><span class="line"><span class="comment"> * @param - list    : 从媒体库读取的原始节目信息数据</span></span><br><span class="line"><span class="comment"> * @param - size    : 频道总个数</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_list_create</span><span class="params">(<span class="type">mlib_listdesc_t</span> *list, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len, totalsize;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">msg_list_t</span> *msg_list;</span><br><span class="line">    <span class="type">msg_listdesc_t</span> *desc_list;</span><br><span class="line">    <span class="type">send_list_t</span> *info;</span><br><span class="line"></span><br><span class="line">    totalsize = <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        totalsize += <span class="built_in">sizeof</span>(<span class="type">msg_listdesc_t</span>) + <span class="built_in">strlen</span>(list[i].desc);     <span class="comment">// 统计节目单信息有效数据的总长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info = <span class="built_in">malloc</span>(totalsize + <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 1节目单1 这样的 所以最前面得加个int</span></span><br><span class="line">    <span class="keyword">if</span> (info == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, totalsize + <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    info-&gt;len = totalsize;              <span class="comment">// 将有效数据的总长度填入申请的内存中</span></span><br><span class="line">    msg_list = info-&gt;msg;</span><br><span class="line"></span><br><span class="line">    msg_list-&gt;chnid = LISTCHNID;        <span class="comment">// 填入 LISTCHNID 频道号 0 号只广播频道信息</span></span><br><span class="line">    desc_list = msg_list-&gt;list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)          <span class="comment">// 将节目单信息的有效数据内容填入申请的内存中</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">sizeof</span>(<span class="type">msg_listdesc_t</span>) + <span class="built_in">strlen</span>(list[i].desc);</span><br><span class="line">        desc_list-&gt;chnid = list[i].chnid;</span><br><span class="line">        desc_list-&gt;deslength = <span class="built_in">htons</span>(len);</span><br><span class="line">        <span class="built_in">strncpy</span>((<span class="type">void</span> *)desc_list-&gt;desc, list[i].desc, <span class="built_in">strlen</span>(list[i].desc));</span><br><span class="line">        desc_list = (<span class="type">void</span> *)(((<span class="type">char</span> *)desc_list) + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadpool_addtask</span>(pool, sendlist, info); <span class="comment">// 向任务队列添加一个任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>这个就是某个频道，一直发送数据了，不管有没有客户端都要一直发送</p>
<p>sendchannel里面调用了mlib_readchn，发送完一个mp3文件之后会列表循环，不会停止发送哈</p>
<p>之前也说了mlib_readchn里面使用了令牌桶进行了流量控制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CHANNEL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CHANNEL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_channel_create</span><span class="params">(<span class="type">chnid_t</span>)</span></span>;    <span class="comment">// 流媒体音乐频道任务创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CHANNEL_H__</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;channel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : sendchannel</span></span><br><span class="line"><span class="comment"> * @description		: 读取媒体库中流媒体的内容并发送</span></span><br><span class="line"><span class="comment"> * @param - arg     : msg_channel_t类型</span></span><br><span class="line"><span class="comment"> * @param - shut    : 线程池当前开启状态</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sendchannel</span><span class="params">(<span class="type">void</span> *arg, <span class="keyword">volatile</span> <span class="type">int</span> *shut)</span></span>&#123;</span><br><span class="line">    <span class="type">msg_channel_t</span> *context = (<span class="type">msg_channel_t</span> *)arg;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (*shut == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(context-&gt;data, <span class="number">0</span>, MAX_CHANNEL_DATA - <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>));</span><br><span class="line">        <span class="comment">//读取频道里面的内容</span></span><br><span class="line">        len = <span class="built_in">mlib_readchn</span>(context-&gt;chnid, context-&gt;data, MAX_CHANNEL_DATA - <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>));</span><br><span class="line">        len = <span class="built_in">sendto</span>(serversd, context, len + <span class="built_in">sizeof</span>(<span class="type">chnid_t</span>), <span class="number">0</span>, (<span class="type">void</span> *)&amp;sndaddr, <span class="built_in">sizeof</span>(sndaddr));</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;%7s thread sendto %5d bytes, pool status is %d&quot;</span>, <span class="string">&quot;channel&quot;</span>, len, *shut);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : thr_channel_create</span></span><br><span class="line"><span class="comment"> * @description		: 流媒体音乐频道任务创建</span></span><br><span class="line"><span class="comment"> * @param - chnid   : 频道号</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回 0; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">thr_channel_create</span><span class="params">(<span class="type">chnid_t</span> chnid)</span></span>&#123;</span><br><span class="line">    <span class="type">msg_channel_t</span> *context;</span><br><span class="line">    context = <span class="built_in">malloc</span>(MAX_CHANNEL_DATA);     <span class="comment">// 申请内存，将本块内存地址传入线程池中</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;malloc() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="comment">// fprintf(stderr, &quot;malloc() : %s\n&quot;, strerror(errno));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(context, <span class="number">0</span>, MAX_CHANNEL_DATA);</span><br><span class="line">    context-&gt;chnid = chnid;</span><br><span class="line">    <span class="built_in">threadpool_addtask</span>(pool, sendchannel, context);     <span class="comment">// context指向的内存由线程池负责释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>前面都讲了，这里就没啥好讲的了，就是将所有的东西组合一下就好</p>
<p>两点注意：</p>
<p>1.守护进程</p>
<p>就是将整个的进程置于后台，终端就不输出了</p>
<p>就是fork一个子进程，然后脱离父进程，使用子进程来执行代码</p>
<p>将输出重定向到 &#x2F;dev&#x2F;null 里面，&#x2F;dev&#x2F;null是一个linux内置的一个设备，往里输出的话就表示，我不需要这些输出，直接丢弃</p>
<p>setsid 创建新会话，脱离终端，即使终端关闭了也不会断开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">daemon_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;fork() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//退出父进程</span></span><br><span class="line">        <span class="comment">//确保守护进程脱离父进程控制，成为后台进程。</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dev/null 这是一个特殊的设备，输入进去之后，所有的东西都会被丢弃</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 守护进程的输入/输出/错误不再关联终端，避免干扰前台。</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);   <span class="comment">// 标准输入</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);  <span class="comment">// 标准输出</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);  <span class="comment">// 标准错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO)&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);    <span class="comment">// 更改工作目录到根目录</span></span><br><span class="line">    <span class="comment">// 设置文件创建时的默认权限掩码。umask(0) 表示新文件权限为 0777 &amp; ~0 = 0777（即 rwxrwxrwx）</span></span><br><span class="line">    <span class="comment">// 确保守护进程创建的文件/目录具有最大权限，由程序自行控制具体权限。</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);      <span class="comment">// 重置文件权限掩码</span></span><br><span class="line">    <span class="comment">// 创建一个新的会话（Session），并成为会话的首进程。</span></span><br><span class="line">    <span class="comment">// 确保守护进程没有控制终端（TTY），即使终端关闭，守护进程仍可运行。</span></span><br><span class="line">    <span class="built_in">setsid</span>();      <span class="comment">// 创建新会话，脱离终端控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面就没啥了，就是socket的创建以及各个函数的调用，这个看代码一看就明白</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server_conf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;medialib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tokenbucket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;channel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> serversd;                 <span class="comment">//全局性变量，在server_conf里面有声明 服务端套接字</span></span><br><span class="line">ThreadPool_t *pool;           <span class="comment">//全局性变量，在server_conf里面有声明 线程池</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sndaddr;   <span class="comment">//全局性变量，在server_conf里面有声明 发送目的地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">mlib_listdesc_t</span> *list; <span class="comment">//节目单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局性变量，在server_conf里面有声明 服务端的一些配置</span></span><br><span class="line"><span class="type">server_conf_t</span> server_conf =</span><br><span class="line">    &#123;</span><br><span class="line">        .media_dir  = DEFAULT_MEDIADIR,</span><br><span class="line">        .rcvport    = DEFAULT_RECVPORT,</span><br><span class="line">        .runmode    = RUN_FOREGROUND,</span><br><span class="line">        .ifname     = DEFAULT_IF,</span><br><span class="line">        .mgroup     = DEFAULT_MGROUP</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> opt[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;mgroup&quot;</span>  , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;M&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;port&quot;</span>    , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;P&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mediadir&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;D&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;runmode&quot;</span> , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;R&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ifname&quot;</span>  , required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;I&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>    , no_argument      , <span class="literal">NULL</span>, <span class="string">&#x27;H&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数帮助</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-M --mgroup     自定义多播组地址\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-P --port       自定义发送端口  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-D --mediadir   自定义媒体库路径\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-R --runmode    自定义运行模式  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-I --ifname     自定义网卡名称  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-H --help       显示帮助       \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">daemon_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;fork() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">//退出父进程</span></span><br><span class="line">        <span class="comment">//确保守护进程脱离父进程控制，成为后台进程。</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dev/null 这是一个特殊的设备，输入进去之后，所有的东西都会被丢弃</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;open() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 守护进程的输入/输出/错误不再关联终端，避免干扰前台。</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);   <span class="comment">// 标准输入</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);  <span class="comment">// 标准输出</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);  <span class="comment">// 标准错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO)&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);    <span class="comment">// 更改工作目录到根目录</span></span><br><span class="line">    <span class="comment">// 设置文件创建时的默认权限掩码。umask(0) 表示新文件权限为 0777 &amp; ~0 = 0777（即 rwxrwxrwx）</span></span><br><span class="line">    <span class="comment">// 确保守护进程创建的文件/目录具有最大权限，由程序自行控制具体权限。</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);      <span class="comment">// 重置文件权限掩码</span></span><br><span class="line">    <span class="comment">// 创建一个新的会话（Session），并成为会话的首进程。</span></span><br><span class="line">    <span class="comment">// 确保守护进程没有控制终端（TTY），即使终端关闭，守护进程仍可运行。</span></span><br><span class="line">    <span class="built_in">setsid</span>();      <span class="comment">// 创建新会话，脱离终端控制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号处理函数：清理资源并退出 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">threadpool_destroy</span>(pool);     <span class="comment">// 销毁线程池</span></span><br><span class="line">    <span class="built_in">mlib_freechnlist</span>(list);       <span class="comment">// 释放频道列表内存</span></span><br><span class="line">    <span class="built_in">mlib_freechncontext</span>();        <span class="comment">// 释放频道上下文资源</span></span><br><span class="line">    <span class="built_in">tokenbt_shutdown</span>();           <span class="comment">// 关闭令牌桶</span></span><br><span class="line">    <span class="built_in">close</span>(serversd);              <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">closelog</span>();                   <span class="comment">// 关闭系统日志</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);           <span class="comment">// 正常退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化UDP套接字 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">socket_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> mreq; <span class="comment">// 多播请求结构体</span></span><br><span class="line">    <span class="comment">/*struct ip_mreqn：用于配置多播组的参数，包含以下字段：</span></span><br><span class="line"><span class="comment">        imr_multiaddr：多播组 IP 地址。</span></span><br><span class="line"><span class="comment">        imr_address：本地接口 IP 地址。</span></span><br><span class="line"><span class="comment">        imr_ifindex：网卡接口的索引。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    serversd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serversd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;socket() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多播组参数</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_conf.mgroup, &amp;mreq.imr_multiaddr); <span class="comment">// 多播组地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;mreq.imr_address);           <span class="comment">// 本地任意地址</span></span><br><span class="line">    mreq.imr_ifindex = if_nametoindex(server_conf.ifname);     <span class="comment">// 网卡名称转索引</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    inet_pton：将字符串形式的 IP 地址转换为二进制格式。</span></span><br><span class="line"><span class="comment">    server_conf.mgroup：配置中的多播组地址（如 &quot;239.0.0.1&quot;）。</span></span><br><span class="line"><span class="comment">    &quot;0.0.0.0&quot;：表示绑定到本地所有可用接口。</span></span><br><span class="line"><span class="comment">    if_nametoindex：将网卡名称（如 &quot;eth0&quot;）转换为系统索引。</span></span><br><span class="line"><span class="comment">    若网卡不存在，此函数会失败，但代码中未处理该错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 告诉内核通过指定的网卡（server_conf.ifname）发送多播数据。</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(serversd, IPPROTO_IP, IP_MULTICAST_IF, &amp;mreq, <span class="built_in">sizeof</span>(mreq));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;setsockopt() : %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sndaddr.sin_family = AF_INET;</span><br><span class="line">    sndaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(server_conf.rcvport));</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_conf.mgroup, &amp;sndaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">int</span> arg;</span><br><span class="line">    <span class="type">int</span> list_size;                <span class="comment">// 频道列表大小</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;      <span class="comment">// 信号处理结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开系统日志，标识为&quot;netradio&quot;，包含PID和输出到stderr</span></span><br><span class="line">    <span class="built_in">openlog</span>(<span class="string">&quot;netradio&quot;</span>, LOG_PID | LOG_PERROR, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        arg = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;M:P:D:R:I:H&quot;</span>, opt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">-1</span>) <span class="comment">//没有参数就都是默认的，不用解析</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            server_conf.mgroup = optarg; <span class="comment">// 设置多播组地址</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            server_conf.rcvport = optarg; <span class="comment">// 设置接收端口</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            server_conf.media_dir = optarg; <span class="comment">// 设置媒体目录</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            <span class="comment">// 设置运行模式（0:前台，1:守护进程）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">atoi</span>(optarg) == <span class="number">1</span> || <span class="built_in">atoi</span>(optarg) == <span class="number">0</span>) &#123;</span><br><span class="line">                server_conf.runmode = (<span class="keyword">enum</span> RNUMODE)<span class="built_in">atoi</span>(optarg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;参数错误！详见&quot;</span>);</span><br><span class="line">                <span class="built_in">print_help</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            server_conf.ifname = optarg; <span class="comment">// 设置网卡名称</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">            <span class="built_in">print_help</span>(); <span class="comment">// 显示帮助</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;参数错误！详见&quot;</span>);</span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syslog</span>(LOG_INFO, <span class="string">&quot;当前配置：\n多播组IP：\t%s\n端口：\t\t%s\n媒体库路径：\t%s\n运行模式：\t%d\n网卡名：\t%s\n&quot;</span>,</span><br><span class="line">        server_conf.mgroup,</span><br><span class="line">        server_conf.rcvport,</span><br><span class="line">        server_conf.media_dir,</span><br><span class="line">        server_conf.runmode,</span><br><span class="line">        server_conf.ifname);</span><br><span class="line">    <span class="comment">// 判断运行模式，如果是守护进程模式则初始化</span></span><br><span class="line">    <span class="keyword">if</span> (server_conf.runmode == RUN_DAEMON)  <span class="comment">// 判断系统运行模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">daemon_init</span>();</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;daemon_init() failed ...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理</span></span><br><span class="line">    action.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;action.sa_mask);    <span class="comment">// 清空信号掩码</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGINT);  <span class="comment">// Ctrl+C</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGQUIT); <span class="comment">// Ctrl+\ //</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGTSTP); <span class="comment">// Ctrl+Z</span></span><br><span class="line">    action.sa_handler = daemon_exit;      <span class="comment">// 绑定处理函数 //都是退出</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;action, <span class="literal">NULL</span>); <span class="comment">// 注册信号捕捉函数</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGQUIT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGTSTP, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化套接字</span></span><br><span class="line">    <span class="built_in">socket_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池（核心5线程，最大20线程，队列容量20）</span></span><br><span class="line">    pool = <span class="built_in">threadpool_create</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;threadpool_create() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取媒体库频道列表</span></span><br><span class="line">    ret = <span class="built_in">mlib_getchnlist</span>(&amp;list, &amp;list_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;mlib_getchnlist() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建频道列表线程</span></span><br><span class="line">    ret = <span class="built_in">thr_list_create</span>(list, list_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thr_list_create() : failed ...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每个频道创建发送线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list_size; i++) &#123;</span><br><span class="line">        ret = <span class="built_in">thr_channel_create</span>(list[i].chnid);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">syslog</span>(LOG_ERR, <span class="string">&quot;thr_channel_create() : failed ...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环挂起，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">pause</span>();  <span class="comment">// 阻塞主线程，等待信号 这里要注意哈，为舍么要阻塞？因为ie前面发送节目单信息以及每个频道里面的信息都申请了 额外的线程来做了，这里就没必要再做了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>任务就是接收数据，两个进程，父进程进行数据的接收，输入到管道里面，然后子进程拿数据输入到ffmpeg里面来播放，就是这个流程, 基本没有啥坑</p>
<p>唯一需要注意的点就是如何选择自己的频道</p>
<p>首先要明白一点，加入到组播里面之后，client会接收所有的数据</p>
<p>因此需要先进行判断，首先得先拿到节目单，也就是ID为0的包。不是ID为0的包就丢弃。</p>
<p>然后把包里面的内容输出到终端让客户来选择那个频道，比如输入1，那么就选择1频道</p>
<p>后面拿到包之后先对比一下是不是1频道，是的话就拿过来，处理。不是的话就丢弃就好。</p>
<p>其他的就没啥的，下面是代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CLIENT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CLIENT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEFAULT_PALYERCMD &quot;/usr/bin/mplayer -&quot;     使用mpg123播放器并将输出重定向到/dev/null（静默模式）</span></span><br><span class="line"><span class="comment">// /dev/null 是一个特殊的文件，通常被称为“空设备”或“位桶”（bit bucket） </span></span><br><span class="line"><span class="comment">// 任何写入 /dev/null 的内容都会被永久丢弃，不会保存在任何地方。同时，从 /dev/null 读取内容时，总是会返回空（EOF，即文件结束符）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PALYERCMD <span class="string">&quot;/usr/bin/mpg123 - &gt; /dev/null&quot;</span> <span class="comment">//mpg123播放mp3文件，并且把一些输出给丢弃掉 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client_conf_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *mgroup;       <span class="comment">// 多播组IP地址</span></span><br><span class="line">    <span class="type">char</span> *revport;      <span class="comment">// 接收端口</span></span><br><span class="line">    <span class="type">char</span> *playercmd;    <span class="comment">// 播放器命令</span></span><br><span class="line">&#125; <span class="type">client_conf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CLIENT_H__</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protocol.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量，程序退出时释放内存。 </span></span><br><span class="line"><span class="type">msg_list_t</span> *msg_list = <span class="literal">NULL</span>;        <span class="comment">// 节目单数据缓冲区指针</span></span><br><span class="line"><span class="type">msg_channel_t</span> *msg_channel = <span class="literal">NULL</span>;  <span class="comment">// 频道数据缓冲区指针</span></span><br><span class="line"><span class="type">int</span> sfd;                            <span class="comment">// 套接字文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="type">client_conf_t</span> conf = <span class="comment">// client 配置</span></span><br><span class="line">    &#123;</span><br><span class="line">        .mgroup = DEFAULT_MGROUP,         <span class="comment">// 默认多播组地址</span></span><br><span class="line">        .revport = DEFAULT_RECVPORT,      <span class="comment">// 默认接收端口</span></span><br><span class="line">        .playercmd = DEFAULT_PALYERCMD&#125;;  <span class="comment">// 默认播放器命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数解析</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">option</span> opt[] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;mgroup&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;M&#x27;</span>&#125;,       <span class="comment">// 多播组地址选项</span></span><br><span class="line">        &#123;<span class="string">&quot;port&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;P&#x27;</span>&#125;,         <span class="comment">// 接收端口选项</span></span><br><span class="line">        &#123;<span class="string">&quot;player&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,       <span class="comment">// 播放器命令选项</span></span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;H&#x27;</span>&#125;&#125;;              <span class="comment">// 帮助选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数帮助 // 打印帮助信息</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-M --mgroup 自定义多播组地址\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-P --port   自定义接收端口  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-p --player 自定义音乐解码器\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-H --help   显示帮助       \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : writen</span></span><br><span class="line"><span class="comment"> * @description		: 自定义封装函数，保证写足 count 字节</span></span><br><span class="line"><span class="comment"> * @param - fd 	    : 文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf 	: 要写入的内容</span></span><br><span class="line"><span class="comment"> * @param - count 	: 要写入的内容总长度</span></span><br><span class="line"><span class="comment"> * @return 			: 成功返回写入的字节数; 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len, total, ret;</span><br><span class="line">    total = count;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; total &gt; <span class="number">0</span>; len += ret, total -= ret)&#123;</span><br><span class="line">    again:</span><br><span class="line">        ret = <span class="built_in">write</span>(fd, buf + len, total);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">// 中断系统调用，重启 write</span></span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;write() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @name            : exit_action</span></span><br><span class="line"><span class="comment"> * @description		: 信号捕捉函数，用于退出前清理</span></span><br><span class="line"><span class="comment"> * @param - s 	    : 信号</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">exit_action</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = <span class="built_in">getpgid</span>(<span class="built_in">getpid</span>());  <span class="comment">// 获取进程组ID</span></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">if</span> (msg_list != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(msg_list);</span><br><span class="line">    <span class="keyword">if</span> (msg_channel != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(msg_channel);</span><br><span class="line">    <span class="built_in">close</span>(sfd);           <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">kill</span>(-pid, SIGQUIT);  <span class="comment">// 向进程组发送退出信号</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;\nthis programme is going to exit...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arg;       <span class="comment">// 临时存储getopt返回值</span></span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 通用返回值存储</span></span><br><span class="line">    <span class="type">int</span> len;       <span class="comment">// 接收数据长度</span></span><br><span class="line">    <span class="type">int</span> val;       <span class="comment">// 临时整数值存储</span></span><br><span class="line">    <span class="type">int</span> chosen;    <span class="comment">// 用户选择的频道ID</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];     <span class="comment">// 管道文件描述符数组</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">20</span>];   <span class="comment">// 存储IP字符串</span></span><br><span class="line">    <span class="type">pid_t</span> pid;     <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">socklen_t</span> socklen;   <span class="comment">// 套接字地址结构长度</span></span><br><span class="line">    <span class="type">uint64_t</span> receive_buf_size = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 20MB  // 接收缓冲区大小（20MB）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> group;      <span class="comment">// 多播组结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr,    <span class="comment">// 本地绑定地址</span></span><br><span class="line">                    list_addr,  <span class="comment">// 节目单来源地址</span></span><br><span class="line">                    data_addr;  <span class="comment">// 数据来源地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;    <span class="comment">// 信号处理结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg = <span class="built_in">getopt_long</span>(argc, argv, <span class="string">&quot;P:M:p:H&quot;</span>, opt, <span class="literal">NULL</span>); <span class="comment">// 命令行参数解析</span></span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (arg)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            conf.revport = optarg;      <span class="comment">// 设置接收端口</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            conf.mgroup = optarg;       <span class="comment">// 设置多播组地址</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            conf.playercmd = optarg;    <span class="comment">// 设置播放器命令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:                       <span class="comment">// 显示帮助</span></span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;参数错误！详见\n&quot;</span>);</span><br><span class="line">            <span class="built_in">print_help</span>();</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印当前配置</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;当前配置：\n多播组IP:\t%s\n端口：\t\t%s\n播放器：\t%s\n&quot;</span>,</span><br><span class="line">            conf.mgroup, conf.revport, conf.playercmd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pipe</span>(fd); <span class="comment">// 创建匿名管道创建管道用于与播放器通信</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;pipe() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork(); <span class="comment">// 创建子进程 // 创建子进程用于运行播放器</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;  <span class="comment">//创建失败</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fork() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  <span class="comment">//子进程负责将父进程读取到的数据通过管道馈入到ffmpeg里面播放</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);                 <span class="comment">// 关闭写端（子进程只读）</span></span><br><span class="line">        <span class="built_in">dup2</span>(fd[<span class="number">0</span>], STDIN_FILENO);    <span class="comment">// 将管道读端重定向到标准输入</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);                 <span class="comment">// 关闭原始读端</span></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, conf.playercmd, <span class="literal">NULL</span>); <span class="comment">// 使用shell解释器来运行 mpg123，子进程被替换成mpg123</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;execl() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">//父进程不需要读管道</span></span><br><span class="line">    <span class="comment">// 配置信号处理结构体</span></span><br><span class="line">    action.sa_flags = <span class="number">0</span>;                   <span class="comment">// 不使用特殊标志</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;action.sa_mask);          <span class="comment">// 清空信号屏蔽字</span></span><br><span class="line">    <span class="comment">// 添加要阻塞的信号（处理期间屏蔽这些信号）</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGINT);    <span class="comment">// Ctrl+C</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGQUIT);   <span class="comment">// Ctrl+\ //</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;action.sa_mask, SIGTSTP);   <span class="comment">// Ctrl+Z</span></span><br><span class="line">    action.sa_handler = exit_action;       <span class="comment">// 设置统一信号处理函数</span></span><br><span class="line">    <span class="comment">// 注册信号处理器</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;action, <span class="literal">NULL</span>);   <span class="comment">// 注册Ctrl+C处理</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGQUIT, &amp;action, <span class="literal">NULL</span>);  <span class="comment">// 注册退出处理</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGTSTP, &amp;action, <span class="literal">NULL</span>);  <span class="comment">// 注册暂停处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建UDP套接字</span></span><br><span class="line">    sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置绑定地址结构</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;addr.sin_addr);</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(conf.revport));</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    ret = <span class="built_in">bind</span>(sfd, (<span class="type">void</span> *)&amp;addr, <span class="built_in">sizeof</span>(addr)); <span class="comment">// 绑定本地 IP ，端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;bind() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接收缓冲区大小</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, SOL_SOCKET, SO_RCVBUF, &amp;receive_buf_size, <span class="built_in">sizeof</span>(receive_buf_size)); <span class="comment">// 设置套接字接收缓冲区 20 MB</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;SO_RCVBUF : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许组播数据回环（本机接收自己发送的数据）</span></span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;(val), <span class="built_in">sizeof</span>(val)); <span class="comment">// 允许组播数据包本地回环</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;IP_MULTICAST_LOOP : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置多播组参数</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, conf.mgroup, &amp;group.imr_multiaddr);       <span class="comment">// 多播组地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);           <span class="comment">// 本地接口地址</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;ens33&quot;</span>);                                 <span class="comment">// 绑定自己的网卡</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="built_in">sizeof</span>(group)); <span class="comment">// 加入多播组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;IP_ADD_MEMBERSHIP() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配节目单数据缓冲区</span></span><br><span class="line">    msg_list = <span class="built_in">malloc</span>(MAX_LISTCHN_DATA);</span><br><span class="line">    <span class="keyword">if</span> (msg_list == <span class="literal">NULL</span>)&#123; <span class="comment">//错误处理</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    socklen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_list, <span class="number">0</span>, MAX_LISTCHN_DATA);    <span class="comment">// 清空缓冲区</span></span><br><span class="line">        len = <span class="built_in">recvfrom</span>(sfd, msg_list, MAX_LISTCHN_DATA, <span class="number">0</span>, (<span class="type">void</span> *)&amp;list_addr, &amp;socklen); <span class="comment">// 接收节目单包</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">sizeof</span>(<span class="type">msg_list_t</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is too short, len = %d...\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 检查是否为节目单数据（根据预设的LISTCHNID判断）</span></span><br><span class="line">        <span class="keyword">if</span> (msg_list-&gt;chnid == LISTCHNID) <span class="comment">// 如果是节目单包则保留，不是则丢弃</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;list from IP = %s, Port = %d\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;list_addr.sin_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">                    <span class="built_in">ntohs</span>(list_addr.sin_port));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并打印节目单信息</span></span><br><span class="line">    <span class="type">msg_listdesc_t</span> *desc;</span><br><span class="line">    <span class="keyword">for</span> (desc = msg_list-&gt;list; (<span class="type">char</span> *)desc &lt; (<span class="type">char</span> *)msg_list + len; desc = (<span class="type">void</span> *)((<span class="type">char</span> *)desc + <span class="built_in">ntohs</span>(desc-&gt;deslength)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;chnid = %d, description = %s\n&quot;</span>, desc-&gt;chnid, desc-&gt;desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(msg_list); <span class="comment">// 释放节目单缓冲区</span></span><br><span class="line">    msg_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户选择频道</span></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;请输入收听的频道号码，按回车结束！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fflush</span>(<span class="literal">NULL</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;chosen);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配频道数据缓冲区</span></span><br><span class="line">    msg_channel = <span class="built_in">malloc</span>(MAX_CHANNEL_DATA);</span><br><span class="line">    <span class="keyword">if</span> (msg_channel == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc() : %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续接收数据</span></span><br><span class="line">    socklen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_channel, <span class="number">0</span>, MAX_CHANNEL_DATA);     <span class="comment">// 清空缓冲区</span></span><br><span class="line">        len = <span class="built_in">recvfrom</span>(sfd, msg_channel, MAX_CHANNEL_DATA, <span class="number">0</span>, (<span class="type">void</span> *)&amp;data_addr, &amp;socklen); <span class="comment">// 接收频道内容包</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="built_in">sizeof</span>(<span class="type">msg_channel_t</span>))&#123; <span class="comment">// UDP不是面向字节流的，接收的话就是一个包</span></span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is too short, len = %d...\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data_addr.sin_addr.s_addr != list_addr.sin_addr.s_addr || data_addr.sin_port != list_addr.sin_port)&#123;</span><br><span class="line">        <span class="comment">// 验证数据包和节目单数据包是否为同一服务端发送，防止干扰</span></span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;data is not match!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg_channel-&gt;chnid == chosen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;recv %d length data!\n&quot;</span>, len);</span><br><span class="line">            ret = <span class="built_in">writen</span>(fd[<span class="number">1</span>], msg_channel-&gt;data, len - <span class="built_in">sizeof</span>(msg_channel-&gt;chnid)); <span class="comment">// 写入管道</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉比webserver还要简单一些，就是这个里面的结构体各种定义很容易迷，这就是不如C++ class封装之处了。整体来看还是很值的做的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">张振强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/07/IPV4DUP/">http://example.com/2025/05/07/IPV4DUP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">张振强的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img class="cover" src="/img/load4.gif" data-original="/img/cover/6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ffmpeg</div></div><div class="info-2"><div class="info-item-1">C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++...</div></div></div></a><a class="pagination-related" href="/2025/07/17/muduo/" title="C++ Muduo 库"><img class="cover" src="/img/load4.gif" data-original="/img/cover/2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++ Muduo 库</div></div><div class="info-2"><div class="info-item-1">C++ Muduo 库https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac   noncopyable 禁止拷贝我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承noncopyable类，我们看一下noncopyable.h代码 #ifndef NONCOPYABLE_H#define NONCOPYABLE_Hclass noncopyable&#123;public:    noncopyable(const noncopyable&amp;) = delete;    noncopyable&amp; operator=(const noncopyable&amp;) = delete;protected:    noncopyable() = default;    ~noncopyable() =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/13/ThreadPool/" title="ThreadPool"><img class="cover" src="/img/load4.gif" data-original="/img/cover/4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">ThreadPool</div></div><div class="info-2"><div class="info-item-1">线程池项目基本概念线程池的概念： 线程池是一种用于优化线程管理和任务调度的并发编程机制，其核心在于复用线程、控制资源使用，并提升系统性能。 说白了就是，为了防止这么构造线程的浪费太多的时间，先把线程创建好，放在那等着，有任务提交的话就直接处理，省去了构造线程的过程 那么我们就可以想到一个线程池的最基础的构造 变量：  一个vector 用来存储构造好的线程 一个queue 用来存储task (利用先进先出的思想，先来先服务 嘛 ) mutex  有了queue自然得考虑到互斥的问题 condition_variable 条件变量 同mutex理 flag   停止标识  函数：  首先得有初始化函数，用来构造线程 (此处可以使用类的构造函数) 其次得有线程的释放join 的函数  （此处可以使用类的析构函数） 还有得有添加任务的函数  ThreadPool声明通过前面描述来声明一下CLASS class ThreadPool&#123;private:    std::vector&lt;std::thread&gt; workers;        // 工作线程集合   ...</div></div></div></a><a class="pagination-related" href="/2025/04/15/chatRoom/" title="chatRoom"><img class="cover" src="/img/load4.gif" data-original="/img/cover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">chatRoom</div></div><div class="info-2"><div class="info-item-1">chatRoom 项目git:https://github.com/zqzhang2023/zzqStudy 简单介绍：socket的简单应用，简单来说，就是一个服务端：server 许多个客户端：client1 client2 client3 client4… 现在要把这么多客户端拉到一个聊天室里面，实现群聊通信 实现方式：其实思想很简单，就是 client_i 向 server发送消息，然后server接收到消息之后，把消息转发给除却 client_i 之外的所有的 客户 这里主要学习 I&#x2F;O多路复用技术 之前学习的基础的 socket 是客户端 服务器 一对一的，现在需要服务器接收多个客户端的连接，因此需要用到 I&#x2F;O多路复用技术 I&#x2F;O多路复用技术为什么使用socket 中的许多操作会阻塞进程，比如服务端的accept 还有两端的 recv 等操作，如果要接受多个客户端，就不能阻塞进程。 有一种方法就是 多线程操作，每个线程接收一个，但是这种方法会严重的浪费内存空间，高并发的程序中 上千个客户端，就需要申请上千个线程 而且每一次切换线程...</div></div></div></a><a class="pagination-related" href="/2025/04/13/tinyhttpd/" title="Tinyhttpd"><img class="cover" src="/img/load4.gif" data-original="/img/cover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-13</div><div class="info-item-2">Tinyhttpd</div></div><div class="info-2"><div class="info-item-1">tinyhttpd 项目写在前面：这个项目是  J. David 大佬 在1999年做出来的，虽然很老旧, 而且手打一遍之后也感觉有些地方可能不适合这么写，但是做完这个项目之后学到的东西有很多很多，如果大家有时间的话，不妨跟着做一做，相信一定会有很大的收获 膜拜大佬！！！ GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 我这边加上注释的代码： 运行起来做之前需要先确定自己的环境能够正常把项目运行起来，要不然做的过程之中不知道是自己代码的问题还是环境的问题 我用的Linux ubuntu 提前安装了perl 地址在 &#x2F;usr&#x2F;bin&#x2F;perl(这个可以通过 which perl 命令得到) GIT 原始项目地址：https://github.com/EZLippi/Tinyhttpd 1.克隆下来，解压 这个不必对多说 2.执行make命令  会生成 httpd 与 client (会有一些警告，不必在意)  3.执行httpd(.&#x2F;httpd)  这个时候浏览器输入...</div></div></div></a><a class="pagination-related" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img class="cover" src="/img/load4.gif" data-original="/img/cover/5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">tinyWebServer</div></div><div class="info-2"><div class="info-item-1">tinyWebServer 项目写在前面： 学习了C++很久一直很想找个项目来做做看一看，验证一下自己目前的学习进度，于是在网上搜了一下，几乎每一篇博客都会有这个项目的推荐，也有人说这个项目做的人很多，不可以写在简历上。但是我觉得做的人很多就代表着很经典，咱们应该尝试着做一下。 刚开始看这个项目的代码的时候完全不知道如何下手，看也看不懂，搞的我都快怀疑自己的能力了。后来想了一下，确实不应该这么着急，可以提前了解一下项目的知识再重新来做一下。 于是就先做了三个小项目，每个项目都挺经典的，而且项目的代码量也很小。  线程池的项目：(主要学习线程池的概念和用法) 项目介绍：https://blog.zqzhang2025.com/2025/04/13/ThreadPool/ git链接：https://github.com/zqzhang2023/zzqStudy/tree/main/project/2_ThreadPool   tinyhttpd...</div></div></div></a><a class="pagination-related" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img class="cover" src="/img/load4.gif" data-original="/img/cover/6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">ffmpeg</div></div><div class="info-2"><div class="info-item-1">C++ FFMPEG 项目这个项目主要是为了学习FFMPEG 完整的主要功能 是 实现对一个封装格式的视频（比如MP4）进行解码，随后获取音视频采样的数据，通过实现音视频同步之后再调用音频驱动与视频取驱动进行播放 这里做了一些简化操作 完成的功能 是  解码之后再进行编码最后再将之组合一下 形成 一个新的 封装好的mp4文件 整体的框架是这样的：  FFMPEG介绍对于FFMPEG这个强大的的跨平台多媒体框架就不过多介绍了。咱们平时再用的时候主要是用他的命令行来进行操作。这个项目主要是使用C++结合FFMPEG对音视频进行处理。所以这里主要介绍一下C++...</div></div></div></a><a class="pagination-related" href="/2025/07/17/muduo/" title="C++ Muduo 库"><img class="cover" src="/img/load4.gif" data-original="/img/cover/2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-17</div><div class="info-item-2">C++ Muduo 库</div></div><div class="info-2"><div class="info-item-1">C++ Muduo 库https://www.bilibili.com/video/BV1UE4m1R72y/?spm_id_from=333.337.search-card.all.click&amp;vd_source=28887ecca1f25a715214067a2b3b58ac   noncopyable 禁止拷贝我们在看Muduo库代码的时候可以看到，基本上大多数class都会继承noncopyable类，我们看一下noncopyable.h代码 #ifndef NONCOPYABLE_H#define NONCOPYABLE_Hclass noncopyable&#123;public:    noncopyable(const noncopyable&amp;) = delete;    noncopyable&amp; operator=(const noncopyable&amp;) = delete;protected:    noncopyable() = default;    ~noncopyable() =...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/load4.gif" data-original="/img/paidaxing_icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张振强</div><div class="author-info-description">咱们都是最棒的</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zqzhang2023"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zqzhang2023" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_45769058" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1611379529&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:bzzhenqiang@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EIPV4%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E5%B9%BF%E6%92%AD"><span class="toc-number">1.</span> <span class="toc-text">基于IPV4的流媒体广播</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5"><span class="toc-number">2.</span> <span class="toc-text">运行起来</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">复现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">服务端：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#server-conf-h"><span class="toc-number">4.2.1.</span> <span class="toc-text">server_conf.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpool"><span class="toc-number">4.2.2.</span> <span class="toc-text">threadpool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tokenbucket"><span class="toc-number">4.2.3.</span> <span class="toc-text">tokenbucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#medialib"><span class="toc-number">4.2.4.</span> <span class="toc-text">medialib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">4.2.5.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">4.2.6.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-number">4.2.7.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.2.8.</span> <span class="toc-text">客户端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/17/muduo/" title="C++ Muduo 库"><img src="/img/load4.gif" data-original="/img/cover/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Muduo 库"/></a><div class="content"><a class="title" href="/2025/07/17/muduo/" title="C++ Muduo 库">C++ Muduo 库</a><time datetime="2025-07-17T02:05:26.162Z" title="发表于 2025-07-17 10:05:26">2025-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播"><img src="/img/load4.gif" data-original="/img/cover/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于IPV4的流媒体广播"/></a><div class="content"><a class="title" href="/2025/05/07/IPV4DUP/" title="基于IPV4的流媒体广播">基于IPV4的流媒体广播</a><time datetime="2025-05-07T09:43:42.756Z" title="发表于 2025-05-07 17:43:42">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/17/ffmpeg/" title="ffmpeg"><img src="/img/load4.gif" data-original="/img/cover/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ffmpeg"/></a><div class="content"><a class="title" href="/2025/04/17/ffmpeg/" title="ffmpeg">ffmpeg</a><time datetime="2025-04-17T14:51:36.000Z" title="发表于 2025-04-17 22:51:36">2025-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/tinyWebServer/" title="tinyWebServer"><img src="/img/load4.gif" data-original="/img/cover/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tinyWebServer"/></a><div class="content"><a class="title" href="/2025/04/15/tinyWebServer/" title="tinyWebServer">tinyWebServer</a><time datetime="2025-04-15T14:58:54.000Z" title="发表于 2025-04-15 22:58:54">2025-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/15/chatRoom/" title="chatRoom"><img src="/img/load4.gif" data-original="/img/cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chatRoom"/></a><div class="content"><a class="title" href="/2025/04/15/chatRoom/" title="chatRoom">chatRoom</a><time datetime="2025-04-15T14:57:54.000Z" title="发表于 2025-04-15 22:57:54">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 张振强</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>